<!DOCTYPE html>
<html lang='en'>
<head>
  <title>player.html</title>
  <meta charset='utf-8'>
  <meta name='description' content='Drop player.html in a folder of video and audio files and play them on the web' />
  <meta name='version' content='2.15.0'>
  <meta name='Copyright' content='&copy;2026 Paul Ellis'>
  <meta name='license' content='https://opensource.org/licenses/MIT'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0' />
  <link rel='shortcut icon'
    href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQBAMAAAAVaP+LAAAAMFBMVEX////+8vn+4fP+zuz+tuL+n9r+l9f+gc7+bMb+XcD+Rbj+MK/+Hqj+D6P+BZ/+AJ2hzeniAAABZ0lEQVR42u3UO3HDQABF0QdhISgMdiYEBEEAMokgWBBEQRAiCBYE2xAsCJLzmdTWZ1/KtClu5dkL4JRXuVwul8vl/tmzoF5bMb3tNQR5LSHISwFBngME+UJBHijop4MgpwaCvFUQ5DVCkO8FBHkMEJTOEOTUQ5BTB0H+PkBQ+ioZyF4iBHkOEOQrBXmgIL9TkBsK2msISmsEoL+nEJCnAEE+U1A6QpDdUdDeQJC3EoK8RAjyLUCQRwpKJwiyewpKLQR5ryHIawlB/iggKE2BgewLBfkIQamFoF4MNIiBrmKgOTDQEoVAWykE2hsxUCcG6sVAZzHQFBjoXgiB1igE2iohUGrEQJ0YaBADXcVAc2CgJQqBtlIItB+EQKkVA/VioJMYaAwMdC+EQJ9RCLRVQqDUiIE6MdBRDHQRA02BgZZCCLSWQqC9FgKlVgzUi4FOYqBRDHQrGGiJQnqpxPSkXC6Xy+VyD9ovn971FIU9/uIAAAAASUVORK5CYII=' />
  
  <style type='text/css' primary>    *,
    *:before,
    *:after {
      -moz-box-sizing: border-box;
      -webkit-box-sizing: border-box;
      box-sizing: border-box;

      user-select: none;

      line-height: 1em;

      touch-action: manipulation;
    }

    html {
      --player-aspect-ratio: calc(9/16);
      --tile-aspect-ratio: var(--player-aspect-ratio);
      --tile-width: 24rem;
      --tile-height: calc(var(--tile-width) * var(--tile-aspect-ratio));
      --tile-border-radius: 0.6rem / 0.5rem;
      --tile-font-color: var(--tile-font-color-dark);
      --tile-title-background-color: var(--tile-title-background-color-dark);
      --tile-background-color: var(--tile-background-color-dark);
      --inter-tile-margin: 1rem;

      --modal-font-color: var(--tile-font-color);

      --progress-bar-background-color: hsl(var(--theme-hue), 100%, 95%);
      --progress-bar-position-color: var(--theme-color);
      --progress-bar-height: 1rem;
      --progress-bar-buffer-color: hsl(var(--theme-hue), 40%, 80%);
      --trick-preview-width: max(10vw, 100px);

      --base-background-color: var(--base-background-color-dark);
      --base-overlay-color: 128,128,128;

      --default-hue: 323;
      --theme-hue: var(--default-hue);
      --theme-color-base: var(--theme-hue), 100%, 50%;
      --theme-color: hsl(var(--theme-color-base));

      --folder-color: hsl(44,100%,68%);
      --file-color: #FFF;
      --playing-color: hsl(var(--theme-hue), 100%, 85%);

      --primary-font-color: var(--primary-font-color-dark);
      --secondary-font-color: var(--secondary-font-color-dark);

      --modal-background-color: var(--modal-background-color-dark);
      --thumbnail-overlay-color: rgba(64,64,64,0.2);

      --transition-base: 300ms;
      --blur-base: 1rem;

      --subtitle-font-family: system-ui, 'Segoe UI', Calibri, Arial, Helvetica, sans-serif;
      --subtitle-font-size: 100%;
      --subtitle-color: #ffffff;
      --subtitle-background-color: #000000;

      font-family: system-ui, 'Segoe UI', Calibri, Arial, Helvetica, sans-serif;
      font-size: 12px;
      background-color: var(--base-background-color);
      color: var(--primary-font-color);
    }

    @media (prefers-reduced-motion) {
      * {
        --transition-base: 0;
        transition: none !important;
        animation: none !important;
      }
    }

    html {
      /* Light mode colors */
      --base-background-color-light: white;
      --primary-font-color-light: hsl(var(--theme-hue), 10%, 40%);
      --secondary-font-color-light: hsl(var(--theme-hue), 25%, 75%);
      --tile-font-color-light: white;
      --tile-title-background-color-light: hsla(var(--theme-hue), 15%, 50%, 80%);
      --tile-background-color-light: hsl(var(--theme-hue), 50%, 97%);
      --modal-background-color-light: hsla(var(--theme-hue), 100%, 95%, 0.5);

      /* Dark mode colors */
      --base-background-color-dark: black;
      --primary-font-color-dark: hsl(var(--theme-hue), 50%, 90%);
      --secondary-font-color-dark: hsl(var(--theme-hue), 10%, 40%);
      --tile-font-color-dark: hsl(var(--theme-hue), 50%, 95%);
      --tile-title-background-color-dark: hsla(var(--theme-hue), 15%, 20%, 80%);
      --tile-background-color-dark: hsl(var(--theme-hue), 10%, 12.5%);
      --modal-background-color-dark: hsla(var(--theme-hue), 30%, 15%, 0.5);
    }

    :fullscreen html      { --base-background-color: hsl(var(--theme-hue), 100%, 4%); }

    :fullscreen, :fullscreen * {
      --modal-background-color: hsla(var(--theme-hue), 30%, 15%, 0.5);
    }

    body {
      display: grid;
      grid-template-areas:
        "player-container"
        "controls"
        "links"
        "footer";
      grid-template-rows: min-content min-content minmax(calc(var(--tile-height) * 2), auto) min-content;
      grid-template-columns: 1fr;

      padding: 0;
      margin: 0 auto;
    }

    .player-container {
      grid-area: player-container;
      display: grid;
      grid-template-areas:
        "player"
        "controls";
      grid-template-rows: min-content min-content;
      grid-template-columns: 1fr;


      position: relative;
      width: 100%;
      min-height: 30vw;

      z-index: 1000;
    }

    .is-audio .player-container {
      min-height: unset;
    }

    /* These two declarations must be separate. When combining the selectors Firefox doesn't apply this CSS */
    .player-container:-webkit-full-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%; /* webkit doesn't do this automatically */
      height: 100%; /* webkit doesn't do this automatically */
    }
    .player-container:fullscreen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .player-container.drop:before {
      display: flex;
      align-items: center;
      justify-content: center;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      content: "Drop Here";
      font-size: 5rem;
      text-shadow: 0px 0px 1.5rem #000;
      background-color: rgba(64,64,64,0.5);
      background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjRweCIgaGVpZ2h0PSIyNHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHBhdGggZmlsbD0iaHNsKDMyMywgMTAwJSwgNTAlKSIgZD0iTTEyLDIgQzE3LjUyMjgsMiAyMiw2LjQ3NzE1IDIyLDEyIEMyMiwxNy41MjI4IDE3LjUyMjgsMjIgMTIsMjIgQzYuNDc3MTUsMjIgMiwxNy41MjI4IDIsMTIgQzIsNi40NzcxNSA2LjQ3NzE1LDIgMTIsMiBaIE0xMiw0IEM3LjU4MTcyLDQgNCw3LjU4MTcyIDQsMTIgQzQsMTYuNDE4MyA3LjU4MTcyLDIwIDEyLDIwIEMxNi40MTgzLDIwIDIwLDE2LjQxODMgMjAsMTIgQzIwLDcuNTgxNzIgMTYuNDE4Myw0IDEyLDQgWiBNMTIsNiBDMTUuMzEzNyw2IDE4LDguNjg2MjkgMTgsMTIgQzE4LDE1LjMxMzcgMTUuMzEzNywxOCAxMiwxOCBDOC42ODYyOSwxOCA2LDE1LjMxMzcgNiwxMiBDNiw4LjY4NjI5IDguNjg2MjksNiAxMiw2IFogTTEyLDggQzkuNzkwODYsOCA4LDkuNzkwODYgOCwxMiBDOCwxNC4yMDkxIDkuNzkwODYsMTYgMTIsMTYgQzE0LjIwOTEsMTYgMTYsMTQuMjA5MSAxNiwxMiBDMTYsOS43OTA4NiAxNC4yMDkxLDggMTIsOCBaIE0xMiwxMCBDMTMuMTA0NiwxMCAxNCwxMC44OTU0IDE0LDEyIEMxNCwxMy4xMDQ2IDEzLjEwNDYsMTQgMTIsMTQgQzEwLjg5NTQsMTQgMTAsMTMuMTA0NiAxMCwxMiBDMTAsMTAuODk1NCAxMC44OTU0LDEwIDEyLDEwIFoiPjwvcGF0aD48L3N2Zz4=');
      background-size: 25%;
      background-position: center;
      background-repeat: no-repeat;
      animation: pulse calc(2 * var(--transition-base)) ease-in-out alternate infinite;
      z-index: 2000;    }

    @keyframes pulse {
      0%   { opacity: 100%; }
      100% { opacity: 50% }
    }

    /* These two declarations must be separate. When combining the selectors Firefox doesn't apply this CSS */
    :-webkit-full-screen.fadeout { cursor: none; }
    :fullscreen.fadeout { cursor: none; }

    .media-container {
      position: relative;
      width: 100%;
      background: black;
      overflow: hidden;
    }

    .is-audio .media-container {
      margin-top: 1rem;
    }

    .media-title {
      position: absolute;
      top: 0;
      left: 0;
      margin: 1rem 0 0 1.5rem;
      font-size: 1.5em;
      color: rgba(255,255,255,0);
      transition: color var(--transition-base);
    }
    
    .player:hover + .media-title {
      color: rgba(255,255,255,1);
    }

    .player {
      grid-area: player;
      width: 100%;
      max-height: 75vh;
      margin: auto;
      background-image: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0nVVRGLTgnIHN0YW5kYWxvbmU9J25vJz8+DQo8c3ZnIHdpZHRoPSc1NycgaGVpZ2h0PSczNScgdmlld0JveD0nMCAwIDU1IDM2JyB2ZXJzaW9uPScxLjEnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc+DQogIDxnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDQsLTYuOTUyNTA4KSc+DQogICAgPHBhdGggc3R5bGU9J2ZpbGw6IGhzbCggIDMyMywgMTAwJSwgNTAlKScgZD0nTSAxMy43NTAxMzQsOC40MTIxMjAzIDM4LjE2NzE4OSwyMS4xMTY5MjkgYyAxLjU5MjI3NiwwLjgyODUwMiAyLjIxMTQzOCwyLjc5MDkyOSAxLjM4MjkzNiw0LjM4MzIwNSAtMC4zMDgwNTEsMC41OTIwMzcgLTAuNzkwODk5LDEuMDc0ODg1IC0xLjM4MjkzNiwxLjM4MjkzNyBMIDEzLjc1MDEzNCwzOS41ODc4OCBDIDEyLjE1Nzg1OCw0MC40MTYzODEgMTAuMTk1NDMxLDM5Ljc5NzIxOSA5LjM2NjkyOTMsMzguMjA0OTQzIDkuMTI1ODYzLDM3Ljc0MTY0NCA5LDM3LjIyNzA3MiA5LDM2LjcwNDgwOSBWIDExLjI5NTE5MSBjIDAsLTEuNzk0OTI1NCAxLjQ1NTA3NSwtMy4yNSAzLjI1LC0zLjI1IDAuNDQ3NjU0LDAgMC44ODk2NTgsMC4wOTI0NzEgMS4yOTg1NjYsMC4yNzA2OTk1IHogbSAtMS4xNTM5NDksMi4yMTc3NDY3IC0wLjExMDQ4NywtMC4wNDY2OCBjIC0wLjA3NTc5LC0wLjAyNTA5IC0wLjE1NTM1LC0wLjAzOCAtMC4yMzU2OTgsLTAuMDM4IC0wLjQxNDIxNCwwIC0wLjc1LDAuMzM1Nzg2IC0wLjc1LDAuNzUgdiAyNS40MDk2MTggYyAwLDAuMTIwNTIyIDAuMDI5MDQsMC4yMzkyNyAwLjA4NDY4LDAuMzQ2MTg1IDAuMTkxMTkzLDAuMzY3NDQ4IDAuNjQ0MDYxLDAuNTEwMzMyIDEuMDExNTA5LDAuMzE5MTM5IEwgMzcuMDEzMjQsMjQuNjY1MzI0IGMgMC4xMzY2MjQsLTAuMDcxMDkgMC4yNDgwNSwtMC4xODI1MTUgMC4zMTkxMzksLTAuMzE5MTM5IDAuMTkxMTkyLC0wLjM2NzQ0OSAwLjA0ODMxLC0wLjgyMDMxNiAtMC4zMTkxMzksLTEuMDExNTA5IHonLz4NCiAgPC9nPg0KPC9zdmc+');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;

      transition: filter calc(0.5 * var(--transition-base));
      will-change: filter;
    }

    .player::cue {
      font-family: var(--subtitle-font-family);
      font-size: var(--subtitle-font-size);
      color: var(--subtitle-color);
      background-color: var(--subtitle-background-color);
    }

    body:not(.is-loaded) .player {
      min-height: max(20vw, 33vh);
    }

    .is-audio .player {
      min-height: 50vh;
      background-size: contain;
    }

    /* These two declarations must be separate. When combining the selectors Firefox doesn't apply this CSS */
    /* There should *not* be a space between `:fullscreen` and `.player` as webkit makes the `<video>` element full screen */
    :-webkit-full-screen.player {
      margin: 0;
      max-height: 100%;
      background: black !important; /* `!important` must be used to override inline styles */
    }
    /* There *must* be a space between `:fullscreen` and `.player` as other browsers allow non-<video> elements to be the fullscreen root */
    :fullscreen .player {
      margin: 0;
      max-height: 100%;
      background: black !important; /* `!important` must be used to override inline styles */
    }

    .modal.show ~ .modal-background-overlay {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: transparent;
    }

    .modal {
      z-index: 100;
      display: flex;
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      min-width: 40vw;
      max-width: 100vw;
      overflow-x: auto;

      color: var(--modal-font-color);

      margin: 0;
      transform: translateX(-100vw);
      transition:
        transform var(--transition-base) ease,
        backdrop-filter var(--transition-base) ease;
      will-change: transform, backdrop-filter;
      padding: 1rem;

      align-items: center;
      justify-content: flex-start;
      flex-direction: column;
      gap: 0.1rem;

      list-style: none;

      background-color: var(--modal-background-color);
      background-image: linear-gradient(to right, rgba(0,0,0,0.1), rgba(0,0,0,0));
      -webkit-backdrop-filter: blur(var(--blur-base));
      backdrop-filter: blur(var(--blur-base));
    }
    .modal.show { transform: translateX(0); }

    .modal:before {
      display: block;
      width: 100%;
      padding: 0.5rem 0.25rem;
      color: #FFF;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 0.8rem;
    }
    .subtitle-selection:before { content: "Select a subtitle below"; }
    .settings:before { content: "Settings"; }
    .fileinfo:before { content: "File metadata"; }
    .help:before { content: "Keyboard Shortcuts" }
    .playlist:before { content: "Playlist"; }

    .modal-item {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      padding: 1rem;
      width: 100%;
      position: relative;
      margin: 0;
      background-color: rgba(0,0,0,0.25);
    }
    .modal-item:first-of-type {
      border-top-left-radius: 0.75rem;
      border-top-right-radius: 0.75rem;
    }
    .modal-item:last-of-type {
      border-bottom-left-radius: 0.75rem;
      border-bottom-right-radius: 0.75rem;
    }
    .modal-item .desc { overflow: hidden; }

    .subtitle-item { cursor: pointer; }
    .subtitle-section-heading {
      pointer-events: none;
      cursor: default;
      padding: 0.6rem 0.25rem;
      background: transparent;
      border-radius: 0 !important;
      color: #FFF;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 0.8rem;
    }
    .subtitle-settings-heading {
      margin-top: 0.75rem;
      padding-top: 0.85rem;
      border-top: 1px solid rgba(255,255,255,0.2);
    }
    .help-item { max-width: 320px; }

    .fileinfo-item .key, .help-item .key, .setting-item .key {
      display: inline-block;
      width: 10rem;
      margin-right: 1rem;
      font-weight: bold;
    }

    .fileinfo-item .value, .setting-item .value {
      display: inline-block;
      width: calc(100% - 11rem);
      user-select: text;
    }

    .help-item .key {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 12ch;
      padding: 0.75em;
      border-radius: var(--tile-border-radius);
      background-color: #333;
      text-align: center;
      gap: 1rem;
      font-weight: normal;
      font-family: Consolas, 'Courier New', Courier, monospace;
    }

    .help-item .desc { display: inline-block; }

    .modal input, .modal button {
      position: relative;
      -webkit-appearance: none;
      appearance: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 3.5rem;
      height: 2rem;
      z-index: 50;
      cursor: pointer;
      font-size: 0.9rem;
      overflow: hidden;
      color: black;
      border-radius: 2rem;
      outline: none;

      --input-background-color: #999;
      --input-slider-color: #FFF;
    }

    .modal select {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: auto;
      min-width: 3.5rem;
      height: 2rem;
      padding: 0 0.25rem 0 0.75rem;
      font-size: 0.9rem;
      color: black;
      border-radius: 2rem;
      outline: none;
      cursor: pointer;
      background-color: #FFF;
      border: 0 none;
      text-align: left;
      text-align-last: left;
    }
    .modal input:checked {
      --input-background-color: var(--theme-color);
    }

    .modal .reset-defaults {
      border: 0 none;
      background-color: var(--theme-color);
      color: #FFF;
    }
    .modal .reset-defaults:hover {
      background-color: hsl(var(--theme-hue), 50%, 60%);
    }
    .modal .reset-defaults:active {
      background-color: hsl(var(--theme-hue), 50%, 40%);
      padding-top: 0.25rem;
    }

    .modal .setting-cache + .metadata {
      margin-left: 1rem;
    }

    .modal .setting-cache + .metadata::after {
      content: 'KB';
    }

    .modal input[type=button] {
      background-color: var(--theme-color);
      border: 0 none;
      color: #FFF;
      text-shadow: black 0 0 2px;
    }

    .modal input[type='color'] {
      width: 2rem;
      border: 0 none;
      padding: 0;
      background-color: var(--input-background-color);
    }
    .modal input.setting-hue { --input-background-color: var(--theme-color); }
    .modal input.setting-subtitle-color { --input-background-color: var(--subtitle-color); }
    .modal input.setting-subtitle-background { --input-background-color: var(--subtitle-background-color); }

    .modal input[type='color']::-webkit-color-swatch-wrapper {
      padding: 0;
      border-radius: inherit;
    }
    .modal input[type='color']::-webkit-color-swatch {
      border: 0 none;
      border-radius: inherit;
    }
    .modal input[type='color']::-moz-color-swatch {
      border: 0 none;
      border-radius: inherit;
    }

    .modal input[type='checkbox'] {
      --width: 3.5rem;
      --diameter: 2rem;
      --spacing: 2px;
    }

    /* Checkbox background */
    .modal input[type='checkbox']:before {
      content: '';
      display: flex;
      width: 100%;
      height: 100%;

      border-radius: var(--diameter);
      background-color: var(--input-background-color);
      transition:
        left var(--transition-base),
        background-color var(--transition-base);
      will-change: left, background-color;
      color: hsl(var(--theme-hue), 100%, 4%);
    }

    /* Checkbox slider */
    .modal input[type='checkbox']:after {
      content: 'off';
      background-color: white;
      border-radius: 50%;
      height: calc(var(--diameter) - (var(--spacing) * 2));
      width:  calc(var(--diameter) - (var(--spacing) * 2));
      position: absolute;
      top: var(--spacing);
      left: var(--spacing);
      padding: 1px;
      transition: transform var(--transition-base);
      will-change: transform;

      display: flex;
      justify-content: center;
      align-items: center;
      filter: drop-shadow(0 0 5px rgba(0,0,0,0.5));
    }
    .modal input[type='checkbox']:checked:after {
      content: 'on';
      transform: translateX(calc(var(--width) - var(--diameter)));
    }

    .playlist .playlist-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      width: 100%;
      justify-content: flex-start;
    }

    .playlist .playlist-controls button {
      width: auto;
      height: auto;
      padding: 0.35rem 0.75rem;
      border-radius: 1rem;
      background-color: rgba(0,0,0,0.2);
      color: var(--modal-font-color);
      border: 0 none;
      gap: 0.35rem;
    }

    .playlist .playlist-controls button svg {
      width: 1rem;
      height: 1rem;
      fill: var(--modal-font-color);
    }

    .playlist-item {
      justify-content: space-between;
      gap: 0.75rem;
    }

    .playlist-item .playlist-label {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .playlist-item.current {
      background-color: rgba(0,0,0,0.4);
    }

    .playlist-item .playlist-actions {
      display: flex;
      gap: 0.35rem;
    }

    .playlist-item .playlist-actions button {
      width: 2rem;
      height: 2rem;
      padding: 0;
      border-radius: 999px;
      border: 0 none;
      background-color: transparent;
    }

    .playlist-item .playlist-actions svg {
      width: 1.5rem;
      height: 1.5rem;
      fill: var(--modal-font-color);
    }

    .playlist-empty {
      justify-content: center;
      opacity: 0.7;
    }

    .color-scheme-change-transition, .color-scheme-change-transition * {
      --transition-args: calc(var(--transition-base) * 3) ease;
      transition:
        background-color var(--transition-base),
        background-image var(--transition-base),
        color            var(--transition-base),
        fill             var(--transition-base);
    }

    .controls {
      grid-area: controls;

      display: grid;
      grid-template-areas:
        "progress-bar       progress-bar     progress-bar"
        "secondary-controls primary-controls settings-controls";
      grid-template-rows: calc(1rem + var(--progress-bar-height)) min-content;
      grid-template-columns: 1fr auto 1fr;
      row-gap: 1.25rem;

      position: relative;
      padding: 1rem;
      width: 100%;
      text-align: center;

      color: var(--primary-font-color);

      transition: transform var(--transition-base);
      will-change: transform;
      transform: none;
    }
    /* These two declarations must be separate. When combining the selectors Firefox doesn't apply this CSS */
    :-webkit-full-screen .controls {
      position: absolute;
      bottom: 0;
      background-color: rgba(var(--base-overlay-color), 1);
      --base-overlay-color: 0,0,0;

      transform: none;
    }
    :fullscreen .controls  {
      position: absolute;
      bottom: 0;
      background-color: rgba(var(--base-overlay-color), 1);
      --base-overlay-color: 0,0,0;

      transform: none;
    }
    :-webkit-full-screen.fadeout .controls { transform: translateY(100%); }
    :fullscreen.fadeout .controls  { transform: translateY(100%); }

    .controls button {
      display: inline-flex;
      justify-content: center;
      align-items: center;
      border: 0 none;
      outline: none;

      width: min(10vw, 2.5rem);
      height: min(10vw, 2.5rem);

      margin: 0rem 0.1rem;
      padding: 0;

      background: none;
      cursor: pointer;
    }

    .controls button:focus-visible,
    .modal input:focus-visible,
    .modal button:focus-visible,
    .links a:focus-visible,
    .links .btn-add-to-playlist:focus-visible,
    .playlist .playlist-actions button:focus-visible {
      outline: 2px solid var(--theme-color);
      outline-offset: 3px;
      border-radius: 3px;
    }

    .controls button svg {
      fill: var(--theme-color);
      min-width: 100%;
      min-height: 100%;
      max-width: 100%;
      max-height: 100%;
    }

    .no-subtitles .btn-subtitles svg { fill: hsl(var(--theme-hue), 0%, 50%); }
    .is-audio .btn-subtitles         { display: none !important; }
    .controls button:hover       svg { fill: hsl(var(--theme-hue), 70%, 75%); }
    .controls button:active      svg { fill: hsl(var(--theme-hue), 100%, 33%); }
    .controls .stop svg { margin: 0 0.5rem; }

    .primary-buttons .level-0, .primary-buttons .level-1, .primary-buttons .level-2, .primary-buttons .level-3 {
      display: none;
    }

    .primary-buttons.volume-0 .level-0, .primary-buttons.volume-1 .level-1, .primary-buttons.volume-2 .level-2, .primary-buttons.volume-3 .level-3 {
      display: inline-block;
    }

    .controls .btn-playback-rate:after {
      display: block;

      color: var(--base-background-color);
      content: var(--playback-rate) 'x';
      position: absolute;
      text-align: center;

      font-weight: bold;
      font-size: min(2vw, 0.75rem);
      font-family: Arial, Helvetica, sans-serif;
    }

    /* Reset to show none */
    .btn-play-pause .pause, .btn-play-pause .play {
      display: none;
    }

    /* Show play button by default */
    .btn-play-pause .play {
      display: inline-block;
    }

    /* Loaded AND Playing */
    /* Hide play button */
    .is-loaded.is-playing .btn-play-pause .play { display: none; }
    /* Show pause button */
    .is-loaded.is-playing .btn-play-pause .pause { display: inline-block; }

    button.btn-fullscreen                          { display: none; }
    button.btn-fullscreen.enabled                  { display: inline-block; }
    .btn-fullscreen .collapse                      { display: none; } /* Hide `.collapse` by default */
    .btn-fullscreen .expand                        { display: block; } /* Show `.expand` by default */
    :-webkit-full-screen .btn-fullscreen .collapse { display: block; } /* Show collapse in fullscreen mode */
    :fullscreen          .btn-fullscreen .collapse { display: block; }
    :-webkit-full-screen .btn-fullscreen .expand   { display: none; } /* Hide collapse in fullscreen mode */
    :fullscreen          .btn-fullscreen .expand   { display: none; }
    .is-audio .btn-fullscreen                      { display: none !important; }
    
    button.btn-pip          { display: none; }
    button.btn-pip.enabled  { display: inline-block; }
    .btn-pip .exit          { display: none; } /* Hide `.exit` by default */
    .btn-pip .enter         { display: block; } /* Show `.enter` by default */
    .is-pip .btn-pip .exit  { display: block; }
    .is-pip .btn-pip .enter { display: none; }
    .is-audio .btn-pip      { display: none !important; }

    .btn-loop .loop-off { display: none; }
    .playlist-loop-off .btn-loop .loop-on { display: none; }
    .playlist-loop-off .btn-loop .loop-off { display: block; }

    .btn-previous,
    .btn-next {
      display: none;
    }
    .playlist-multiple .btn-previous,
    .playlist-multiple .btn-next {
      display: inline-flex;
    }

    .current-timestamp {
      grid-area: progress-bar;
      display: block;
      position: absolute;
      right: 0;
      top: 0;
      margin-top: calc(0.6rem + var(--progress-bar-height));
    }

    .current-timestamp .position:before { content: var(--absolute-position); }
    .current-timestamp .duration:before { content: var(--duration); }
    .current-timestamp .divider:before  { content: ' / '; }

    .progress-bar {
      grid-area: progress-bar;
      display: flex;
      align-items: center;

      z-index: 2000;
      cursor: pointer;

      position: relative;
      top: 0;
      left: 0;
      width: 100%;
      height: var(--progress-bar-height);

      border-radius: 10rem;

      background-color: var(--progress-bar-background-color);
    }

    .progress-bar::after, .progress-bar::before {
      --duration: 250ms;

      transition: all var(--duration) linear;
      transition-property: left, transform, width;
    }
    .is-paused .progress-bar::after,
    .is-paused .progress-bar::before,
    .is-stopped .progress-bar::after,
    .is-stopped .progress-bar::before {
      transition-duration: calc((1000/60) * 5); /* 3 frames */
      transition-timing-function: ease-in-out;
    }

    /* Bar */
    .progress-bar:before {
      display: block;
      content: '';
      border-radius: 1rem 0 0 1rem;
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: var(--relative-position);
      background-color: var(--progress-bar-position-color);
      margin-bottom: calc(0.4rem + var(--progress-bar-height));
    }

    /* Indicator */
    .progress-bar:after {
      content: '';
      display: block;
      position: absolute;

      --indicator-position: clamp(0.45rem, var(--relative-position), calc(100% - 0.45rem));
      --indicator-size: calc(var(--progress-bar-height) + 0.4rem);
      left: clamp(
        calc(var(--indicator-size) / 2),
        var(--indicator-position),
        calc(100% - (var(--indicator-size) / 2)));
      width: var(--indicator-size);
      height: var(--indicator-size);

      margin-left: calc(var(--indicator-size) * -0.5);

      background: hsl(var(--theme-hue), 100%, 95%);
      border: calc(var(--indicator-size) / 4) solid var(--theme-color);
      border-radius: 50%;
      filter: drop-shadow(0px 0px 1px black);
    }

    .trick-container {
      display: flex;
      align-items: center;
      justify-content: center;
      top: calc(1rem + var(--progress-bar-height));
      left: clamp(
        calc(var(--trick-preview-width)/2 + 1rem),
        var(--trick-position),
        calc(100% - var(--trick-preview-width)/2 - 1rem)
      );
      width: var(--trick-preview-width);
      margin-left: calc(var(--trick-preview-width) * -0.5);

      position: absolute;
      max-height: 0%;
      overflow: hidden;
      border-radius: 0 0 0.5rem 0.5rem;
      background: rgb(32,32,32);
      transition: max-height var(--transition-base);
      will-change: max-height;
      border: 0 none;
      box-shadow: 0 0 10px black;
      z-index: 1000;
    }

    .is-audio .trick-container {
      display: none;
    }

    .trick-container:after {
      content: '';
      width: 100%;
      height: 1rem;
      position: absolute;
      top: 0;
      left: 0;
      background-image: linear-gradient(to bottom, black, transparent);
    }  
    
    .trick {
      display: block;
      min-width: 102%;
      min-height: 102%;
      margin-left: -1%;
      margin-top: -1%;
      border: 0 none;
      filter: blur(0.5px);
      object-fit: cover;
    }  

    .is-loaded .progress-bar:hover + .trick-container {
      border: 1px solid transparent;
      height: calc(var(--trick-preview-width) * var(--player-aspect-ratio));
      max-height: 100%;
    }

      /* Only show this button if cloud streaming is enabled/possible */
    .controls .btn-cloud {
       display: none;
       padding: 0.25rem;
       max-height: 2.5rem;
    }
    .controls .btn-cloud:hover { filter: brightness(1.25); }
    .controls .btn-local-file { margin: 0 -0.15rem; }
    .controls .btn-onedrive { padding: 0 0.1rem; }

    .controls .btn-fileinfo { display: none; }
    .is-loaded .controls .btn-fileinfo { display: initial; }

    .primary-buttons {
      grid-area: primary-controls;
      display: flex;
      width: 100%;
      position: relative;
      justify-content: center;
      align-items: end;
    }

    .controls-settings {
      grid-area: settings-controls;

      display: flex;
      justify-content: flex-end;
      align-items: center;
    }

    .controls-sources {
      grid-area: secondary-controls;
      display: flex;
      justify-content: flex-start;
      align-items: center;
    }

    .links {
      z-index: 500;
      grid-area: links;

      display: grid;
      gap: var(--inter-tile-margin);
      grid-template-columns: repeat(auto-fill, var(--tile-width));
      justify-content: center;

      max-width: 100vw;
      margin-top: 1rem;

      padding-bottom: 2rem;
    }

    .links a {
      /* background */
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;

      width: var(--tile-width);
      height: var(--tile-height);

      padding: 0;
      border-radius: var(--tile-border-radius);

      background-color: var(--tile-background-color);
      color: var(--tile-font-color);
      text-decoration: none;

      /* Oversize the background to crop off bad video edges */
      background-size: cover;
      background-position: center;
      background-origin: border-box;
      background-repeat: no-repeat;

      background-image: var(--image-url-0, var(--image-fallback, none));
      animation: animateThumbnail 1000ms infinite;
      animation-play-state: paused;
    }
    .links a.prerendered { animation: none; }
    .links a:hover { animation-play-state: running; }
    .no-thumbnail-animation .links a { animation: unset; }

    .links a .title {
      /* Title */
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      bottom: 0;
      left: 0;

      width: 100%;

      overflow-wrap: break-word;
      font-size: 1.25rem;
      line-height: 1.5rem;
      text-align: left;
      padding: 1rem;

      background-color: var(--tile-title-background-color);
      border-radius: 0 0 var(--tile-border-radius) var(--tile-border-radius);

      -webkit-backdrop-filter: blur(var(--blur-base) / 4);
      backdrop-filter: blur(var(--blur-base) / 4);
    }

    .links a .title .label {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 2rem;
    }

    .folder .title {
      justify-content: space-between;
    }

    .folder .title .folder-label {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      flex: 1;
      min-width: 0;
    }

    .folder .title .label {
      flex: 1;
      min-width: 0;
    }

    .links .btn-add-to-playlist {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: auto;
      height: auto;
      border-radius: 0;
      border: 0 none;
      background: none;
      box-shadow: none;
      color: inherit;
      cursor: pointer;
      opacity: 0.85;
    }

    .links .btn-add-to-playlist svg {
      width: 1.5rem;
      height: 1.5rem;
    }

    .links a:hover .btn-add-to-playlist { opacity: 1; }

    .links a.parent .title::after {
      content: '[Parent Folder]';
    }
    .links a.parent .title .label {
      display: none;
    }


    .links a .title .icon {
      display: none;
    }

    .links a.parent .title .icon {
      display: initial;
    }

    .folder .title svg {
      height: 1em;
      width: 1em;
      margin-bottom: -0.18em;
    }

    .file.audio-file {
      --image-fallback: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCjxwYXRoIGQ9Ik0xNS45ODY3IDMuMDE1NzZDMTUuODkwOCAyLjQzMDE4IDE1LjI5MTkgMi4wNDE0OCAxNC43MDE3IDIuMjI1OUw3LjcwMTczIDQuNDEzNEM3LjI4NDI1IDQuNTQzODcgNyA0LjkzMDUgNyA1LjM2Nzg4VjEzLjUwMDFDNi41ODIxNyAxMy4xODYzIDYuMDYyOCAxMy4wMDAzIDUuNSAxMy4wMDAzQzQuMTE5MjkgMTMuMDAwMyAzIDE0LjExOTYgMyAxNS41MDAzQzMgMTYuODgxIDQuMTE5MjkgMTguMDAwMyA1LjUgMTguMDAwM0M2Ljg4MDcxIDE4LjAwMDMgOCAxNi44ODEgOCAxNS41MDAzVjguMzY3OTNMMTUgNi4xODA0M1Y5LjAyMjczQzE1LjM0MzQgOS4wNTM2NyAxNS42Nzc3IDkuMTE2MTggMTYgOS4yMDczNFYzLjE4MDQzQzE2IDMuMTI0MTEgMTUuOTk1NCAzLjA2OTA5IDE1Ljk4NjcgMy4wMTU3NlpNMTkgMTQuNTAwMkMxOSAxNi45ODU1IDE2Ljk4NTMgMTkuMDAwMiAxNC41IDE5LjAwMDJDMTIuMDE0NyAxOS4wMDAyIDEwIDE2Ljk4NTUgMTAgMTQuNTAwMkMxMCAxMi4wMTUgMTIuMDE0NyAxMC4wMDAyIDE0LjUgMTAuMDAwMkMxNi45ODUzIDEwLjAwMDIgMTkgMTIuMDE1IDE5IDE0LjUwMDJaTTE2LjczNjcgMTQuMDY0NUwxMy43NDI2IDEyLjQxNDRDMTMuNDA5NCAxMi4yMzA4IDEzLjAwMTMgMTIuNDcxOCAxMy4wMDEzIDEyLjg1MjNMMTMuMDAxMyAxNi4xNTI0QzEzLjAwMTMgMTYuNTMyOSAxMy40MDkzIDE2Ljc3MzkgMTMuNzQyNiAxNi41OTAzTDE2LjczNjYgMTQuOTQwNEMxNy4wODE1IDE0Ljc1MDMgMTcuMDgxNiAxNC4yNTQ2IDE2LjczNjcgMTQuMDY0NVoiIGZpbGw9IiM0NDQ0NDQiLz4NCjwvc3ZnPg0K');
      background-size: contain;
    }

    .folder .arrow,
    .file .arrow {
      /* Arrow */
      font-size: 3rem;

      display: block;
      text-align: center;
      padding: 0;
    }

    .file .arrow { filter: drop-shadow(0 0 0.1rem rgba(0, 0, 0, 0.5)); }

    .file:hover .arrow svg,
    .folder:hover .arrow svg,
    .file.current .arrow svg {
      transform: rotate(360deg);
      width: calc(var(--tile-width) / 3);
    }

    .file .arrow svg, .folder .arrow svg {
      width: calc(var(--tile-width) / 5);
      will-change: width, transform;
    }

    .file svg, .folder svg {
      --transition-options: calc(2 * var(--transition-base)) ease;
      transition:
        fill var(--transition-options),
        background-blend-mode var(--transition-options),
        transform  var(--transition-options),
        width var(--transition-options),
        height var(--transition-options);
      will-change: fill, background-blend-mode, transform, width, height;
    }
    .file svg { fill: var(--file-color); }
    .folder svg { fill: var(--folder-color); }

    .current { background-blend-mode: luminosity; }
    .current::before {
      content: "";
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      background-color: hsla(var(--theme-hue), 50%, 20%, 0.25);
    }

    .file:hover .arrow svg,
    .file .btn-add-to-playlist:hover svg { fill: var(--theme-color); }
    .current .arrow svg {
      fill: var(--playing-color);
      filter: drop-shadow(0px 0px 3px var(--playing-color));
    }

    .folder .arrow .closed,
    .folder:first-of-type .arrow .open { display: block; }
    .folder .arrow .open,
    .folder:first-of-type .arrow .closed { display: none; }

    footer {
      grid-area: footer;
      display: flex;
      justify-content: center;
      margin: 2rem 0;
    }

    footer a {
      text-decoration: none;
      color: var(--secondary-font-color);
    }

    html[data-blur="disabled"] { --blur-base: 0rem; }
    html[data-transitions="disabled"] * { transition: none !important; will-change: none; }
    .no-volume .btn-volume { display: none; }

    @media (min-width: 1024px) { html { --tile-width: 24vw; } }
    @media (max-width: 1024px) { html { --tile-width: 32vw; } }
    @media (max-width: 768px)  { html { --tile-width: 48vw; } }
    @media (max-width: 500px) {
      html {
        --tile-width: 96vw;
        --progress-bar-height: 1.25rem;
      }
      .controls {
        grid-template-areas:
          "progress-bar       progress-bar"
          "timestamp          timestamp"
          "primary-controls   primary-controls"
          "secondary-controls settings-controls";
        grid-template-rows: min-content min-content min-content min-content;
        grid-template-columns: auto;
      }

      .current-timestamp {
        position: static;
        grid-area: timestamp;
        margin-top: 0.35rem;
        justify-self: end;
      }

      .controls-sources   { justify-content: flex-end; }
      .controls-settings  { justify-content: flex-start; }
      .progress-bar       { margin-bottom: 1rem; }
      .trick-container    { display: none; }
    }

    @media (prefers-color-scheme: light) {
      html {
        --base-background-color: var(--base-background-color-light);
        --primary-font-color: var(--primary-font-color-light);
        --secondary-font-color-light: var(--secondary-font-color);
        --tile-font-color: var(--tile-font-color-light);
        --tile-title-background-color: var(--tile-title-background-color-light);
        --tile-background-color: var(--tile-background-color-light);
      }

      .modal {
        --modal-background-color: var(--modal-background-color-light);
      }
    }

    /* @media (prefers-color-scheme: dark) {
    } */

    /* Light mode override */
    html[data-color-scheme="light"] {
      --base-background-color: var(--base-background-color-light);
      --primary-font-color: var(--primary-font-color-light);
      --secondary-font-color: var(--secondary-font-color-light);
      --tile-font-color: var(--tile-font-color-light);
      --tile-title-background-color: var(--tile-title-background-color-light);
      --tile-background-color: var(--tile-background-color-light);
    }

    [data-color-scheme="light"] .modal {
      --modal-background-color: var(--modal-background-color-light);
    }

    /* Dark mode override */
    html[data-color-scheme="dark"] {
      --base-background-color: var(--base-background-color-dark);
      --primary-font-color: var(--primary-font-color-dark);
      --secondary-font-color: var(--secondary-font-color-dark);
      --tile-font-color: var(--tile-font-color-dark);
      --tile-title-background-color: var(--tile-title-background-color-dark);
      --tile-background-color: var(--tile-background-color-dark);
    }

    [data-color-scheme="dark"] .modal {
      --modal-background-color: var(--modal-background-color-dark);
    }</style>
</head>
<body class='no-subtitles is-stopped'>
  <div class='player-container'>
    <div class='media-container'>
      <video class='player' data-volume="3" crossorigin="anonymous" playsinline></video>
      <div class="media-title"></div>
      <ul class='fileinfo modal'><li class='fileinfo-item modal-item'>Metadata not yet loaded</li></ul>
      <ul class='help modal'>
        <li class='help-item modal-item'><span class='key'>Context Menu</span><span class='desc'>Open Settings</span></li>
        <li class='help-item modal-item'><span class='key'>Spacebar</span><span class='desc'>Toggle Play/Pause</span></li>
        <li class='help-item modal-item'><span class='key'>F</span><span class='desc'>Toggle Fullscreen</span></li>
        <li class='help-item modal-item'><span class='key'>I</span><span class='desc'>Media file information</span></li>
        <li class='help-item modal-item'><span class='key'>0-9</span><span class='desc'>Seek to 0%-90% of media</span></li>
        <li class='help-item modal-item'><span class='key'>Left Arrow</span><span class='desc'>Go back 10 seconds</span></li>
        <li class='help-item modal-item'><span class='key'>Right Arrow</span><span class='desc'>Go forward 30 seconds</span></li>
        <li class='help-item modal-item'><span class='key'>Page Up</span><span class='desc'>Previous track</span></li>
        <li class='help-item modal-item'><span class='key'>Page Down</span><span class='desc'>Next track</span></li>
        <li class='help-item modal-item'><span class='key'>R</span><span class='desc'>Alter playback rate</span></li>
        <li class='help-item modal-item'><span class='key'>S</span><span class='desc'>Select a subtitle</span></li>
        <li class='help-item modal-item'><span class='key'>Ctrl+V</span><span class='desc'>Paste and Play</span></li>
        <li class='help-item modal-item'><span class='key'>Backspace</span><span class='desc'>Go to previous folder</span></li>
        <li class='help-item modal-item'><span class='key'>? or F1</span><span class='desc'>This help information</span></li>
      </ul>
      <ul class='subtitle-selection modal'><li class='subtitle-item modal-item'>No subtitles loaded yet</li></ul>
      <ul class='playlist modal'></ul>
      <ul class='settings modal'></ul>
      <div class="modal-background-overlay"></div>
    </div>
    <section class='controls'>
      <div class='progress-bar' style=' --relative-position: 0%;' role='slider' tabindex='0' aria-label='Seek' aria-valuemin='0' aria-valuemax='0' aria-valuenow='0' aria-valuetext='0:00 of 0:00' aria-disabled='true'></div>
      <div class='trick-container' style='--trick-position: 0%'>
        <video class='trick'></video>
      </div>
      <section class='controls-settings'>
        <button class='btn-fileinfo' type='button' title='Show media file information' aria-label='Show media file information'><svg><use xlink:href='#svg-info'/></svg></button>
        <button class='btn-settings' type='button' title='Open settings' aria-label='Open settings'><svg><use xlink:href='#svg-settings'/></svg></button>
      </section>
      <section class='primary-buttons volume-3'>
        <button class='btn-previous' type='button' title='Previous track [Page Up]' aria-label='Previous track'><svg><use xlink:href='#svg-previous'/></svg></button>
        <button class='btn-rewind' type='button' title='Go back 15 seconds [Left Arrow]' aria-label='Go back'><svg><use xlink:href='#svg-replay'/></svg></button>
        <button class='btn-play-pause' type='button' title='Toggle Play/Pause [Spacebar]' aria-label='Play or pause' aria-pressed='false'><svg class='play'><use xlink:href='#svg-play'/></svg><svg class='pause'><use xlink:href='#svg-pause'/></svg></button>
        <button class='btn-stop' type='button' title='Stop media playback' aria-label='Stop playback'><svg><use xlink:href='#svg-stop'/></svg></button>
        <button class='btn-fast-forward' type='button' title='Go forward 30 seconds [Right Arrow]' aria-label='Go forward'><svg><use xlink:href='#svg-skip'/></svg></button>
        <button class='btn-next' type='button' title='Next track [Page Down]' aria-label='Next track'><svg><use xlink:href='#svg-next'/></svg></button>
        <button class='btn-loop' type='button' title='Toggle playlist looping' aria-label='Toggle playlist looping' aria-pressed='false'>
          <svg class='loop-on'><use xlink:href='#svg-loop-on'/></svg>
          <svg class='loop-off'><use xlink:href='#svg-loop-off'/></svg>
        </button>
        <button class='btn-volume' type='button' title='Adjust audio volume' aria-label='Adjust audio volume'>
          <svg class='level-0' title="Muted"><use xlink:href='#svg-speaker-volume-0'/></svg>
          <svg class='level-1' title="Volume 33%"><use xlink:href='#svg-speaker-volume-1'/></svg>
          <svg class='level-2' title="Volume 66%"><use xlink:href='#svg-speaker-volume-2'/></svg>
          <svg class='level-3' title="Volume 100%"><use xlink:href='#svg-speaker-volume-3'/></svg>
        </button>
        <button class='btn-playback-rate' type='button' title='Alter media playback rate' aria-label='Change playback rate' style='--playback-rate: "1.00"'><svg><use xlink:href='#svg-circle'/></svg></button>
        <button class='btn-fullscreen' type='button' title='Toogle fullscreen mode' aria-label='Toggle fullscreen' aria-pressed='false'><svg class='collapse'><use xlink:href='#svg-collapse'/></svg><svg class='expand'><use xlink:href='#svg-expand'/></svg></button>
        <button class='btn-pip' type='button' title='Toggle picture-in-picture mode' aria-label='Toggle picture-in-picture' aria-pressed='false'><svg class='exit'><use xlink:href='#svg-pip-exit-regular'/></svg><svg class='enter'><use xlink:href='#svg-pip-enter-regular'/></svg></button>
        <button class='btn-subtitles' type='button' title='Toggle Subtitles' aria-label='Select subtitles' aria-pressed='false'><svg><use xlink:href='#svg-subtitles-enabled'/></svg></button>
      </section>
      <section class='controls-sources'>
        <button class='btn-playlist' type='button' title='Open playlist' aria-label='Open playlist'><svg><use xlink:href='#svg-playlist'/></svg></button>
        <button class='btn-cloud btn-onedrive' type='button' title='Open from OneDrive' aria-label='Open from OneDrive'><svg><use xlink:href='#svg-onedrive'/></svg></button>
        <button class='btn-cloud btn-gdrive' type='button' title='Open from Google Drive' aria-label='Open from Google Drive'><svg><use xlink:href='#svg-google-drive'/></svg></button>
        <button class='btn-local-file' type='button' title='Open local media file' aria-label='Open local media file'><svg><use xlink:href='#svg-folder-open-vertical'/></svg></button>
      </section>
    <div class='current-timestamp' style='--duration: "0:00"; --absolute-position: "0:00";'><span class='position'></span><span class='divider'></span><span class='duration'></span></div>
    </section>
  </div>
  <section class='links'></section>
  <footer><a href='https://github.com/pseudosavant/player.html' target='_blank'>player.html <span class='version'></span> &copy; Paul Ellis</a></footer>
  <section class='xlinks' style='display: none'>
<!-- ic_fluent_caret_down_24_filled.svg -->
<svg id='svg-caret-down' viewBox="0 0 24 24"><path d="M6.10204 8C5.0281 8 4.45412 9.2649 5.16132 10.0731L10.6831 16.3838C11.3804 17.1806 12.6199 17.1806 13.3172 16.3838L18.839 10.0731C19.5462 9.2649 18.9722 8 17.8983 8H6.10204Z"/></svg>
<!-- ic_fluent_caret_up_24_filled.svg -->
<svg id='svg-caret-up' viewBox="0 0 24 24"><path d="M6.10204 16.9805C5.0281 16.9805 4.45412 15.7156 5.16132 14.9073L10.6831 8.59668C11.3804 7.79986 12.6199 7.79985 13.3172 8.59668L18.839 14.9073C19.5462 15.7156 18.9722 16.9805 17.8983 16.9805H6.10204Z"/></svg>
<!-- ic_fluent_circle_24_filled.svg -->
<svg id='svg-circle' viewBox="0 0 24 24"><path d="M2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12Z"/></svg>
<!-- ic_fluent_arrow_minimize_24_filled.svg -->
<svg id='svg-collapse' viewBox="0 0 24 24"><path d='M10.498103,12.5046266 C11.0109388,12.5046266 11.4336102,12.8906668 11.4913753,13.3880055 L11.498103,13.5046266 L11.498103,21.0085171 C11.498103,21.5608018 11.0503877,22.0085171 10.498103,22.0085171 C9.98526715,22.0085171 9.56259583,21.6224769 9.50483072,21.1251382 L9.49810299,21.0085171 L9.49757619,15.9154145 L3.70710678,21.7071068 C3.34662282,22.0675907 2.77939176,22.0953203 2.38710056,21.7902954 L2.29289322,21.7071068 C1.93240926,21.3466228 1.90467972,20.7793918 2.20970461,20.3871006 L2.29289322,20.2928932 L8.08057619,14.5044145 L2.99657619,14.5046266 C2.44429144,14.5046266 1.99657619,14.0569114 1.99657619,13.5046266 C1.99657619,12.9917908 2.38261638,12.5691195 2.87995507,12.5113544 L2.99657619,12.5046266 L10.498103,12.5046266 Z M13.4990964,1.99941454 C14.0119323,1.99941454 14.4346036,2.38545473 14.4923687,2.88279341 L14.4990964,2.99941454 L14.4985762,8.08641454 L20.2928932,2.29289322 C20.6533772,1.93240926 21.2206082,1.90467972 21.6128994,2.20970461 L21.7071068,2.29289322 C22.0675907,2.65337718 22.0953203,3.22060824 21.7902954,3.61289944 L21.7071068,3.70710678 L15.9105762,9.50241454 L21.0006232,9.50330499 C21.552908,9.50330499 22.0006232,9.95102024 22.0006232,10.503305 C22.0006232,11.0161408 21.614583,11.4388122 21.1172444,11.4965773 L21.0006232,11.503305 L13.4990964,11.503305 C12.9862606,11.503305 12.5635893,11.1172648 12.5058242,10.6199261 L12.4990964,10.503305 L12.4990964,2.99941454 C12.4990964,2.44712979 12.9468117,1.99941454 13.4990964,1.99941454 Z'></path></svg>
<!-- ic_fluent_arrow_download_24_filled.svg -->
<svg id='svg-download' viewBox="0 0 24 24"><path d="M13 3C13 2.44772 12.5523 2 12 2C11.4477 2 11 2.44772 11 3V15.0858L7.70711 11.7929C7.31658 11.4024 6.68342 11.4024 6.29289 11.7929C5.90237 12.1834 5.90237 12.8166 6.29289 13.2071L11.2929 18.2071C11.6834 18.5976 12.3166 18.5976 12.7071 18.2071L17.7071 13.2071C18.0976 12.8166 18.0976 12.1834 17.7071 11.7929C17.3166 11.4024 16.6834 11.4024 16.2929 11.7929L13 15.0858V3ZM5 20C4.44772 20 4 20.4477 4 21C4 21.5523 4.44772 22 5 22H19C19.5523 22 20 21.5523 20 21C20 20.4477 19.5523 20 19 20H5Z"/></svg>
<!-- ic_fluent_arrow_expand_24_filled.svg -->
<svg id='svg-expand' viewBox="0 0 24 24"><path d='M7.6687288,14.9228932 C8.05925309,14.5323689 8.69241807,14.5323689 9.08294236,14.9228932 C9.47346666,15.3134175 9.47346666,15.9465825 9.08294236,16.3371068 L9.08294236,16.3371068 L6.415,19.0042145 L8,19.0042145 C8.51283584,19.0042145 8.93550716,19.3902547 8.99327227,19.8875934 L9,20.0042145 C9,20.5564992 8.55228475,21.0042145 8,21.0042145 L8,21.0042145 L4,21.0042145 C3.44771525,21.0042145 3,20.5564992 3,20.0042145 L3,20.0042145 L3,16.0042145 C3,15.4519298 3.44771525,15.0042145 4,15.0042145 C4.55228475,15.0042145 5,15.4519298 5,16.0042145 L5,16.0042145 L5,17.5912145 L7.6687288,14.9228932 Z M16.0050107,21.0042145 C15.452726,21.0042145 15.0050107,20.5564992 15.0050107,20.0042145 C15.0050107,19.4519298 15.452726,19.0042145 16.0050107,19.0042145 L16.0050107,19.0042145 L17.5880107,19.0042145 L14.9226154,16.3368288 C14.5622731,15.9762031 14.5347666,15.4089612 14.8399456,15.0167899 L14.9231713,14.9226153 C15.313849,14.5322446 15.947014,14.5324935 16.3373847,14.9231712 L16.3373847,14.9231712 L19.0050107,17.5932145 L19.0050107,16.0042145 C19.0050107,15.4913787 19.3910509,15.0687073 19.8883896,15.0109422 L20.0050107,15.0042145 C20.5572954,15.0042145 21.0050107,15.4519298 21.0050107,16.0042145 L21.0050107,16.0042145 L21.0050107,20.0042145 C21.0050107,20.5564992 20.5572954,21.0042145 20.0050107,21.0042145 L20.0050107,21.0042145 L16.0050107,21.0042145 Z M8,3 C8.55228475,3 9,3.44771525 9,4 C9,4.55228475 8.55228475,5 8,5 L8,5 L6.417,5 L9.08238468,7.66817123 C9.44272691,8.02879686 9.47023348,8.59603878 9.1650544,8.98821005 L9.08182877,9.08238468 C8.691151,9.47275543 8.05798607,9.47250654 7.66761532,9.08182877 L7.66761532,9.08182877 L5,6.412 L5,8 C5,8.51283584 4.61395981,8.93550716 4.11662113,8.99327227 L4,9 C3.44771525,9 3,8.55228475 3,8 L3,8 L3,4 C3,3.44771525 3.44771525,3 4,3 L4,3 L8,3 Z M20.0049977,3 C20.5572824,3 21.0049977,3.44771525 21.0049977,4 L21.0049977,4 L21.0049977,8 C21.0049977,8.55228475 20.5572824,9 20.0049977,9 C19.452713,9 19.0049977,8.55228475 19.0049977,8 L19.0049977,8 L19.0049977,6.412 L16.3372498,9.08196378 C15.9768387,9.44252063 15.4096133,9.47036487 15.0172604,9.16541931 L14.9230362,9.08224975 C14.532433,8.69180444 14.532305,8.05863947 14.9227503,7.66803622 L14.9227503,7.66803622 L17.5889977,5 L16.0049977,5 C15.4921619,5 15.0694905,4.61395981 15.0117254,4.11662113 L15.0049977,4 C15.0049977,3.44771525 15.452713,3 16.0049977,3 L16.0049977,3 L20.0049977,3 Z'></path></svg>
<!-- ic_fluent_arrow_up_24_filled.svg -->
<svg id='svg-folder-arrow' viewBox="0 0 24 24"><path d='M4.28401,10.2955 C3.89639,10.6889 3.90108,11.322 4.29449,11.7097 C4.68789,12.0973 5.32104,12.0926 5.70866,11.6992 L11,6.32889 L11,20 C11,20.5523 11.4477,21 12,21 C12.5523,21 13,20.5523 13,20 L13,6.33538 L18.2849,11.6992 C18.6726,12.0926 19.3057,12.0973 19.6991,11.7097 C20.0925,11.322 20.0972,10.6889 19.7096,10.2955 L12.8872,3.3713 C12.3976,2.87438 11.596,2.87438 11.1064,3.3713 L4.28401,10.2955 Z'/></svg>
<!-- ic_fluent_folder_24_filled.svg -->
<svg id='svg-folder-closed' viewBox="0 0 24 24"><path d='M13.821,6.5 L19.75,6.5 C20.8867338,6.5 21.826582,7.34296748 21.9785265,8.43788437 L21.9948092,8.59595119 L22,8.75 L22,17.75 C22,18.940864 21.0748384,19.9156449 19.9040488,19.9948092 L19.75,20 L4.25,20 C3.05913601,20 2.08435508,19.0748384 2.00519081,17.9040488 L2,17.75 L2,10.499 L8.2069251,10.5 L8.40335497,10.4914126 C8.79396018,10.4571882 9.16895973,10.3214197 9.49094085,10.0976522 L9.64734,9.97849788 L13.821,6.5 Z M8.2069251,4 C8.66748759,4 9.11529621,4.14128575 9.49094085,4.40234784 L9.64734,4.52150212 L11.75,6.273 L8.6870634,8.82616596 L8.60221452,8.8873763 C8.51362501,8.94231824 8.41452303,8.9781981 8.31129371,8.99270416 L8.2069251,9 L2,8.999 L2,6.25 C2,5.05913601 2.92516159,4.08435508 4.09595119,4.00519081 L4.25,4 L8.2069251,4 Z'/></svg>
<!-- ic_fluent_folder_open_vertical_20_filled.svg -->
<svg id='svg-folder-open-vertical' viewBox="0 0 20 20"><path d='M4.1369,2.87306 L10.0437,5.17014 C10.5758538,5.37711231 10.9404053,5.86607751 10.9933413,6.42663963 L11,6.56815 L11,18.1574 C10.7250286,18.2553714 10.4180245,18.2745837 10.1126094,18.1919254 L9.96019,18.142 L5.60032,16.4603 C4.69273412,16.1102765 4.07596069,15.2685381 4.00653955,14.3090021 L4,14.1278 L4,3.5 C4,3.3321425 4.02757375,3.17072562 4.078435,3.02002719 L4.1369,2.87306 Z M14.5,2 C15.2796706,2 15.9204457,2.59488554 15.9931332,3.35553954 L16,3.5 L16,7.37689 C16,7.45865667 15.9933333,7.54021444 15.9800593,7.62075444 L15.9552,7.7407 L15,11.5616 L15,14.5 C15,15.2796706 14.4050879,15.9204457 13.6444558,15.9931332 L13.5,16 L12,16 L12,6.56815 C12,5.59775941 11.4392803,4.72105242 10.5722047,4.30971206 L10.4061,4.23813 L4.93446,2.11027 C5.0653575,2.056945 5.20548,2.02158063 5.35176891,2.00723125 L5.5,2 L14.5,2 Z'></path></svg>
<!-- ic_fluent_folder_open_24_filled.svg -->
<svg id='svg-folder-open' viewBox="0 0 24 24"><path d='M1.99957 6.24922C2 5.00689 3.00724 4 4.24957 4H8.20509C8.73063 4 9.23959 4.18396 9.64368 4.51998L12.0247 6.49988H17.75C18.9926 6.49988 20 7.50724 20 8.74988V9.50195H6.42105C5.38827 9.50195 4.48811 10.2051 4.23802 11.2071L2.316 18.9079C2.35895 18.7356 2.315 18.9118 2.316 18.9079C2.11246 18.5694 1.99546 18.173 1.99561 17.7492L1.99957 6.24922Z M3.74448 19.3789C3.66573 19.6945 3.90439 20 4.2296 20H18.4693C19.2723 20 19.9722 19.4535 20.167 18.6745L21.9302 11.6232C22.0091 11.3077 21.7704 11.002 21.4451 11.002H6.42105C6.07679 11.002 5.77674 11.2363 5.69337 11.5703L3.74448 19.3789Z'/></svg>
<!-- Based on SVG from https://upload.wikimedia.org/wikipedia/commons/a/ad/Logo_of_Google_Drive.svg -->
<svg id='svg-google-drive' viewBox="0.738 2.853 16.524 14.295">
      <path style='fill:#fccd48' d='M6.112017465007343,2.85274083196329 L11.884426325760373,2.85500390178011 L17.2620935892589,12.172385633327938 L11.499060245557772,12.173355520392281 z'/>
      <path style='fill:#0ba25e' d='M3.616513460742275,17.144350020887746 L0.7379064321147182,12.165273128189341 L6.112017465007343,2.85274083196329 L8.998060248538135,7.835050681542867 z'/>
      <path style='fill:#2a71e9' d='M3.616513460742275,17.144350020887746 L6.491564258763939,12.167212902318052 L17.2620935892589,12.172385633327938 L14.388335966003016,17.147259682080808 z'/>
      <path style='fill:#e3b73a' d='M10.242417666910494,10.000485200554223 L17.2620935892589,12.169863926960613 L11.499060245557772,12.173420179529906 z'/>
      <path style='fill:#089156' d='M8.998060248538135,7.835050681542867 L7.7478835437197695,10.001455087618574 L6.112017465007343,2.85274083196329 z'/>
      <path style='fill:#296ad9' d='m3.616513460742275,17.144350020887746 l2.8750507980216633,-4.977137118569696 l2.4856435466759867,0.0002909661193057999 z'/>
    </svg>
<!-- ic_fluent_arrow_import_24_filled.svg -->
<svg id='svg-import' viewBox="0 0 24 24"><path d="M21.25 4.5C21.6297 4.5 21.9435 4.78215 21.9932 5.14823L22 5.25V18.75C22 19.1642 21.6642 19.5 21.25 19.5C20.8703 19.5 20.5565 19.2178 20.5069 18.8518L20.5 18.75V5.25C20.5 4.83579 20.8358 4.5 21.25 4.5ZM12.2098 6.38702L12.293 6.29282C12.6535 5.93237 13.2207 5.9047 13.613 6.20977L13.7072 6.29297L18.7038 11.2906C19.064 11.6509 19.0919 12.2178 18.7873 12.6101L18.7042 12.7043L13.7076 17.7077C13.3173 18.0985 12.6842 18.0989 12.2934 17.7087C11.9327 17.3484 11.9045 16.7812 12.2093 16.3887L12.2924 16.2945L15.581 13H3C2.48716 13 2.06449 12.614 2.00673 12.1166L2 12C2 11.4872 2.38604 11.0645 2.88338 11.0067L3 11H15.584L12.2928 7.70703C11.9324 7.34651 11.9047 6.77928 12.2098 6.38702L12.293 6.29282L12.2098 6.38702Z"/></svg>
<!-- ic_fluent_info_24_filled.svg -->
<svg id='svg-info' viewBox="0 0 24 24"><path d="M12.0000002,1.99896738 C17.523704,1.99896738 22.0015507,6.47681407 22.0015507,12.0005179 C22.0015507,17.5242217 17.523704,22.0020684 12.0000002,22.0020684 C6.47629639,22.0020684 1.99844971,17.5242217 1.99844971,12.0005179 C1.99844971,6.47681407 6.47629639,1.99896738 12.0000002,1.99896738 Z M11.996193,10.2495494 C11.4833573,10.2498854 11.0609387,10.6362021 11.0034989,11.1335785 L10.9968474,11.250204 L11.000448,16.751798 L11.0072521,16.8684147 C11.0653426,17.3657155 11.4882665,17.751479 12.0011022,17.7511438 C12.5139379,17.7508078 12.9363565,17.3644911 12.9937963,16.8671147 L13.0004478,16.7504892 L12.9968474,11.2488952 L12.9900433,11.1322785 C12.9319526,10.6349777 12.5090287,10.2492142 11.996193,10.2495494 Z M12.0004478,6.5 C11.3092523,6.5 10.7489277,7.06032464 10.7489277,7.75152012 C10.7489277,8.44271559 11.3092523,9.00304023 12.0004478,9.00304023 C12.6916433,9.00304023 13.2519679,8.44271559 13.2519679,7.75152012 C13.2519679,7.06032464 12.6916433,6.5 12.0004478,6.5 Z"></path></svg>
<!-- ic_fluent_arrow_repeat_all_off_24_filled.svg -->
<svg id='svg-loop-off' viewBox="0 0 24 24"><path d="M3.6129 2.20943L3.70711 2.29262L21.7071 20.2926C22.0976 20.6831 22.0976 21.3163 21.7071 21.7068C21.3466 22.0673 20.7794 22.095 20.3871 21.79L20.2929 21.7068L17.2249 18.639C16.626 18.8395 15.991 18.9613 15.3321 18.992L15.0008 18.9997L9.405 18.9991L10.7087 20.303L10.7864 20.3902C11.0972 20.7828 11.0713 21.3546 10.7087 21.7172C10.3482 22.0777 9.78097 22.1055 9.38867 21.8004L9.29447 21.7172L6.28926 18.712L6.21156 18.6248C5.92663 18.265 5.92465 17.7545 6.20562 17.3926L6.28926 17.2978L9.29447 14.2926L9.38169 14.2149C9.7415 13.93 10.252 13.928 10.6139 14.209L10.7087 14.2926L10.7864 14.3798C11.0713 14.7396 11.0733 15.2501 10.7923 15.612L10.7087 15.7068L9.415 16.9991L15.0008 16.9997C15.1879 16.9997 15.3726 16.9894 15.5544 16.9694L6.34801 7.76142C4.93774 8.64529 4 10.2134 4 12.0005C4 12.9191 4.24775 13.7798 4.68008 14.5195L4.81525 14.7377C4.93132 14.9003 5 15.1006 5 15.3169C5 15.8692 4.55228 16.3169 4 16.3169C3.666 16.3169 3.37024 16.1531 3.18863 15.9015C2.43833 14.7896 2 13.4462 2 12.0005C2 9.66244 3.14641 7.59213 4.90779 6.32103L2.29289 3.70683C1.90237 3.31631 1.90237 2.68314 2.29289 2.29262C2.65338 1.93213 3.22061 1.9044 3.6129 2.20943ZM20 7.6821C20.3191 7.6821 20.6034 7.8316 20.7865 8.06438L20.84 8.13937L20.8569 8.1663C21.5797 9.2672 22 10.5848 22 12.0005C22 13.9776 21.1803 15.7632 19.8621 17.036L18.447 15.6221C19.4037 14.7114 20 13.4256 20 12.0005C20 11.0746 19.7483 10.2075 19.3095 9.46383L19.1724 9.24451C19.064 9.0847 19 8.89087 19 8.6821C19 8.12982 19.4477 7.6821 20 7.6821ZM14.6251 2.21128L14.7123 2.28899L17.7175 5.29419C18.0801 5.65682 18.106 6.22867 17.7952 6.62118L17.7175 6.7084L14.7123 9.71361C14.3218 10.1041 13.6886 10.1041 13.2981 9.71361C12.9355 9.35098 12.9096 8.77913 13.2204 8.38662L13.2981 8.2994L14.595 7.00109H9.826L7.91134 5.08534C8.1887 5.04205 8.47145 5.01506 8.75859 5.00536L8.99921 5.0013L14.597 5.00109L13.2981 3.7032C12.9355 3.34057 12.9096 2.76873 13.2204 2.37621L13.2981 2.28899C13.6607 1.92636 14.2326 1.90046 14.6251 2.21128Z"/></svg>
<!-- ic_fluent_arrow_repeat_all_24_filled.svg -->
<svg id='svg-loop-on' viewBox="0 0 24 24"><path d="M14.7123 2.28878L14.6251 2.21113C14.2326 1.90052 13.6607 1.92641 13.2981 2.28878L13.2204 2.37594C12.9096 2.76818 12.9355 3.33963 13.2981 3.702L14.597 4.99899L8.99921 4.99919L8.75859 5.00325C5.00445 5.12998 2 8.21112 2 11.9935C2 13.4382 2.43833 14.7806 3.18863 15.8918C3.37024 16.1432 3.666 16.3068 4 16.3068C4.55228 16.3068 5 15.8594 5 15.3075C5 15.0914 4.93132 14.8912 4.81525 14.7288L4.68008 14.5107C4.24775 13.7716 4 12.9114 4 11.9935C4 9.23444 6.23822 6.99779 8.99921 6.99779L14.595 6.99758L13.2981 8.29497L13.2204 8.38213C12.9096 8.77438 12.9355 9.34582 13.2981 9.7082C13.6886 10.0984 14.3218 10.0984 14.7123 9.7082L17.7175 6.7051L17.7952 6.61794C18.106 6.2257 18.0801 5.65425 17.7175 5.29188L14.7123 2.28878ZM20.7865 8.06013C20.6034 7.82751 20.3191 7.67811 20 7.67811C19.4477 7.67811 19 8.12551 19 8.67741C19 8.88559 19.0637 9.0789 19.1717 9.23841C19.6952 10.0282 20 10.9753 20 11.9935C20 14.7525 17.7618 16.9892 15.0008 16.9892L9.415 16.9886L10.7087 15.6972L10.7923 15.6025C11.0733 15.2408 11.0713 14.7307 10.7864 14.3712L10.7087 14.284L10.6139 14.2004C10.252 13.9196 9.7415 13.9216 9.38169 14.2063L9.29447 14.284L6.28926 17.2871L6.20562 17.3818C5.92465 17.7435 5.92663 18.2536 6.21156 18.6132L6.28926 18.7003L9.29447 21.7034L9.38867 21.7865C9.78097 22.0913 10.3482 22.0636 10.7087 21.7034C11.0713 21.341 11.0972 20.7696 10.7864 20.3773L10.7087 20.2902L9.405 18.9872L15.0008 18.9878L15.2414 18.9837C18.9956 18.857 22 15.7759 22 11.9935C22 10.5336 21.5524 9.17809 20.7868 8.05666L20.7865 8.06013Z"/></svg>
<!-- ic_fluent_music_note_2_play_20_filled.svg -->
<svg id='svg-music-icon' viewBox="0 0 20 20">
      <path d="M15.9867 3.01576C15.8908 2.43018 15.2919 2.04148 14.7017 2.2259L7.70173 4.4134C7.28425 4.54387 7 4.9305 7 5.36788V13.5001C6.58217 13.1863 6.0628 13.0003 5.5 13.0003C4.11929 13.0003 3 14.1196 3 15.5003C3 16.881 4.11929 18.0003 5.5 18.0003C6.88071 18.0003 8 16.881 8 15.5003V8.36793L15 6.18043V9.02273C15.3434 9.05367 15.6777 9.11618 16 9.20734V3.18043C16 3.12411 15.9954 3.06909 15.9867 3.01576ZM19 14.5002C19 16.9855 16.9853 19.0002 14.5 19.0002C12.0147 19.0002 10 16.9855 10 14.5002C10 12.015 12.0147 10.0002 14.5 10.0002C16.9853 10.0002 19 12.015 19 14.5002ZM16.7367 14.0645L13.7426 12.4144C13.4094 12.2308 13.0013 12.4718 13.0013 12.8523L13.0013 16.1524C13.0013 16.5329 13.4093 16.7739 13.7426 16.5903L16.7366 14.9404C17.0815 14.7503 17.0816 14.2546 16.7367 14.0645Z" fill="#212121"/>
    </svg>
<!-- ic_fluent_next_24_filled.svg -->
<svg id='svg-next' viewBox="0 0 24 24"><path d="M3.0001 4.753C3.0001 3.34519 4.57791 2.51363 5.73926 3.30937L16.2377 10.5028C17.2479 11.1949 17.2531 12.6839 16.2478 13.3831L5.7493 20.6847C4.58897 21.4917 3.0001 20.6613 3.0001 19.248V4.753ZM21 3.75C21 3.33579 20.6642 3 20.25 3C19.8358 3 19.5 3.33579 19.5 3.75V20.25C19.5 20.6642 19.8358 21 20.25 21C20.6642 21 21 20.6642 21 20.25V3.75Z"/></svg>
<!-- Based on SVG from https://upload.wikimedia.org/wikipedia/commons/d/d3/Microsoft_Office_OneDrive_%282018%E2%80%93present%29.svg -->
<svg id='svg-onedrive' viewBox='0 2.311 24 15.376'>
      <path d='m14.4993603046,12.68824475238037 l4.953813,-4.737589000000001 c-1.0290212,-4.012493 -5.1159810000000006,-6.431033 -9.128474,-5.401872 c-1.806915,0.46339040000000015 -3.3764030000000003,1.5835146000000002 -4.401836,3.1417720000000005 c0.0766803,-0.0019339000000000012 8.576264,6.997689 8.576264,6.997689 z' fill='#0364b8' stroke-width='0' id='svg_2'/>
      <path d='m9.1517773046,6.582246752380371 l-0.0002330000000000001,0.0008155000000000004 c-0.9465858,-0.5862746000000001 -2.0382607,-0.8961646000000002 -3.1517910000000002,-0.8946501000000001 c-0.025723200000000005,0 -0.05100370000000002,0.0016310000000000005 -0.0766803,0.0019339000000000012 c-3.311862,0.04103130000000002 -5.963635,2.759186 -5.922627,6.071048 c0.014865400000000004,1.2013946 0.39025170000000003,2.370542 1.0774852000000001,3.356132 l7.421749,-0.9295302 l5.690093,-4.588236 z' fill='#0078d4' stroke-width='0' id='svg_3'/>
      <path d='m19.4531733046,7.950655752380371 c-0.10890420000000003,-0.007269600000000004 -0.21834430000000007,-0.012302400000000003 -0.3290659000000001,-0.012302400000000003 c-0.6645859000000002,-0.0006524000000000004 -1.3222517,0.13509340000000003 -1.9322690000000002,0.3988261000000001 l-0.00013980000000000004,-0.0005126000000000004 l-3.0019720000000003,1.2633260000000002 l3.309532,4.088218 l5.916569000000001,1.4382624000000002 c1.2768167000000001,-2.370309 0.3903216000000001,-5.3268460000000015 -1.9800340000000003,-6.6036860000000015 c-0.6124871000000001,-0.3299280000000001 -1.2885133000000002,-0.5249257 -1.9826203,-0.5719218000000001 v-0.00002330000000000001 z' fill='#1490df' stroke-width='0' id='svg_4'/>
      <path d='m1.0779545046000003,15.11773575238037 c1.1206135,1.6111717 2.9593330000000004,2.5713880000000002 4.9218920000000015,2.570456 h13.124424 c1.7928418000000004,0.0005126000000000004 3.441177,-0.9833065999999999 4.29186,-2.561602 l-9.226334000000001,-5.526527000000001 z' fill='#28a8ea' stroke-width='0' id='svg_5'/>
    </svg>
<!-- ic_fluent_pause_24_filled.svg -->
<svg id='svg-pause' viewBox="0 0 24 24"><path d='M8.25,2 C9.21649831,2 10,2.78350169 10,3.75 L10,20.25 C10,21.2164983 9.21649831,22 8.25,22 L4.75,22 C3.78350169,22 3,21.2164983 3,20.25 L3,3.75 C3,2.78350169 3.78350169,2 4.75,2 L8.25,2 Z M19.25,2 C20.2164983,2 21,2.78350169 21,3.75 L21,20.25 C21,21.2164983 20.2164983,22 19.25,22 L15.75,22 C14.7835017,22 14,21.2164983 14,20.25 L14,3.75 C14,2.78350169 14.7835017,2 15.75,2 L19.25,2 Z'></path></svg>
<!-- ic_fluent_picture_in_picture_enter_24_regular.svg -->
<svg id='svg-pip-enter-regular' viewBox="0 0 24 24"><path d="M2 6.25C2 4.45507 3.45507 3 5.25 3H18.75C20.5449 3 22 4.45507 22 6.25V12H20.5V6.25C20.5 5.2835 19.7165 4.5 18.75 4.5H5.25C4.2835 4.5 3.5 5.2835 3.5 6.25V15.75C3.5 16.7165 4.2835 17.5 5.25 17.5H11V19H5.25C3.45507 19 2 17.5449 2 15.75V6.25ZM14 13C12.8954 13 12 13.8954 12 15V20C12 21.1046 12.8954 22 14 22H21C22.1046 22 23 21.1046 23 20V15C23 13.8954 22.1046 13 21 13H14ZM5.21967 6.21967C5.51256 5.92678 5.98744 5.92678 6.28033 6.21967L9.5 9.43934V7.75C9.5 7.33579 9.83579 7 10.25 7C10.6642 7 11 7.33579 11 7.75V11.25C11 11.6642 10.6642 12 10.25 12H6.75C6.33579 12 6 11.6642 6 11.25C6 10.8358 6.33579 10.5 6.75 10.5H8.43934L5.21967 7.28033C4.92678 6.98744 4.92678 6.51256 5.21967 6.21967Z"/></svg>
<!-- ic_fluent_picture_in_picture_exit_24_regular.svg -->
<svg id="svg-pip-exit-regular" viewBox="0 0 24 24"><path d="M10 11C11.1046 11 12 10.1046 12 9V4C12 2.89543 11.1046 2 10 2H3C1.89543 2 1 2.89543 1 4V9C1 9.75939 1.42323 10.4199 2.04668 10.7586C2.33007 10.9126 2.65482 11 3 11H10ZM18.75 6.5H13V5H18.75C20.5449 5 22 6.45508 22 8.25V17.75C22 19.5449 20.5449 21 18.75 21H5.25C3.45507 21 2 19.5449 2 17.75V11.8293C2.31278 11.9398 2.64936 12 3 12H3.5V17.75C3.5 18.7165 4.2835 19.5 5.25 19.5H18.75C19.7165 19.5 20.5 18.7165 20.5 17.75V8.25C20.5 7.2835 19.7165 6.5 18.75 6.5ZM15.9393 16H14.25C13.8358 16 13.5 16.3358 13.5 16.75C13.5 17.1642 13.8358 17.5 14.25 17.5H17.75C18.1642 17.5 18.5 17.1642 18.5 16.75V13.25C18.5 12.8358 18.1642 12.5 17.75 12.5C17.3358 12.5 17 12.8358 17 13.25V14.9393L14.2803 12.2197C13.9874 11.9268 13.5126 11.9268 13.2197 12.2197C12.9268 12.5126 12.9268 12.9874 13.2197 13.2803L15.9393 16Z"/></svg>
<!-- ic_fluent_play_24_filled.svg -->
<svg id='svg-play' viewBox="0 0 24 24"><path d='M6.33994976,2.27500912 C5.25284495,1.67304649 3.88358525,2.06633193 3.28162262,3.15343674 C3.09690734,3.48702035 3,3.86207592 3,4.2433865 L3,19.7591388 C3,21.0017795 4.00735931,22.0091388 5.25,22.0091388 C5.63140051,22.0091388 6.00654154,21.9121858 6.34018202,21.7273876 L20.3484443,13.9684314 C21.4354781,13.3663405 21.8286019,11.9970344 21.226511,10.9100006 C21.0219396,10.540661 20.7175758,10.2363331 20.348212,10.0318053 L6.33994976,2.27500912 Z'/></svg>
<!-- ic_fluent_add_circle_24_filled.svg -->
<svg id='svg-playlist-add' viewBox="0 0 24 24"><path d="M12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2ZM12 7C11.6203 7 11.3065 7.28215 11.2568 7.64823L11.25 7.75V11.25H7.75C7.33579 11.25 7 11.5858 7 12C7 12.3797 7.28215 12.6935 7.64823 12.7432L7.75 12.75H11.25V16.25C11.25 16.6642 11.5858 17 12 17C12.3797 17 12.6935 16.7178 12.7432 16.3518L12.75 16.25V12.75H16.25C16.6642 12.75 17 12.4142 17 12C17 11.6203 16.7178 11.3065 16.3518 11.2568L16.25 11.25H12.75V7.75C12.75 7.33579 12.4142 7 12 7Z"/></svg>
<!-- ic_fluent_dismiss_circle_24_filled.svg -->
<svg id='svg-playlist-remove' viewBox="0 0 24 24"><path d="M12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2ZM15.5303 8.46967L15.4462 8.39705C15.1852 8.2034 14.827 8.20101 14.5636 8.38988L14.4697 8.46967L12 10.939L9.53033 8.46967L9.44621 8.39705C9.18522 8.2034 8.82701 8.20101 8.56362 8.38988L8.46967 8.46967L8.39705 8.55379C8.2034 8.81478 8.20101 9.17299 8.38988 9.43638L8.46967 9.53033L10.939 12L8.46967 14.4697L8.39705 14.5538C8.2034 14.8148 8.20101 15.173 8.38988 15.4364L8.46967 15.5303L8.55379 15.6029C8.81478 15.7966 9.17299 15.799 9.43638 15.6101L9.53033 15.5303L12 13.061L14.4697 15.5303L14.5538 15.6029C14.8148 15.7966 15.173 15.799 15.4364 15.6101L15.5303 15.5303L15.6029 15.4462C15.7966 15.1852 15.799 14.827 15.6101 14.5636L15.5303 14.4697L13.061 12L15.5303 9.53033L15.6029 9.44621C15.7966 9.18522 15.799 8.82701 15.6101 8.56362L15.5303 8.46967L15.4462 8.39705L15.5303 8.46967Z"/></svg>
<!-- ic_fluent_text_bullet_list_24_filled.svg -->
<svg id='svg-playlist' viewBox="0 0 24 24"><path d="M3.49942 16.5006C4.32752 16.5006 4.99883 17.1719 4.99883 18C4.99883 18.8281 4.32752 19.4994 3.49942 19.4994C2.67131 19.4994 2 18.8281 2 18C2 17.1719 2.67131 16.5006 3.49942 16.5006ZM7.50034 17H21.0035C21.5558 17 22.0035 17.4477 22.0035 18C22.0035 18.5128 21.6174 18.9355 21.1201 18.9933L21.0035 19H7.50034C6.94805 19 6.50034 18.5523 6.50034 18C6.50034 17.4872 6.88638 17.0645 7.38372 17.0067L7.50034 17H21.0035H7.50034ZM3.49942 10.5006C4.32752 10.5006 4.99883 11.1719 4.99883 12C4.99883 12.8281 4.32752 13.4994 3.49942 13.4994C2.67131 13.4994 2 12.8281 2 12C2 11.1719 2.67131 10.5006 3.49942 10.5006ZM7.50034 11H21.0035C21.5558 11 22.0035 11.4477 22.0035 12C22.0035 12.5128 21.6174 12.9355 21.1201 12.9933L21.0035 13H7.50034C6.94805 13 6.50034 12.5523 6.50034 12C6.50034 11.4872 6.88638 11.0645 7.38372 11.0067L7.50034 11H21.0035H7.50034ZM3.49942 4.50781C4.32752 4.50781 4.99883 5.17912 4.99883 6.00723C4.99883 6.83533 4.32752 7.50664 3.49942 7.50664C2.67131 7.50664 2 6.83533 2 6.00723C2 5.17912 2.67131 4.50781 3.49942 4.50781ZM7.50034 5.00082H21.0035C21.5558 5.00082 22.0035 5.44854 22.0035 6.00082C22.0035 6.51366 21.6174 6.93633 21.1201 6.9941L21.0035 7.00082H7.50034C6.94805 7.00082 6.50034 6.55311 6.50034 6.00082C6.50034 5.48799 6.88638 5.06532 7.38372 5.00755L7.50034 5.00082H21.0035H7.50034Z"/></svg>
<!-- ic_fluent_previous_24_filled.svg -->
<svg id='svg-previous' viewBox="0 0 24 24"><path d="M3 3.75C3 3.33579 3.33579 3 3.75 3C4.16421 3 4.5 3.33579 4.5 3.75V20.25C4.5 20.6642 4.16421 21 3.75 21C3.33579 21 3 20.6642 3 20.25V3.75ZM20.9999 4.753C20.9999 3.34519 19.4221 2.51363 18.2608 3.30937L7.76231 10.5028C6.75214 11.1949 6.74694 12.6839 7.75226 13.3831L18.2507 20.6847C19.4111 21.4917 20.9999 20.6613 20.9999 19.248V4.753Z"/></svg>
<!-- ic_fluent_rewind_24_filled.svg -->
<svg id='svg-replay' viewBox="0 0 24 24"><path d='M21.0015268,4.75008179 L21,18.7500818 C20.9999319,19.374155 20.2821581,19.7251581 19.7895445,19.3420142 L12.5,13.6726109 L12.5,18.7500818 C12.4999319,19.374155 11.7821581,19.7251581 11.2895445,19.3420142 L2.28954454,12.3420142 C1.90346505,12.0417301 1.90348904,11.4582003 2.28959321,11.157948 L11.29112,4.15794799 C11.7838024,3.77481559 12.5015268,4.12596134 12.5015268,4.75008179 L12.5,9.82661094 L19.79112,4.15794799 C20.2838024,3.77481559 21.0015268,4.12596134 21.0015268,4.75008179 Z'/></svg>
<!-- ic_fluent_save_24_filled.svg -->
<svg id='svg-save' viewBox="0 0 24 24"><path d="M6.75 3H5.75C4.23122 3 3 4.23122 3 5.75V18.25C3 19.7688 4.23122 21 5.75 21H6V15C6 13.7574 7.00736 12.75 8.25 12.75H15.75C16.9926 12.75 18 13.7574 18 15V21H18.25C19.7688 21 21 19.7688 21 18.25V8.28553C21 7.42358 20.6576 6.59693 20.0481 5.98744L18.0126 3.9519C17.4114 3.35079 16.5991 3.00947 15.75 3.00019V7.5C15.75 8.74264 14.7426 9.75 13.5 9.75H9C7.75736 9.75 6.75 8.74264 6.75 7.5V3ZM14.25 3V7.5C14.25 7.91421 13.9142 8.25 13.5 8.25H9C8.58579 8.25 8.25 7.91421 8.25 7.5V3H14.25ZM16.5 21V15C16.5 14.5858 16.1642 14.25 15.75 14.25H8.25C7.83579 14.25 7.5 14.5858 7.5 15V21H16.5Z"/></svg>
<!-- https://github.com/microsoft/fluentui-system-icons -->
<!-- ic_fluent_settings_24_filled.svg -->
<svg id='svg-settings' viewBox="0 0 24 24"><path d="M12.0124 2.25C12.7464 2.25846 13.4775 2.34326 14.1939 2.50304C14.5067 2.57279 14.7406 2.83351 14.7761 3.15196L14.9463 4.67881C15.0233 5.37986 15.6152 5.91084 16.3209 5.91158C16.5105 5.91188 16.6982 5.87238 16.8734 5.79483L18.2741 5.17956C18.5654 5.05159 18.9057 5.12136 19.1232 5.35362C20.1354 6.43464 20.8892 7.73115 21.3279 9.14558C21.4225 9.45058 21.3137 9.78203 21.0566 9.9715L19.8151 10.8866C19.461 11.1468 19.2518 11.56 19.2518 11.9995C19.2518 12.4389 19.461 12.8521 19.8159 13.1129L21.0585 14.0283C21.3156 14.2177 21.4246 14.5492 21.3299 14.8543C20.8914 16.2685 20.138 17.5649 19.1264 18.6461C18.9091 18.8783 18.569 18.9483 18.2777 18.8206L16.8714 18.2045C16.4691 18.0284 16.007 18.0542 15.6268 18.274C15.2466 18.4937 14.9935 18.8812 14.9452 19.3177L14.7761 20.8444C14.7413 21.1592 14.5124 21.4182 14.2043 21.4915C12.7558 21.8361 11.2467 21.8361 9.79828 21.4915C9.49015 21.4182 9.26129 21.1592 9.22643 20.8444L9.0576 19.32C9.00802 18.8843 8.75459 18.498 8.37467 18.279C7.99475 18.06 7.53345 18.0343 7.13244 18.2094L5.72582 18.8256C5.43446 18.9533 5.09428 18.8833 4.87703 18.6509C3.86487 17.5685 3.11144 16.2705 2.67344 14.8548C2.57911 14.5499 2.68811 14.2186 2.94509 14.0293L4.18842 13.1133C4.54256 12.8531 4.75172 12.4399 4.75172 12.0005C4.75172 11.561 4.54256 11.1478 4.18796 10.8873L2.94541 9.97285C2.68804 9.78345 2.57894 9.45178 2.67361 9.14658C3.11236 7.73215 3.86619 6.43564 4.87837 5.35462C5.09584 5.12236 5.43618 5.05259 5.72749 5.18056L7.12786 5.79572C7.53081 5.97256 7.99404 5.94585 8.37601 5.72269C8.75633 5.50209 9.00953 5.11422 9.05841 4.67764L9.22849 3.15196C9.26401 2.83335 9.49811 2.57254 9.81105 2.50294C10.5283 2.34342 11.2602 2.25865 12.0124 2.25ZM11.9999 8.99995C10.3431 8.99995 8.99994 10.3431 8.99994 12C8.99994 13.6568 10.3431 15 11.9999 15C13.6568 15 14.9999 13.6568 14.9999 12C14.9999 10.3431 13.6568 8.99995 11.9999 8.99995Z"/></svg>
<!-- ic_fluent_fast_forward_24_filled.svg -->
<svg id='svg-skip' viewBox="0 0 24 24"><path d='M12.7104555,4.15798491 L21.7104555,11.1579849 C22.0965349,11.458269 22.096511,12.0417988 21.7104068,12.3420511 L12.70888,19.3420511 C12.2161976,19.7251835 11.4984732,19.3740377 11.4984732,18.7499173 L11.4984732,13.6726109 L4.20887999,19.3420511 C3.71619763,19.7251835 2.9984732,19.3740377 2.9984732,18.7499173 L3,4.74991728 C3.00006806,4.12584403 3.71784185,3.774841 4.21045546,4.15798491 L11.4984732,9.82661094 L11.5,4.74991728 C11.5000681,4.12584403 12.2178419,3.774841 12.7104555,4.15798491 Z'/></svg>
<!-- ic_fluent_speaker_off_24_filled.svg -->
<svg id='svg-speaker-off' viewBox="0 0 24 24">
      <path d='M3.28034 2.21968C2.98745 1.92678 2.51257 1.92677 2.21968 2.21966C1.92678 2.51255 1.92677 2.98743 2.21966 3.28032L6.43783 7.49858H4.25C3.00736 7.49858 2 8.50594 2 9.74858V14.2465C2 15.4891 3.00736 16.4965 4.25 16.4965H7.92956C8.11329 16.4965 8.29063 16.5639 8.42793 16.686L12.9194 20.6797C13.7255 21.3965 15 20.8243 15 19.7456V16.0609L20.7194 21.7805C21.0123 22.0734 21.4872 22.0734 21.7801 21.7805C22.073 21.4876 22.073 21.0127 21.7801 20.7198L3.28034 2.21968Z'/>
      <path d='M17.141 13.9593L18.279 15.0973C18.7408 14.1628 19 13.1107 19 12C19 10.7968 18.6958 9.66244 18.1596 8.67183C17.9624 8.30757 17.5072 8.17213 17.143 8.36932C16.7787 8.56651 16.6432 9.02166 16.8404 9.38593C17.2609 10.1627 17.5 11.0523 17.5 12C17.5 12.691 17.3729 13.3512 17.141 13.9593Z'/>
      <path d='M19.3881 16.2064L20.4815 17.2999C21.4437 15.7631 22 13.9457 22 12C22 9.77389 21.2717 7.71569 20.0407 6.05362C19.7941 5.72076 19.3244 5.65079 18.9916 5.89732C18.6587 6.14386 18.5888 6.61355 18.8353 6.9464C19.8815 8.35896 20.5 10.1062 20.5 12C20.5 13.5311 20.0958 14.9663 19.3881 16.2064Z'/>
      <path d='M9.52004 6.33813L15 11.8182V4.25C15 3.17137 13.7255 2.59914 12.9195 3.31582L9.52004 6.33813Z'/>
    </svg>
<!-- ic_fluent_speaker_24_filled.svg -->
<svg id='svg-speaker-on' viewBox="0 0 24 24"><path d='M15,4.25 C15,3.17138 13.7255,2.59915 12.9195,3.31583 L8.42794,7.30909 C8.29065,7.43116 8.11333,7.49859 7.92961,7.49859 L4.25,7.49859 C3.00736,7.49859 2,8.50595 2,9.74859 L2,14.2465 C2,15.4891 3.00736,16.4965 4.25,16.4965 L7.92956,16.4965 C8.11329,16.4965 8.29063,16.5639 8.42793,16.686 L12.9194,20.6797 C13.7255,21.3965 15,20.8243 15,19.7456 L15,4.25 Z M18.9916,5.89733 C19.3244,5.65079 19.7941,5.72077 20.0407,6.05362 C21.2717,7.7157 22,9.7739 22,12 C22,14.2261 21.2717,16.2843 20.0407,17.9464 C19.7941,18.2793 19.3244,18.3492 18.9916,18.1027 C18.6587,17.8562 18.5888,17.3865 18.8353,17.0536 C19.8815,15.6411 20.5,13.8939 20.5,12 C20.5,10.1062 19.8815,8.35896 18.8353,6.94641 C18.5888,6.61356 18.6587,6.14387 18.9916,5.89733 Z M17.143,8.36933 C17.5072,8.17214 17.9624,8.30757 18.1596,8.67184 C18.6958,9.66245 19,10.7968 19,12 C19,13.2032 18.6958,14.3376 18.1596,15.3282 C17.9624,15.6924 17.5072,15.8279 17.143,15.6307 C16.7787,15.4335 16.6432,14.9783 16.8404,14.6141 C17.2609,13.8373 17.5,12.9477 17.5,12 C17.5,11.0523 17.2609,10.1627 16.8404,9.38593 C16.6432,9.02167 16.7787,8.56652 17.143,8.36933 Z'></path></svg>
<!-- ic_fluent_speaker_mute_24_filled.svg -->
<svg id='svg-speaker-volume-0' viewBox="0 0 24 24">
      <path d="M15 4.25C15 3.17138 13.7255 2.59915 12.9195 3.31583L8.42794 7.30909C8.29065 7.43116 8.11333 7.49859 7.92961 7.49859H4.25C3.00736 7.49859 2 8.50595 2 9.74859V14.2465C2 15.4891 3.00736 16.4965 4.25 16.4965H7.92956C8.11329 16.4965 8.29063 16.5639 8.42793 16.686L12.9194 20.6797C13.7255 21.3965 15 20.8243 15 19.7456V4.25Z"/>
      <path d="M16.2197 9.21967C16.5126 8.92678 16.9874 8.92678 17.2803 9.21967L19 10.9393L20.7197 9.21967C21.0126 8.92678 21.4874 8.92678 21.7803 9.21967C22.0732 9.51256 22.0732 9.98744 21.7803 10.2803L20.0607 12L21.7803 13.7197C22.0732 14.0126 22.0732 14.4874 21.7803 14.7803C21.4874 15.0732 21.0126 15.0732 20.7197 14.7803L19 13.0607L17.2803 14.7803C16.9874 15.0732 16.5126 15.0732 16.2197 14.7803C15.9268 14.4874 15.9268 14.0126 16.2197 13.7197L17.9393 12L16.2197 10.2803C15.9268 9.98744 15.9268 9.51256 16.2197 9.21967Z"/>
    </svg>
<!-- ic_fluent_speaker_0_24_filled.svg -->
<svg id='svg-speaker-volume-1' viewBox="0 0 24 24">
      <path d="M14.7041 3.44103C14.8952 3.66674 15 3.95286 15 4.24856V19.7502C15 20.4405 14.4404 21.0002 13.75 21.0002C13.4542 21.0002 13.168 20.8953 12.9423 20.7042L7.97513 16.4984H4.25C3.00736 16.4984 2 15.491 2 14.2484V9.74839C2 8.50575 3.00736 7.49839 4.25 7.49839H7.97522L12.9425 3.29442C13.4694 2.84843 14.2582 2.91407 14.7041 3.44103Z"/>
    </svg>
<!-- ic_fluent_speaker_1_24_filled.svg -->
<svg id='svg-speaker-volume-2' viewBox="0 0 24 24">
      <path d="M14.7041 3.4425C14.8952 3.66821 15 3.95433 15 4.25003V19.7517C15 20.442 14.4404 21.0017 13.75 21.0017C13.4542 21.0017 13.168 20.8968 12.9423 20.7056L7.97513 16.4999H4.25C3.00736 16.4999 2 15.4925 2 14.2499V9.74985C2 8.50721 3.00736 7.49985 4.25 7.49985H7.97522L12.9425 3.29588C13.4694 2.84989 14.2582 2.91554 14.7041 3.4425ZM17.1035 8.64021C17.4571 8.42442 17.9187 8.5361 18.1344 8.88967C18.7083 9.8298 18.9957 10.8818 18.9957 12.0304C18.9957 13.1789 18.7083 14.231 18.1344 15.1711C17.9187 15.5247 17.4571 15.6364 17.1035 15.4206C16.75 15.2048 16.6383 14.7432 16.8541 14.3897C17.2822 13.6882 17.4957 12.9069 17.4957 12.0304C17.4957 11.1539 17.2822 10.3726 16.8541 9.67112C16.6383 9.31756 16.75 8.85601 17.1035 8.64021Z"/>
    </svg>
<!-- ic_fluent_speaker_2_24_filled.svg -->
<svg id='svg-speaker-volume-3' viewBox="0 0 24 24">
      <path d="M15 4.25V19.7456C15 20.8243 13.7255 21.3965 12.9194 20.6797L8.42793 16.686C8.29063 16.5639 8.11329 16.4965 7.92956 16.4965H4.25C3.00736 16.4965 2 15.4891 2 14.2465V9.74859C2 8.50595 3.00736 7.49859 4.25 7.49859H7.92961C8.11333 7.49859 8.29065 7.43116 8.42794 7.30909L12.9195 3.31583C13.7255 2.59915 15 3.17138 15 4.25ZM18.9916 5.89733C19.3244 5.65079 19.7941 5.72077 20.0407 6.05362C21.2717 7.7157 22 9.7739 22 12C22 14.2261 21.2717 16.2843 20.0407 17.9464C19.7941 18.2793 19.3244 18.3492 18.9916 18.1027C18.6587 17.8562 18.5888 17.3865 18.8353 17.0536C19.8815 15.6411 20.5 13.8939 20.5 12C20.5 10.1062 19.8815 8.35896 18.8353 6.94641C18.5888 6.61356 18.6587 6.14387 18.9916 5.89733ZM17.143 8.36933C17.5072 8.17214 17.9624 8.30757 18.1596 8.67184C18.6958 9.66245 19 10.7968 19 12C19 13.2032 18.6958 14.3376 18.1596 15.3282C17.9624 15.6924 17.5072 15.8279 17.143 15.6307C16.7787 15.4335 16.6432 14.9783 16.8404 14.6141C17.2609 13.8373 17.5 12.9477 17.5 12C17.5 11.0523 17.2609 10.1627 16.8404 9.38593C16.6432 9.02167 16.7787 8.56652 17.143 8.36933Z"/>
    </svg>
<!-- ic_fluent_stop_24_filled.svg -->
<svg id='svg-stop' viewBox="0 0 24 24"><path d='M4.75 3C3.7835 3 3 3.7835 3 4.75V19.25C3 20.2165 3.7835 21 4.75 21H19.25C20.2165 21 21 20.2165 21 19.25V4.75C21 3.7835 20.2165 3 19.25 3H4.75Z'/></svg>
<!-- ic_fluent_closed_caption_24_regular.svg -->
<svg id='svg-subtitles-disabled' viewBox="0 0 24 24"><path d="M18.75,4 C20.5449254,4 22,5.45507456 22,7.25 L22,16.754591 C22,18.5495164 20.5449254,20.004591 18.75,20.004591 L5.25,20.004591 C3.45507456,20.004591 2,18.5495164 2,16.754591 L2,7.25 C2,5.51696854 3.35645477,4.10075407 5.06557609,4.00514479 L5.25,4 L18.75,4 Z M18.75,5.5 L5.25,5.5 L5.10647279,5.5058012 C4.20711027,5.57880766 3.5,6.3318266 3.5,7.25 L3.5,16.754591 C3.5,17.7210893 4.28350169,18.504591 5.25,18.504591 L18.75,18.504591 C19.7164983,18.504591 20.5,17.7210893 20.5,16.754591 L20.5,7.25 C20.5,6.28350169 19.7164983,5.5 18.75,5.5 Z M5.5,12 C5.5,8.85441664 8.21322176,7.22468635 10.6216203,8.59854135 C10.981411,8.80378156 11.1066989,9.2618296 10.9014586,9.62162028 C10.6962184,9.98141095 10.2381704,10.1066989 9.87837972,9.90145865 C8.48070939,9.10416685 7,9.9935733 7,12 C7,14.0045685 8.48410774,14.8962094 9.8791978,14.102709 C10.2392458,13.8979206 10.6971362,14.0237834 10.9019246,14.3838314 C11.106713,14.7438795 10.9808502,15.2017699 10.6208022,15.4065583 C8.21538655,16.7747125 5.5,15.1433285 5.5,12 Z M13,12 C13,8.85441664 15.7132218,7.22468635 18.1216203,8.59854135 C18.481411,8.80378156 18.6066989,9.2618296 18.4014586,9.62162028 C18.1962184,9.98141095 17.7381704,10.1066989 17.3783797,9.90145865 C15.9807094,9.10416685 14.5,9.9935733 14.5,12 C14.5,14.0045685 15.9841077,14.8962094 17.3791978,14.102709 C17.7392458,13.8979206 18.1971362,14.0237834 18.4019246,14.3838314 C18.606713,14.7438795 18.4808502,15.2017699 18.1208022,15.4065583 C15.7153866,16.7747125 13,15.1433285 13,12 Z"></path></svg>
<!-- ic_fluent_closed_caption_24_filled.svg -->
<svg id='svg-subtitles-enabled' viewBox="0 0 24 24"><path d="M18.75,4 C20.5449254,4 22,5.45507456 22,7.25 L22,16.754591 C22,18.5495164 20.5449254,20.004591 18.75,20.004591 L5.25,20.004591 C3.45507456,20.004591 2,18.5495164 2,16.754591 L2,7.25 C2,5.51696854 3.35645477,4.10075407 5.06557609,4.00514479 L5.25,4 L18.75,4 Z M10.6216203,8.59854135 C8.21322176,7.22468635 5.5,8.85441664 5.5,12 C5.5,15.1433285 8.21538655,16.7747125 10.6208022,15.4065583 C10.9808502,15.2017699 11.106713,14.7438795 10.9019246,14.3838314 C10.6971362,14.0237834 10.2392458,13.8979206 9.8791978,14.102709 C8.48410774,14.8962094 7,14.0045685 7,12 C7,9.9935733 8.48070939,9.10416685 9.87837972,9.90145865 C10.2381704,10.1066989 10.6962184,9.98141095 10.9014586,9.62162028 C11.1066989,9.2618296 10.981411,8.80378156 10.6216203,8.59854135 Z M18.1216203,8.59854135 C15.7132218,7.22468635 13,8.85441664 13,12 C13,15.1433285 15.7153866,16.7747125 18.1208022,15.4065583 C18.4808502,15.2017699 18.606713,14.7438795 18.4019246,14.3838314 C18.1971362,14.0237834 17.7392458,13.8979206 17.3791978,14.102709 C15.9841077,14.8962094 14.5,14.0045685 14.5,12 C14.5,9.9935733 15.9807094,9.10416685 17.3783797,9.90145865 C17.7381704,10.1066989 18.1962184,9.98141095 18.4014586,9.62162028 C18.6066989,9.2618296 18.481411,8.80378156 18.1216203,8.59854135 Z"></path></svg>
</section>
  <script type='text/javascript' src='https://apis.google.com/js/api.js' defer></script>
  <script type='text/javascript' src='https://js.live.net/v7.2/OneDrive.js' defer></script>

  <!-- Global Config -->
  <script type="module">
    /* IMPORTANT!!!

      If you would like support for opening directly from the cloud, you must supply the appropriate keys
      in the `app.options.cloud` below AND register your app with Google and/or Microsoft.

      OneDrive Docs: https://docs.microsoft.com/en-us/onedrive/developer/rest-api/getting-started/app-registration?view=odsp-graph-online
      GDrive Docs: https://developers.google.com/drive/api/v3/picker

    */
    const global = window;
    global.app = {
      options: {
        // When false, suppress non-error console noise.
        debug: false,
        cloud: {
          onedrive: {
            clientId: '98a393da-bb36-4061-82df-f847ed49ce8a'
          },
          gdrive: {
            developerKey: 'AIzaSyASwr9ZqtB_DGszfJ7E1nIq-SRO44rsXdc', // Browser API key obtained from the Google API Console.
            clientId: '350482528905-uplflng9avfo3p5sghlgr0g059r04v0b.apps.googleusercontent.com', // Client ID obtained from the Google API Console. Replace with your own Client ID.
            appId: '350482528905' // console.developers.google.com - 'Project number' under 'IAM & Admin' > 'Settings'
          }
        },
        thumbnails: {
          timestamps: [0.005, 0.01, 0.015], // How far into the clip (relatively) should it grab the thumbnail from (e.g. 0.10 = 10%)
          size: 320, // Maximum width of thumbnails. Setting this smaller will save localStorage space.
          mime: {
            type: 'image/webp',
            quality: 0.2
          },
          cache: true, // Should thumbnails be written and read from localStorage cache
          resizeQuality: 'high', // `<canvas>` resize quality
          concurrency: 1 // How many thumbnails should it generate at a time. WARNING: Be careful with this setting. Setting it higher than 1 can swamp your HTTP server with thumbnail requests and cause playback issues.
        },
        audioThumbnails: {
          concurrency: 4, // How many audio thumbnails should it generate at a time. Audio artwork checks are typically lightweight.
          sidecarConcurrency: 4 // How many sidecar checks should run per audio file.
        },
        subtitles: {
          autoMatch: false, // Auto-load matching .vtt/.srt subtitles after playback starts.
          font: 'sans', // sans | serif | mono | casual
          size: '100%', // 90% | 100% | 120% | 140%
          position: 'author', // author | 90 | 75 | 60 | 35 | 20
          color: '#ffffff', // Subtitle text color in hex.
          background: '#000000' // Subtitle background color in hex.
        },
        // Perceptual volume curve exponent for the discrete volume control (0..1 -> 0..1).
        // Higher values give more control at lower volumes.
        volumeExponent: 1.8,
        updateRate: { // Limit UI update rates in ms
          timeupdate: 1000/5, // media playback `timeupdate` events
          trickHover: 1000/10 // Seeking on trickplay hover overlay
        }
      },
      links: [],
      metadata: {}
    };
</script>


  <!-- Utitilies -->
  <script type="module">
    const global = window;
    // jQuery-like syntactic sugar. Only queries for one element. Does not loop over multiple like jQuery
    const $ = (query, ...args) => {
      if (typeof query === 'undefined') throw 'No query provided to $';

      const $targetEl = args[0];

      var el;
      if (typeof query.nodeType === 'string') {
        el = query;
      } else if (query[0] === '<') {
        const container = document.createElement('div');
        container.innerHTML = query;
        el = container.firstChild;
      } else if (typeof query === 'string') {
        el = ($targetEl || document).querySelector(query);
      } else {
        el = query;
      }

      if (el) {
        el.on = (e, fn, ...args) => {
          if (args.length > 0) {
            el.addEventListener(e, fn, ...args);
          } else {
            el.addEventListener(e, fn, false);
          }

          return el;
        };

        el.off = (eventType, callback) => { el.removeEventListener(eventType, callback); return el; }

        el.once = (e, fn) => el.addEventListener(e, fn, {once: true});

        el.trigger = (eventType, detail) => {
          detail = detail ? { detail: detail } : undefined;
          const e = new CustomEvent(eventType, detail);
          el.dispatchEvent(e);

          return el;
        };

        el.hasClass =    c => el.classList.contains(c);
        el.addClass =    c => { el.classList.add(c); return el; }
        el.removeClass = c => { el.classList.remove(c); return el; }
        el.toggleClass = c => { el.classList.toggle(c); return el; }
        el.append = element => { el.appendChild($(element)); return el; }
        el.remove = () => { el.parentNode.removeChild(el); return el; }
        el.show = () => { el.style.display = 'initial'; return el; }
        el.attr = (name, val) => {
          if (isUndefined(val)) {
            return el.getAttribute(name);
          } else {
            el.setAttribute(name, val);
            return el;
          }
        };
        el.removeAttr = name => { el.removeAttribute(name); return el; }
        el.val = (v) => (!isUndefined(v) ? el.value = v : el.value);
        el.find = q => $(q, el);
        el.html = h => {
          if (isUndefined(h)) {
            return el.innerHTML;
          } else {
            el.innerHTML = h;
            return el;
          }
        };
      }

      const isUndefined = (v) => typeof v === 'undefined';

      return el;
    }
    global.$ = $;

    const delay = (ms, fn) => {
      fn = fn || (() => {});

      const p = new Promise((resolve) => {
        setTimeout(() => resolve(fn()), ms);
      });

      return p;
    }
    global.delay = delay;

    const throttle = (fn, wait, opts) => {
      var context, args, result;
      var timeout = null;
      var previous = 0;

      opts = opts || {};
      const later = () => {
        previous = opts.leading === false ? 0 : Date.now();
        timeout = null;
        result = fn.apply(context, args);
        if (!timeout) context = args = null;
      };

      return function() {
        var now = Date.now();
        if (!previous && opts.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          previous = now;
          result = fn.apply(context, args);
          if (!timeout) context = args = null;
        } else if (!timeout && opts.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };
    }
    global.throttle = throttle;

    const storageStore = (key, val) => {
      try {
        return localStorage.setItem(key, val);
      } catch (e) {
        console.warn(`Failed to store: ${key}`, e);
        return null;
      }
    }
    global.storageStore = storageStore;

    const storageRetrieve = (key) => {
      try {
        return localStorage.getItem(key);
      } catch (e) {
        console.warn(`Failed to retrieve: ${key}`, e);
        return null;
      }
    }
    global.storageRetrieve = storageRetrieve;

    const storageRemove = (key) => {
      try {
        return localStorage.removeItem(key);
      } catch (e) {
        console.warn(`Failed to remove: ${key}`, e);
        return null;
      }
    }
    global.storageRemove = storageRemove;

    const sessionStore = (key, val) => {
      try {
        return sessionStorage.setItem(key, val);
      } catch (e) {
        console.warn(`Failed to store (session): ${key}`, e);
        return null;
      }
    }
    global.sessionStore = sessionStore;

    const sessionRetrieve = (key) => {
      try {
        return sessionStorage.getItem(key);
      } catch (e) {
        console.warn(`Failed to retrieve (session): ${key}`, e);
        return null;
      }
    }
    global.sessionRetrieve = sessionRetrieve;

    const sessionRemove = (key) => {
      try {
        return sessionStorage.removeItem(key);
      } catch (e) {
        console.warn(`Failed to remove (session): ${key}`, e);
        return null;
      }
    }
    global.sessionRemove = sessionRemove;

    const secondsToHMS = (totalSecs) => {
      if (Number.isNaN(totalSecs)) return { hours: 0, mins: 0, secs: 0 };

      const hours = Math.floor(totalSecs / 3600);
      totalSecs   = totalSecs % 3600;
      const mins  = Math.floor(totalSecs / 60);
      const secs  = Math.floor(totalSecs % 60);

      return {hours, mins, secs}
    }
    global.secondsToHMS = secondsToHMS;

    const secondsToString = (s) => {
      const t = secondsToHMS(s);
      return `${pad(t.hours)}:${pad(t.mins)}:${pad(t.secs)}`;
    }
    global.secondsToString = secondsToString;

    const pad = (s) => {
      s = s.toString();
      if (s.length < 2) return `0${s}`;

      return s;
    }
    global.pad = pad;

    const addCommas = (n) => {
      const parts = n.toString().split('.');
      const s = parts[0];
      const decimal = parts[1];
      const arr = [...s].reverse(); // ['1', '2', '3', '4', '5', '6', '7'];
      const formatted = []; // []
      arr.forEach((c, i) => {
        const mod = i % 3;
        if (i > 0 && mod === 0) {
          formatted.push(',', c);
        } else {
          formatted.push(c);
        }
      });

      if (decimal) {
        const output = `${formatted.reverse().join('')}.${decimal}`;
        return output;
      } else {
        const output = `${formatted.reverse().join('')}`;
        return output;
      }
    };
    global.addCommas = addCommas;

    const limitPrecision = (v, places) => {
      const factor = Math.pow(10, places);
      return Math.round(v * factor) / factor;
    }
    global.limitPrecision = limitPrecision;

    const minmax = (min, val, max) => Math.max(min, Math.min(max, val));
    global.minmax = minmax;

    // UTF Base64 encode/decode
    const base64EncodeUTF = (str) => {
      return btoa(
        encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (match, p1) => String.fromCharCode('0x' + p1))
      );
    }
    global.base64EncodeUTF = base64EncodeUTF;

    const base64DecodeUTF = (str) => {
      return decodeURIComponent(
        atob(str).split('').map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join('')
      );
    }
    global.base64DecodeUTF = base64DecodeUTF;

    /* Type checking */
    const is = (type) => (v) => typeof v === type;
    const isNumber = is('number');
    const isString = is('string');
    const isBoolean = is('boolean');
    const isUndefined = is('undefined');
    global.isNumber = isNumber;
    global.isUndefined = isUndefined;
    global.isString = isString;

    /* CSS Variables */
    const setCSSVariableString = (k, v, target) => {
      const el = target || document.documentElement;
      el.style.setProperty(k, `'${v}'`);
    };
    const setCSSVariableNumber = (k, v, target) => {
      const el = target || document.documentElement;
      el.style.setProperty(k, v);
    };
    const clearCSSVariable = (k, target) => setCSSVariableNumber(k, null, target);
    global.setCSSVariableString = setCSSVariableString;
    global.setCSSVariableNumber = setCSSVariableNumber;
    global.clearCSSVariable = clearCSSVariable;

    const getCSSVariable = (v, optTarget) => {
      const target = (!optTarget ? document.documentElement : optTarget);
      const val = getComputedStyle(target).getPropertyValue(v);

      return (val == +val ? +val : val); // Convert to number type if it is a numeric string
    }
    global.getCSSVariable = getCSSVariable;
</script>

  <!-- PWA -->
  <script type="module">
    const iconLink = document.querySelector('link[rel="shortcut icon"]') || document.querySelector('link[rel="icon"]');
    if (iconLink) {
      const icon = iconLink.href;
      const metadata = await imageMetadata(icon);
      const startUrl = window.location.href.split('#')[0];
      const scopeUrl = new URL('./', startUrl).toString();

      const manifest = {
        short_name: document.title,
        name: document.title,
        description: document.querySelector('meta[name="description"]').content,
        background_color: '#FFFFFF',
        theme_color: getCSSVariable('--theme-color'),
        color: getCSSVariable('--theme-color'),
        icons: [
          {
            src: icon,
            sizes: `${metadata.width}x${metadata.height}`,
            type: metadata.type
          }
        ],
        display: 'standalone',
        start_url: startUrl,
        scope: scopeUrl,
        file_handlers: [
          {
            action: location.href.split('#')[0],
            accept: {
              "audio/*": [".mp3", ".wav", ".aac", ".m4a", ".mka", ".ogg"],
              "video/*": [".mp4", ".mov", ".webm", ".mkv"]
            }
          }
        ]
      }
      setPWAManifest(manifest);
    }

    function setPWAManifest(manifest) {
      const json = JSON.stringify(manifest);
      const base64 = base64EncodeUTF(json);
      const mimeType = 'application/json';
      const dataURI = `data:${mimeType};base64,${base64}`;

      const link = document.createElement('link');
      link.setAttribute('rel', 'manifest');
      link.setAttribute('href', dataURI);

      document.querySelector('head').appendChild(link);
    }

    function imageMetadata(src) {
      const img = document.createElement('img');

      const inferImageType = (value) => {
        const dataMatch = /^data:([^;]+);/i.exec(value);
        if (dataMatch) return dataMatch[1];

        const extMatch = /\.([a-z0-9]+)(?:$|[?#])/i.exec(value);
        if (extMatch) {
          const ext = extMatch[1].toLowerCase();
          const map = {
            png: 'image/png',
            jpg: 'image/jpeg',
            jpeg: 'image/jpeg',
            gif: 'image/gif',
            webp: 'image/webp',
            svg: 'image/svg+xml',
            ico: 'image/x-icon'
          };
          if (map[ext]) return map[ext];
        }

        return 'image/png';
      }

      const type = inferImageType(src);

      const promise = new Promise((resolve) => {
        img.onload = function imageSizeLoad() {
          const width = img.naturalWidth;
          const height = img.naturalHeight;
          resolve({ height, width, type });
        }
        img.onerror = function imageSizeError() {
          resolve({ height: 0, width: 0, type });
        }
      });

      img.src = src;

      return promise;
    }
</script>

  <!-- Social Media metadata -->
  <script type="module">
    const iconLink = document.querySelector('link[rel="shortcut icon"]') || document.querySelector('link[rel="icon"]');
    const metadata = {
      title: document.querySelector('title').textContent,
      description: document.querySelector('meta[name="description"]').content,
      type: 'video.movie',
      icon: iconLink ? iconLink.href : undefined,
      backgroundColor: '#FF0099'
    };

    setMetadata(metadata);

    function setMetadata(metadata) {

      function setTitle(title){
        const metas = [
          'og:site_name',
          'twitter:title',
          'og:title'
        ];

        setMetas(metas, title);
      }

      function setIcon(iconDataURI) {
        const metas = [
          'twitter:image:src',
          'msapplicationTileImage',
          'og:image'
        ];

        setMetas(metas, iconDataURI);

        const links = [
          'apple-touch-icon'
        ];

        setLinks(links, iconDataURI);
      }

      function setMetas(metas, content) {
        metas.forEach(function metaFn(meta) {
          const metadata = {
            prop: meta,
            content: content
          };

          append(createMeta(metadata));
        });
      }

      function setLinks(links, href) {
        links.forEach(function linkFn(rel) {
          const link = {
            rel: rel,
            href: href
          };

          append(createLink(link));
        });
      }

      function setDescription(desc) {
        const metas = [
          'og:description',
          'twitter:description'
        ];

        setMetas(metas, desc);
      }

      function setType(type){
        const metadata = {
          prop: 'og:type',
          content: type
        };

        append(createMeta(metadata));
      }

      function createLink(linkMetadata) {
        const rel = linkMetadata.rel;
        const href = linkMetadata.href;

        const link = document.createElement('link');
        link.rel = rel;
        link.href = href;

        return link;
      }

      function createMeta(metaMetadata) {
        const prop = metaMetadata.prop;
        const content = metaMetadata.content;

        const meta = document.createElement('meta');
        meta.property = prop;
        meta.name = prop;
        meta.content = content;

        return meta;
      }

      function append(el) {
        const $head = document.querySelector('head');
        $head.appendChild(el);
      }


      if (metadata.title) {
        setTitle(metadata.title);
      }

      if (metadata.icon) {
        setIcon(metadata.icon);
      }

      if (metadata.type) {
        setType(metadata.type);
      }

      if (metadata.description) {
        setDescription(metadata.description);
      }

      if (metadata.backgroundColor) {
        append(createMeta({prop: 'msapplication-TileColor', content: metadata.backgroundColor}));
      }
    }
</script>

  <!-- Video Thumbnail -->
  <script type="module">
    const global = window;
    // video-thumbnail.js v2.0.2
    // https://github.com/pseudosavant/video-thumbnail.js
    //  2025 Paul Ellis (https://github.com/pseudosavant)
    // License: MIT
    
    const defaults = {
      timestamps: [0.1],
      size: 480,
      mime: { type: 'image/jpeg', quality: 0.5 },
      type: 'dataURI',
      cache: false,
      cacheKeyPrefix: 'video-thumbnail.js',
      debug: false
    };
    
    const round = (val, digits) => +val.toFixed(digits);
    
    let lastDebug = defaults.debug;
    let lastCacheKeyPrefix = defaults.cacheKeyPrefix;
    
    const store = (key, val, debug = false, cacheKeyPrefix = defaults.cacheKeyPrefix) => {
      try {
        localStorage.setItem(key, val);
        if (debug) console.info(`[${cacheKeyPrefix}] Persisted to localStorage: ${key}`);
        return true;
      } catch (e) {
        if (e.name === 'QuotaExceededError') {
          if (debug) console.warn(`[${cacheKeyPrefix}] localStorage quota exceeded: unable to persist ${key}`)
        } else {
          if (debug) console.warn(`[${cacheKeyPrefix}] Failed to store in localStorage: ${key} (${e.name})`, e);
        }
        return null;
      }
    }
    
    const retrieve = (key, debug = false, cacheKeyPrefix = defaults.cacheKeyPrefix) => {
      try {
        return localStorage.getItem(key);
      } catch (e) {
        if (debug) console.warn(`[${cacheKeyPrefix}] Failed to retrieve from localStorage: ${key}`, e);
        return null;
      }
    }
    
    const findCachedKey = (cacheKeySuffix, cacheKeyPrefix = defaults.cacheKeyPrefix) => {
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith(cacheKeyPrefix + '-') && key.endsWith(cacheKeySuffix)) {
          return key;
        }
      }
      return null;
    }
    
    const betweenZeroAndOne = (n) => (n >= 0 && n < 1);
    
    const is = (type) => (v) => typeof v === type;
    const isNumber = is('number');
    const isString = is('string');
    const isBoolean = is('boolean');
    const isUndefined = is('undefined');
    
    let _canCache;
    const canCache = (debug = false, cacheKeyPrefix = defaults.cacheKeyPrefix) => {
      if (!isUndefined(_canCache)) return _canCache;
    
      const falseMessage = `[${cacheKeyPrefix}] Thumbnail caching support: false`;
      try {
        const key = '__canCacheTest__';
        const val = 'true';
    
        localStorage.setItem(key, val);
        const supported = localStorage.getItem(key) === val;
        localStorage.removeItem(key);
    
        if (!supported && debug) console.info(falseMessage);
        _canCache = supported;
        return supported;
      } catch (e) {
        if (debug) console.info(falseMessage);
        _canCache = false;
        return false;
      }
    };
    
    const getVideo = (url, timeout = 10000, onTiming) => {
      const $player = document.createElement('video');
      $player.crossOrigin = 'anonymous';
      $player.muted = true;
      $player.autoplay = false;
      $player.playsInline = true; // Must be set to `true` to prevent automatic fullscreen on iOS
    
      const promise = new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          cleanup();
          reject(new Error(`Video loading timeout after ${timeout}ms: ${url}`));
        }, timeout);
    
        const cleanup = () => {
          clearTimeout(timeoutId);
        };
    
        $player.addEventListener('canplay', () => {
          cleanup();
          $player.pause();
          if (typeof onTiming === 'function') {
            onTiming({ phase: 'load', when: 'end', ts: performance.now() });
          }
          resolve($player);
        }, { once: true });
    
        $player.addEventListener('error', (e) => {
          cleanup();
          const errorMsg = e.target?.error?.message || 'Unknown video loading error';
          if (typeof onTiming === 'function') {
            onTiming({ phase: 'load', when: 'end', ts: performance.now(), error: true });
          }
          reject(new Error(`Video loading failed: ${errorMsg} (${url})`));
        }, { once: true});
    
        $player.addEventListener('loadedmetadata', () => {
          if ($player.videoWidth === 0 || $player.videoHeight === 0) {
            cleanup();
            if (typeof onTiming === 'function') {
              onTiming({ phase: 'load', when: 'end', ts: performance.now(), error: true });
            }
            reject(new Error(`Invalid video dimensions (${$player.videoWidth}x${$player.videoHeight}): ${url}`));
          }
        }, { once: true });
      });
    
      if (typeof onTiming === 'function') {
        onTiming({ phase: 'load', when: 'start', ts: performance.now() });
      }
      $player.src = url;
      $player.load();
    
      return promise;
    }
    
    // Canvas pool for reuse to improve performance
    const canvasPool = new Map();
    
    const getCanvas = (width, height, useOffscreen = false) => {
      const key = `${width}x${height}:${useOffscreen ? 'off' : 'dom'}`;
      const legacyKey = `${width}x${height}`; // pre-type-keyed entries
    
      const prepare = (canvas) => {
        const ctx = canvas.getContext('2d');
        // Ensure dimensions match exactly (in case an older entry exists with different size)
        if ('width' in canvas && canvas.width !== width) canvas.width = width;
        if ('height' in canvas && canvas.height !== height) canvas.height = height;
        ctx.clearRect(0, 0, width, height);
        return { canvas, ctx };
      };
    
      // Try exact key
      if (canvasPool.has(key)) {
        const canvas = canvasPool.get(key);
        // If DOM canvas is needed, ensure it supports toDataURL
        if (!useOffscreen && typeof canvas.toDataURL !== 'function') {
          // Wrong type in pool; drop and recreate
          canvasPool.delete(key);
        } else {
          return prepare(canvas);
        }
      }
    
      // Try legacy key, migrate when compatible
      if (canvasPool.has(legacyKey)) {
        const canvas = canvasPool.get(legacyKey);
        if (useOffscreen) {
          if (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {
            canvasPool.set(key, canvas);
            canvasPool.delete(legacyKey);
            return prepare(canvas);
          }
          // Not offscreen; ignore legacy entry
        } else {
          if (typeof canvas.toDataURL === 'function') {
            canvasPool.set(key, canvas);
            canvasPool.delete(legacyKey);
            return prepare(canvas);
          }
          // Legacy entry is offscreen or incompatible; ignore
        }
      }
    
      // Create new canvas of the requested type
      let canvas, ctx;
      if (useOffscreen && typeof OffscreenCanvas !== 'undefined') {
        canvas = new OffscreenCanvas(width, height);
        ctx = canvas.getContext('2d');
      } else {
        canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        ctx = canvas.getContext('2d');
      }
    
      if (width * height <= 1920 * 1080) {
        canvasPool.set(key, canvas);
      }
    
      return { canvas, ctx };
    };
    
    const _waitForPresentedFrame = (video, targetSeconds, budgetMs = 600) => {
      return new Promise((resolve) => {
        const epsilon = 0.03; // ~30ms tolerance
        if (typeof video.requestVideoFrameCallback !== 'function') {
          // Best-effort fallback: give the browser two paints
          requestAnimationFrame(() => requestAnimationFrame(resolve));
          return;
        }
        const deadline = performance.now() + budgetMs;
        const loop = () => {
          video.requestVideoFrameCallback((now, metadata) => {
            const mt = metadata && typeof metadata.mediaTime === 'number' ? metadata.mediaTime : null;
            if (mt !== null && Math.abs(mt - targetSeconds) <= epsilon) {
              resolve();
              return;
            }
            if (performance.now() > deadline) {
              resolve();
            } else {
              loop();
            }
          });
        };
        loop();
      });
    };
    
    const videoToDataURI = async (videoElement, timestamp, size, mime, type, onTiming, index, debug = false, cacheKeyPrefix = defaults.cacheKeyPrefix) => {
      const start = performance.now();
      const $player = videoElement;
    
      const aspectRatio = $player.videoHeight / $player.videoWidth;
    
      const w = Math.max(1, Math.min(32767, size));
      const h = Math.max(1, Math.min(32767, w * aspectRatio));
    
      if (w !== size) {
        if (debug) console.warn(`[${cacheKeyPrefix}] Canvas width clamped from ${size} to ${w}`);
      }
    
      const { canvas: c, ctx } = getCanvas(w, h, type === 'objectURL');
    
      var seekTime = 0;
      let seekMs = 0;
      let encodeMs = 0;
      if (isSeekable($player)) {
        // Interpret timestamp: [0,1) => relative; otherwise absolute seconds
        const relSeconds = timestamp * $player.duration;
        const requestedSeconds = betweenZeroAndOne(timestamp)
          ? relSeconds
          : timestamp;
    
        const epsilon = 0;
        const maxT = Math.max(0, $player.duration - 0.05);
        if (!betweenZeroAndOne(timestamp) && requestedSeconds > $player.duration) {
          if (debug) console.warn(`[${cacheKeyPrefix}] Timestamp ${timestamp} exceeds video duration ${$player.duration}s, using end of video`);
        }
        seekTime = Math.min(Math.max(requestedSeconds, epsilon), maxT);
    
        if (typeof onTiming === 'function') {
          onTiming({ phase: 'seek', when: 'start', ts: performance.now(), index });
        }
        const seekStart = performance.now();
        await seek($player, seekTime, 3, debug, cacheKeyPrefix);
        // Briefly play to force frame presentation, then wait for presented frame at target
        try { await $player.play(); } catch (e) { /* ignore autoplay restrictions - muted helps */ }
        await _waitForPresentedFrame($player, seekTime);
        $player.pause();
        seekMs = performance.now() - seekStart;
        if (typeof onTiming === 'function') {
          onTiming({ phase: 'seek', when: 'end', ts: performance.now(), index });
        }
      } else {
        if (debug) console.warn(`[${cacheKeyPrefix}] Unable to seek video: ${videoElement.src}`);
      }
    
      $player.pause();
      if (typeof onTiming === 'function') {
        onTiming({ phase: 'encode', when: 'start', ts: performance.now(), index });
      }
      const encodeStart = performance.now();
      ctx.drawImage($player, 0, 0, w, h);
    
      const URI = (type === 'objectURL' ? await canvasToBlob(c, mime.type, mime.quality) : c.toDataURL(mime.type, mime.quality));
      // Compute size in KB accurately for object URLs
      let sizeKB = 0;
      if (type === 'objectURL') {
        const sz = globalThis._videoThumbnailObjectURLSizes && globalThis._videoThumbnailObjectURLSizes.get(URI);
        if (typeof sz === 'number') sizeKB = round(sz / 1024, 2);
      } else {
        sizeKB = round((URI && URI.length ? (URI.length / 1024) : 0), 2);
      }
      encodeMs = performance.now() - encodeStart;
      if (typeof onTiming === 'function') {
        onTiming({ phase: 'encode', when: 'end', ts: performance.now(), index });
      }
      const duration = performance.now() - start;
      const response = { URI, timestamp, duration, seekTime, mime, seekMs, encodeMs, sizeKB };
    
      return response;
    }
    
    const canvasToBlob = (canvas, type, quality) => {
      const makeURL = (blob, resolve) => {
        const objectURL = URL.createObjectURL(blob);
        if (!globalThis._videoThumbnailObjectURLs) {
          globalThis._videoThumbnailObjectURLs = new Set();
        }
        globalThis._videoThumbnailObjectURLs.add(objectURL);
        // Track sizes for accurate metrics
        if (!globalThis._videoThumbnailObjectURLSizes) {
          globalThis._videoThumbnailObjectURLSizes = new Map();
        }
        try { globalThis._videoThumbnailObjectURLSizes.set(objectURL, blob.size); } catch {}
        resolve(objectURL);
      };
    
      // OffscreenCanvas path
      try {
        if (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {
          return new Promise(async (resolve, reject) => {
            try {
              const blob = await canvas.convertToBlob({ type, quality });
              if (blob) return makeURL(blob, resolve);
              reject(new Error('Failed to create blob from OffscreenCanvas'));
            } catch (e) {
              reject(new Error(`Unable to create blob from OffscreenCanvas: ${e.message}`));
            }
          });
        }
      } catch {}
    
      // HTMLCanvasElement path
      if (typeof canvas.toBlob === 'function') {
        return new Promise((resolve, reject) => {
          try {
            canvas.toBlob((blob) => {
              if (blob) {
                return makeURL(blob, resolve);
              }
              reject(new Error('Failed to create blob from canvas'));
            }, type, quality);
          } catch (e) {
            reject(new Error(`Unable to create blob from canvas: ${e.message}`));
          }
        });
      }
    
      // Fallback: dataURL -> Blob via fetch (works in most browsers)
      return new Promise(async (resolve, reject) => {
        try {
          if (typeof canvas.toDataURL !== 'function') {
            return reject(new Error('Canvas cannot produce dataURL for fallback'));
          }
          const dataURL = canvas.toDataURL(type, quality);
          const resp = await fetch(dataURL);
          const blob = await resp.blob();
          return makeURL(blob, resolve);
        } catch (e) {
          reject(new Error(`Unable to create blob from canvas (fallback): ${e.message}`));
        }
      });
    }
    
    const cleanupObjectURLs = () => {
      let revokedCount = 0;
      if (globalThis._videoThumbnailObjectURLs) {
        revokedCount = globalThis._videoThumbnailObjectURLs.size;
        globalThis._videoThumbnailObjectURLs.forEach(url => {
          try {
            URL.revokeObjectURL(url);
          } catch (e) {
            if (lastDebug) console.warn(`[${lastCacheKeyPrefix}] Failed to revoke object URL: ${e.message}`);
          }
        });
        globalThis._videoThumbnailObjectURLs.clear();
      }
      if (globalThis._videoThumbnailObjectURLSizes) {
        try { globalThis._videoThumbnailObjectURLSizes.clear(); } catch {}
      }
      return revokedCount;
    };
    
    const _getMemoryUsage = () => {
      const cacheSize = getThumbnailDataURI.cacheSize();
      const canvasPoolSize = canvasPool.size;
      const objectURLCount = globalThis._videoThumbnailObjectURLs ? globalThis._videoThumbnailObjectURLs.size : 0;
    
      return {
        cacheSizeBytes: cacheSize,
        cacheSizeKB: Math.round(cacheSize / 1024),
        canvasPoolEntries: canvasPoolSize,
        activeObjectURLs: objectURLCount
      };
    };
    
    const seek = ($player, time, maxRetries = 3, debug = false, cacheKeyPrefix = defaults.cacheKeyPrefix) => {
      const attemptSeek = (attempt = 1) => {
        return new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error(`Seek timeout after 5 seconds (attempt ${attempt}/${maxRetries})`));
          }, 5000);
    
          const errorHandler = (e) => {
            clearTimeout(timeout);
            if (attempt < maxRetries) {
              if (debug) console.warn(`[${cacheKeyPrefix}] Seek attempt ${attempt} failed, retrying...`);
              setTimeout(() => {
                attemptSeek(attempt + 1).then(resolve).catch(reject);
              }, 100 * attempt);
            } else {
              reject(new Error(`Error while seeking video after ${maxRetries} attempts: ${e.message || 'Unknown error'}`));
            }
          };
    
          $player.addEventListener('error', errorHandler, { once: true});
    
          $player.addEventListener('seeked', () => {
            clearTimeout(timeout);
            $player.removeEventListener('error', errorHandler);
    
            const tolerance = 0.5;
            const actualTime = $player.currentTime;
            if (Math.abs(actualTime - time) > tolerance) {
              if (debug) console.warn(`[${cacheKeyPrefix}] Seek inaccuracy: requested ${time}s, got ${actualTime}s`);
            }
    
            resolve(actualTime);
          }, { once: true});
    
          $player.currentTime = time;
        });
      };
    
      return attemptSeek();
    }
    
    const isSeekable = (videoElement) => {
      try {
        const ranges = videoElement?.seekable;
        if (!ranges || ranges.length === 0) return false;
        const end = ranges.end(ranges.length - 1);
        return end > 0;
      } catch {
        return false;
      }
    };
    
    const validateInputs = (url, opts) => {
      if (!url || typeof url !== 'string') {
        throw new Error('URL must be a non-empty string');
      }
    
      try {
        new URL(url);
      } catch (e) {
        if (!url.match(/^[\w\-._~:\/?#[\]@!$&'()*+,;=%]+$/)) {
          throw new Error(`Invalid URL format: ${url}`);
        }
      }
    
      if (opts.size !== undefined) {
        if (!isNumber(opts.size) || opts.size <= 0 || opts.size > 32767) {
          throw new Error('Size must be a positive number not exceeding 32767');
        }
      }
    
      if (opts.timestamps !== undefined) {
        const timestamps = Array.isArray(opts.timestamps) ? opts.timestamps : [opts.timestamps];
        for (const timestamp of timestamps) {
          if (!isNumber(timestamp) || timestamp < 0) {
            throw new Error('Timestamps must be non-negative numbers');
          }
        }
      }
    
      if (opts.mime && opts.mime.type) {
        if (!(/^image\/(webp|jpeg|png)$/i).test(opts.mime.type)) {
          throw new Error(`Unsupported mime type: ${opts.mime.type}. Supported formats: JPEG (default), WebP, PNG`);
        }
        if (opts.mime.quality !== undefined) {
          if (!isNumber(opts.mime.quality) || opts.mime.quality < 0 || opts.mime.quality > 1) {
            throw new Error('Quality must be a number between 0 and 1');
          }
        }
      }
    };
    
    const getThumbnailDataURI = async (url, opts) => {
      opts = {...opts} || {};
    
      validateInputs(url, opts);
    
      const isImageMimeType = (s) => (/image\/.+/i).test(s);
      const size          = (isNumber(opts.size) && opts.size > 0         ? opts.size : defaults.size);
      const defaultMime   = { type: 'image/jpeg', quality: 0.5 };
      const mime          = {
        type: (opts.mime && isImageMimeType(opts.mime.type)) ? opts.mime.type : defaultMime.type,
        quality: (opts.mime && isNumber(opts.mime.quality)) ? opts.mime.quality : defaultMime.quality
      };
      const type          = (opts.type === 'objectURL'                    ? opts.type : defaults.type);
      const shouldCache   = (isBoolean(opts.cache)                        ? opts.cache : defaults.cache);
      const cacheReadOnly = opts.cacheReadOnly;
      const cacheKeyPrefix = (isString(opts.cacheKeyPrefix) ? opts.cacheKeyPrefix : defaults.cacheKeyPrefix);
      const debug         = (isBoolean(opts.debug)                        ? opts.debug : defaults.debug);
    
      lastDebug = debug;
      lastCacheKeyPrefix = cacheKeyPrefix;
    
      const timestamps = (
        Array.isArray(opts.timestamps) ?
          opts.timestamps :
          (isUndefined(opts.timestamps) ? defaults.timestamps : [opts.timestamps])
      );
    
      try {
        const onTiming = (typeof opts.onTiming === 'function') ? opts.onTiming : null;
        const totalStart = performance.now();
        if (onTiming) onTiming({ phase: 'total', when: 'start', ts: totalStart });
        const thumbnails = [];
        let $player = null;
        const timingAgg = { loadMs: 0, totalMs: 0, seeksMs: [], encodesMs: [], seekMsTotal: 0, encodeMsTotal: 0 };
    
        for (let i = 0; i < timestamps.length; i++) {
          const timestamp = timestamps[i];
    
      const cacheKeySuffix = `${size}|${imageFormat(mime)}|${timestamp}|${url}`;
      const cachedKey = findCachedKey(cacheKeySuffix, cacheKeyPrefix);
          const cachedURI = cachedKey ? retrieve(cachedKey, debug, cacheKeyPrefix) : null;
    
          if (canCache(debug, cacheKeyPrefix) && shouldCache && isDataURI(cachedURI)) {
            try {
              const metadata = cacheKeyParser(cachedKey);
              if (!metadata || typeof metadata !== 'object') {
                throw new Error('Invalid metadata structure');
              }
    
              const {timestamp: cacheTimestamp, seekTime, mime: cacheMime} = metadata;
    
              if (typeof cacheTimestamp !== 'number' || typeof seekTime !== 'number') {
                throw new Error('Invalid metadata types');
              }
    
              const sizeKB = round(cachedURI.length / 1024, 2);
              const URI = cachedURI;
              const duration = 0;
    
              thumbnails.push({URI, timestamp: cacheTimestamp, duration, mime: cacheMime || mime, seekTime, sizeKB, seekMs: 0, encodeMs: 0});
              // Cached path: no additional seek/encode time
              timingAgg.seeksMs[i] = 0;
              timingAgg.encodesMs[i] = 0;
              if (debug) console.info(`[${cacheKeyPrefix}] Retrieved from cache: ${cachedKey}`);
              continue;
            } catch (parseError) {
              if (debug) console.warn(`[${cacheKeyPrefix}] Failed to parse cache key, will regenerate: ${cachedKey}`, parseError);
            }
          }
    
          if (!cacheReadOnly) {
            if (!$player) {
              const loadStart = performance.now();
              $player = await getVideo(url, 10000, onTiming);
              timingAgg.loadMs = performance.now() - loadStart;
            }
    
            const thumbnail = await videoToDataURI($player, timestamp, size, mime, type, onTiming, i, debug, cacheKeyPrefix);
    
            if (!thumbnail || typeof thumbnail !== 'object' || !thumbnail.URI) {
              throw new Error(`Invalid thumbnail generated for timestamp ${timestamp}`);
            }
    
            if (typeof thumbnail.sizeKB !== 'number') {
              thumbnail.sizeKB = round((thumbnail.URI && thumbnail.URI.length ? (thumbnail.URI.length / 1024) : 0), 2);
            }
            thumbnail.seekTime = round(thumbnail.seekTime || 0, 2);
            thumbnails.push(thumbnail);
    
            // Aggregate per-thumbnail timings
            timingAgg.seeksMs[i] = typeof thumbnail.seekMs === 'number' ? thumbnail.seekMs : 0;
            timingAgg.encodesMs[i] = typeof thumbnail.encodeMs === 'number' ? thumbnail.encodeMs : 0;
    
            const cacheTimestamp = Date.now();
      const cacheKey = `${cacheKeyPrefix}-${cacheTimestamp}-${thumbnail.seekTime}-${cacheKeySuffix}`;
    
            // Only cache data URIs; skip caching blob/object URLs
            if (type !== 'objectURL' && canCache(debug, cacheKeyPrefix) && shouldCache && !retrieve(cacheKey, debug, cacheKeyPrefix)) {
              const keys = Object.keys(localStorage)
                .filter((key) => key.startsWith(cacheKeyPrefix))
                .sort();
    
              while (!store(cacheKey, thumbnail.URI, debug, cacheKeyPrefix) && keys.length > 0) {
                const key = keys.shift();
                localStorage.removeItem(key);
                if (debug) console.info(`[${cacheKeyPrefix}] Purged from cache: ${key}`);
              }
            }
          }
        }
    
        if ($player) {
          try {
            $player.removeAttribute('src');
            $player.load();
          } catch (cleanupError) {
            if (debug) console.warn(`[${cacheKeyPrefix}] Error during video cleanup: ${cleanupError.message}`);
          }
        }
    
        const totalEnd = performance.now();
        timingAgg.totalMs = totalEnd - totalStart;
        timingAgg.seekMsTotal = timingAgg.seeksMs.reduce((a, b) => a + (b || 0), 0);
        timingAgg.encodeMsTotal = timingAgg.encodesMs.reduce((a, b) => a + (b || 0), 0);
        if (onTiming) onTiming({ phase: 'total', when: 'end', ts: totalEnd });
    
        // Attach non-enumerable timing aggregate to the array (keeps API backward-compatible)
        try {
          Object.defineProperty(thumbnails, 'timing', { value: timingAgg, enumerable: false, configurable: false });
        } catch {}
        return thumbnails;
      } catch (e) {
        if (debug) console.error(`[${cacheKeyPrefix}] Unable to create thumbnail(s) for: ${url}`, e);
        throw e;
      }
    }
    
    const cacheKeyParser = (key) => {
      // Prefix-agnostic parser: <prefix>-<timestamp>-<seekTime>-<size>|<fmt>|<ts>|<url>
        const re = /^(.+?)-(\d{13,})-(\d+\.?\d{0,2})-(\d{1,5})\|(\w{3,4})\|([\d\.]+)\|(.+)$/i;
      const parts = re.exec(key);
    
      if (!parts || parts.length < 8) {
        throw new Error(`Invalid cache key format: ${key}`);
      }
    
      const res = {
        prefix: parts[1],
        cacheTimestamp: +parts[2],
        seekTime: +parts[3],
        size: +parts[4],
        mime: { type: `image/${parts[5]}`},
        timestamp: +parts[6],
        URL: parts[7]
      }
    
      return res;
    };
    const imageFormat = (mime) => mime.type.split('/')[1];
    const isDataURI = (uri) => uri && uri.startsWith('data:image/') && uri.length > 30;
    
    getThumbnailDataURI.clearCache = (prefix) => {
      const cacheKeyPrefix = (typeof prefix === 'string' ? prefix : defaults.cacheKeyPrefix);
    
      const keys = Object.keys(localStorage)
        .filter((k) => k.startsWith(cacheKeyPrefix));
      while (keys.length > 0) localStorage.removeItem(keys.pop());
    
      const remaining = Object.keys(localStorage).some((k) => k.startsWith(cacheKeyPrefix));
      return !remaining;
    }
    
    getThumbnailDataURI.cacheSize = (prefix) => {
      const cacheKeyPrefix = (typeof prefix === 'string' ? prefix : defaults.cacheKeyPrefix);
      const keys = Object.keys(localStorage).filter((key) => key.startsWith(cacheKeyPrefix));
      const size = keys.reduce((acc, key) => acc += (localStorage.getItem(key) || '').length, 0);
      return size;
    }
    
    getThumbnailDataURI.getMemoryUsage = _getMemoryUsage;
    getThumbnailDataURI.cleanupObjectURLs = cleanupObjectURLs;
    
    getThumbnailDataURI.clearCanvasPool = () => {
      canvasPool.clear();
      return true;
    };
    
    
    global.videoThumbnail = getThumbnailDataURI;
</script>

  <!-- Audio Thumbnail -->
  <script type="module">
const global = window;
// audio-thumbnail.js v1.0.0
// https://github.com/pseudosavant/audio-thumbnail.js
// License: MIT

const isAbortError = (e) => (e && (e.name === 'AbortError' || e.code === 20));

const _audioThumbnailActiveObjectURLs = new Set();

const nowMs = () => {
  if (typeof performance !== 'undefined' && typeof performance.now === 'function') return performance.now();
  return Date.now();
};

const defaults = {
  sources: ['sidecar', 'embedded'],
  sourceStrategy: 'race',
  sidecarNames: ['folder', 'cover', 'albumart', 'front', 'album', 'default', 'thumb', 'artwork', 'thumbnail'],
  sidecarExts: ['jpg', 'jpeg'],
  sidecarIncludeBasename: true,
  sidecarValidate: 'auto',
  sidecarConcurrency: 6,
  sidecarMaxResults: 1,
  sidecarCache: true,
  sidecarCacheKeyPrefix: 'audio-thumbnail.js',

  embedded: {
    maxBytes: 1000000,
    preferPicture: 'front'
  },

  output: {
    type: 'objectURL',
    mime: undefined,
    size: undefined
  },

  timeoutMs: 15000,
  fetch: (typeof fetch === 'function' ? fetch.bind(globalThis) : null),
  debug: false,
  onTiming: null,
  signal: null
};

const normalizeOptions = (options = {}) => {
  const out = {
    ...defaults,
    ...options,
    embedded: { ...defaults.embedded, ...(options.embedded || {}) },
    output: { ...defaults.output, ...(options.output || {}) }
  };
  if (!Array.isArray(out.sources)) out.sources = defaults.sources.slice();
  return out;
};

const extractEmbedded = async (url, opts) => {
  const u = new URL(url, location.href);
  const ext = (u.pathname.split('/').pop() || '').split('.').pop()?.toLowerCase() || '';

  const tryOrder = [];
  if (ext === 'mp3') tryOrder.push('mp3');
  if (ext === 'm4a' || ext === 'mp4') tryOrder.push('m4a');
  if (ext === 'mka' || ext === 'mkv') tryOrder.push('mka');
  if (tryOrder.length === 0) tryOrder.push('mp3', 'm4a', 'mka');

  const attempts = [];
  for (const kind of tryOrder) {
    try {
      if (kind === 'mp3') return await extractEmbeddedArtworkMP3(url, opts);
      if (kind === 'm4a') return await extractEmbeddedArtworkM4A(url, opts);
      if (kind === 'mka') return await extractEmbeddedArtworkMKA(url, opts);
    } catch (e) {
      attempts.push(`${kind}: ${e?.message || String(e)}`);
    }
  }
  const err = new Error(`Embedded artwork extraction failed. ${attempts.join(' | ')}`);
  err.attempts = attempts;
  throw err;
};

const materializeEmbeddedArtwork = async (embedded, options) => {
  const { output } = options;

  const wantsResize = !!(output && Number.isFinite(output.size));
  const wantsMime = !!(output && output.mime && output.mime.type);
  const wantsMimeChange = wantsMime && output.mime.type !== embedded.mime;
  const wantsQuality = wantsMime && typeof output.mime.quality === 'number';
  const wantsTranscode = wantsResize || wantsMimeChange || wantsQuality;

  if (!wantsTranscode) {
    if (output.type === 'dataURI') {
      const uri = bytesToDataURI(embedded.bytes, embedded.mime);
      return { URI: uri, outputMime: { type: embedded.mime } };
    }
    const uri = bytesToObjectURL(embedded.bytes, embedded.mime);
    trackObjectURL(uri);
    return { URI: uri, outputMime: { type: embedded.mime } };
  }

  const t0 = nowMs();
  const out = await transcodeImageBytesToOutput(embedded.bytes, embedded.mime, output);
  out.encodeMs = nowMs() - t0;
  if (out.type === 'objectURL') trackObjectURL(out.URI);
  return { URI: out.URI, outputMime: out.mime, width: out.width, height: out.height, encodeMs: out.encodeMs };
};

const audioThumbnail = async (url, options = {}) => {
  const opts = normalizeOptions(options);
  if (!opts.fetch) throw new Error('fetch() is not available in this environment.');
  const parentSignal = opts.signal || null;
  if (parentSignal?.aborted) throw (parentSignal.reason || new Error('aborted'));

  const tStart = nowMs();
  const timing = { totalMs: 0, fetchMsTotal: 0, decodeMsTotal: 0, encodeMsTotal: 0 };
  const results = [];
  const attempts = [];

  const onTiming = (e) => {
    if (typeof opts.onTiming === 'function') opts.onTiming(e);
  };

  const audioURL = new URL(url, location.href);

  if (opts.sourceStrategy === 'race' && opts.sources.includes('sidecar') && opts.sources.includes('embedded')) {
    if (opts.sidecarCache) {
      const groups = makeSidecarCandidateGroups(audioURL, opts);
      const mode = opts.sidecarValidate || 'auto';
      for (const urls of groups) {
        for (const u of urls) {
          const v = getCachedSidecarVerdict(u, opts, mode);
          if (v === true) {
            results.push({ URI: u, source: 'sidecar', kind: 'front' });
            timing.totalMs = nowMs() - tStart;
            const best = pickBestArtwork(results);
            defineHidden(results, 'best', best);
            defineHidden(results, 'timing', timing);
            return results;
          }
        }
      }
    }

    const sidecarController = new AbortController();
    const embeddedController = new AbortController();
    const onAbort = () => {
      try { sidecarController.abort(parentSignal?.reason || new Error('aborted')); } catch { /* ignore */ }
      try { embeddedController.abort(parentSignal?.reason || new Error('aborted')); } catch { /* ignore */ }
    };
    if (parentSignal) parentSignal.addEventListener('abort', onAbort, { once: true });

    const runSidecarR = async () => {
      const groups = makeSidecarCandidateGroups(audioURL, opts);
      if (opts.sidecarValidate === 'none') {
        const c = groups[0]?.[0];
        if (!c) throw new Error('No sidecar candidates generated');
        return { URI: c, source: 'sidecar', kind: 'front' };
      }

      const maxResults = 1;
      const concurrency = Math.max(1, opts.sidecarConcurrency | 0);

      const foundURLs = [];
      let i = 0;
      let active = 0;
      let stop = false;

      await new Promise((resolve) => {
        const pump = () => {
          while (!stop && active < concurrency && i < groups.length) {
            const urls = groups[i++];
            active++;
            (async () => {
              let hit = null;
              for (const c of urls) {
                const ok = await validateSidecarURL(c, opts, onTiming, sidecarController.signal).catch(() => false);
                if (ok) { hit = c; break; }
              }

              if (hit && !stop) {
                foundURLs.push(hit);
                if (foundURLs.length >= maxResults) {
                  stop = true;
                  try { sidecarController.abort(new Error('sidecar-found')); } catch { /* ignore */ }
                  active--;
                  resolve();
                  return;
                }
              }
              active--;
              if (!stop && active === 0 && i >= groups.length) resolve();
              else pump();
            })();
          }
        };
        pump();
      });

      if (foundURLs.length === 0) throw new Error('No valid sidecar URL found');
      return { URI: foundURLs[0], source: 'sidecar', kind: 'front' };
    };

    const runEmbeddedR = async () => {
      const embeddedList = await extractEmbedded(url, {
        fetch: opts.fetch,
        timeoutMs: opts.timeoutMs,
        maxBytes: opts.embedded.maxBytes,
        preferPicture: opts.embedded.preferPicture,
        onTiming,
        signal: embeddedController.signal
      });
      const first = embeddedList && embeddedList[0];
      if (!first) throw new Error('No embedded artwork extracted');
      return first;
    };

    let winner;
    try {
      winner = await Promise.any([
        runSidecarR().then((r) => ({ type: 'sidecar', r })),
        runEmbeddedR().then((e) => ({ type: 'embedded', e }))
      ]).catch((e) => {
        const msg = e?.errors?.map?.((x) => x?.message || String(x)).join(' | ') || (e?.message || String(e));
        throw new Error(`No artwork found. ${msg}`);
      });
    } finally {
      if (parentSignal) {
        try { parentSignal.removeEventListener('abort', onAbort); } catch { /* ignore */ }
      }
    }

    if (winner.type === 'sidecar') {
      try { embeddedController.abort(new Error('race-lost')); } catch { /* ignore */ }
      results.push(winner.r);
    } else {
      try { sidecarController.abort(new Error('race-lost')); } catch { /* ignore */ }
      const emb = winner.e;
      const t0 = nowMs();
      const materialized = await materializeEmbeddedArtwork(emb, opts);
      timing.encodeMsTotal += (nowMs() - t0);
      results.push({
        URI: materialized.URI,
        source: 'embedded',
        container: emb.container,
        kind: emb.kind || 'other',
        inputMime: emb.mime,
        outputMime: materialized.outputMime,
        width: materialized.width,
        height: materialized.height
      });
    }

    timing.totalMs = nowMs() - tStart;
    const best = pickBestArtwork(results);
    defineHidden(results, 'best', best);
    defineHidden(results, 'timing', timing);
    return results;
  }

  if (opts.sourceStrategy === 'all') {
    const sidecarTask = async () => {
      if (!opts.sources.includes('sidecar')) return;

      const groups = makeSidecarCandidateGroups(audioURL, opts);
      if (opts.sidecarValidate === 'none') {
        const flat = groups.flat();
        for (const c of flat.slice(0, Math.max(1, opts.sidecarMaxResults | 0))) {
          results.push({ URI: c, source: 'sidecar', kind: 'front' });
        }
        return;
      }

      const maxResults = Math.max(1, opts.sidecarMaxResults | 0);
      const concurrency = Math.max(1, opts.sidecarConcurrency | 0);
      const controller = new AbortController();
      const onAbort = () => {
        try { controller.abort(parentSignal?.reason || new Error('aborted')); } catch { /* ignore */ }
      };
      if (parentSignal) parentSignal.addEventListener('abort', onAbort, { once: true });

      const foundURLs = [];
      let i = 0;
      let active = 0;
      let stop = false;

      try {
        await new Promise((resolve) => {
          const pump = () => {
            while (!stop && active < concurrency && i < groups.length) {
              const urls = groups[i++];
              active++;
              (async () => {
                let hit = null;
                for (const c of urls) {
                  const t0 = nowMs();
                  const ok = await validateSidecarURL(c, opts, onTiming, controller.signal).catch((e) => {
                    if (!isAbortError(e)) attempts.push(`sidecar:${opts.sidecarValidate}:${c}: ${e?.message || String(e)}`);
                    return false;
                  });
                  timing.fetchMsTotal += (nowMs() - t0);
                  if (ok) { hit = c; break; }
                }

                if (hit && !stop) {
                  foundURLs.push(hit);
                  if (foundURLs.length >= maxResults) {
                    stop = true;
                    try { controller.abort(new Error('sidecar-found')); } catch { /* ignore */ }
                    active--;
                    resolve();
                    return;
                  }
                }

                active--;
                if (!stop && active === 0 && i >= groups.length) resolve();
                else pump();
              })();
            }
          };
          pump();
        });
      } finally {
        if (parentSignal) {
          try { parentSignal.removeEventListener('abort', onAbort); } catch { /* ignore */ }
        }
      }

      for (const c of foundURLs) results.push({ URI: c, source: 'sidecar', kind: 'front' });
    };

    const embeddedTask = async () => {
      if (!opts.sources.includes('embedded')) return;
      try {
        const embeddedList = await extractEmbedded(url, {
          fetch: opts.fetch,
          timeoutMs: opts.timeoutMs,
          maxBytes: opts.embedded.maxBytes,
          preferPicture: opts.embedded.preferPicture,
          onTiming,
          signal: parentSignal
        });

        for (const emb of embeddedList) {
          const t0 = nowMs();
          const materialized = await materializeEmbeddedArtwork(emb, opts);
          timing.encodeMsTotal += (nowMs() - t0);
          results.push({
            URI: materialized.URI,
            source: 'embedded',
            container: emb.container,
            kind: emb.kind || 'other',
            inputMime: emb.mime,
            outputMime: materialized.outputMime,
            width: materialized.width,
            height: materialized.height
          });
        }
      } catch (e) {
        attempts.push(`embedded:${e?.message || String(e)}`);
      }
    };

    await Promise.allSettled([sidecarTask(), embeddedTask()]);

    timing.totalMs = nowMs() - tStart;
    const best = pickBestArtwork(results);
    defineHidden(results, 'best', best);
    defineHidden(results, 'timing', timing);

    if (!best) throw new Error(`No artwork found. ${summarizeAttempts(attempts)}`);
    return results;
  }

  if (opts.sources.includes('sidecar')) {
    const groups = makeSidecarCandidateGroups(audioURL, opts);
    if (opts.sidecarValidate === 'none') {
      const flat = groups.flat();
      for (const c of flat.slice(0, opts.sidecarMaxResults)) {
        results.push({ URI: c, source: 'sidecar', kind: 'front' });
      }
    } else {
      const maxResults = Math.max(1, opts.sidecarMaxResults | 0);
      const concurrency = Math.max(1, opts.sidecarConcurrency | 0);
      const controller = new AbortController();
      const onAbort = () => {
        try { controller.abort(parentSignal?.reason || new Error('aborted')); } catch { /* ignore */ }
      };
      if (parentSignal) parentSignal.addEventListener('abort', onAbort, { once: true });

      const foundURLs = [];
      let i = 0;
      let active = 0;
      let stop = false;

      try {
        await new Promise((resolve) => {
          const pump = () => {
            while (!stop && active < concurrency && i < groups.length) {
              const urls = groups[i++];
              active++;
              (async () => {
                let hit = null;
                for (const c of urls) {
                  const t0 = nowMs();
                  const ok = await validateSidecarURL(c, opts, onTiming, controller.signal).catch((e) => {
                    if (!isAbortError(e)) attempts.push(`sidecar:${opts.sidecarValidate}:${c}: ${e?.message || String(e)}`);
                    return false;
                  });
                  timing.fetchMsTotal += (nowMs() - t0);
                  if (ok) { hit = c; break; }
                }

                if (hit && !stop) {
                  foundURLs.push(hit);
                  if (foundURLs.length >= maxResults) {
                    stop = true;
                    try { controller.abort(new Error('sidecar-found')); } catch { /* ignore */ }
                    active--;
                    resolve();
                    return;
                  }
                }

                active--;
                if (!stop && active === 0 && i >= groups.length) {
                  resolve();
                  return;
                }
                pump();
              })();
            }
          };
          pump();
        });

        for (const c of foundURLs) results.push({ URI: c, source: 'sidecar', kind: 'front' });
      } finally {
        if (parentSignal) {
          try { parentSignal.removeEventListener('abort', onAbort); } catch { /* ignore */ }
        }
      }
    }
  }

  if (results.length === 0 && opts.sources.includes('embedded')) {
    try {
      const embeddedList = await extractEmbedded(url, {
        fetch: opts.fetch,
        timeoutMs: opts.timeoutMs,
        maxBytes: opts.embedded.maxBytes,
        preferPicture: opts.embedded.preferPicture,
        onTiming,
        signal: parentSignal
      });

      for (const emb of embeddedList) {
        const t0 = nowMs();
        const materialized = await materializeEmbeddedArtwork(emb, opts);
        timing.encodeMsTotal += (nowMs() - t0);
        results.push({
          URI: materialized.URI,
          source: 'embedded',
          container: emb.container,
          kind: emb.kind || 'other',
          inputMime: emb.mime,
          outputMime: materialized.outputMime,
          width: materialized.width,
          height: materialized.height
        });
      }
    } catch (e) {
      attempts.push(`embedded:${e?.message || String(e)}`);
    }
  }

  timing.totalMs = nowMs() - tStart;
  const best = pickBestArtwork(results);

  defineHidden(results, 'best', best);
  defineHidden(results, 'timing', timing);

  if (!best) {
    throw new Error(`No artwork found. ${summarizeAttempts(attempts)}`);
  }
  return results;
};

audioThumbnail.cleanupObjectURLs = () => cleanupObjectURLs();
audioThumbnail.clearCanvasPool = () => clearCanvasPool();
audioThumbnail.getMemoryUsage = () => ({
  canvasPoolEntries: getCanvasPoolEntries(),
  activeObjectURLs: getActiveObjectURLCount()
});

global.audioThumbnail = audioThumbnail;

const textDecoder = new TextDecoder('utf-8');

const readVint = (b, o, mask) => {
  if (o >= b.length) return null;
  const first = b[o];
  let len = 0;
  for (let i = 0; i < 8; i++) {
    if (first & (1 << (7 - i))) { len = i + 1; break; }
  }
  if (!len || o + len > b.length) return null;

  let val = 0;
  if (mask) {
    val = first & ((1 << (8 - len)) - 1);
  } else {
    val = first;
  }
  for (let i = 1; i < len; i++) val = (val << 8) | b[o + i];

  let unknown = false;
  if (mask) {
    const allOnes = (len === 1)
      ? (val === 0x7f)
      : (val === ((1 << (7 * len)) - 1));
    unknown = allOnes;
  }
  return { len, val, unknown };
};

const ID_ATTACHMENTS = 0x1941A469;
const ID_SEGMENT = 0x18538067;
const ID_ATTACHED_FILE = 0x61A7;
const ID_FILE_NAME = 0x466E;
const ID_FILE_MIME = 0x4660;
const ID_FILE_DATA = 0x465C;

const bytesToString = (b) => {
  try { return textDecoder.decode(b); } catch { return ''; }
};

const hasAscii = (b, s) => {
  const pat = new TextEncoder().encode(s);
  for (let i = 0; i + pat.length <= b.length; i++) {
    let ok = true;
    for (let j = 0; j < pat.length; j++) {
      if (b[i + j] !== pat[j]) { ok = false; break; }
    }
    if (ok) return true;
  }
  return false;
};

const extractFirstJPEGStream = (b, minBytes = 2048) => {
  for (let i = 0; i + 3 < b.length; i++) {
    if (b[i] !== 0xff || b[i + 1] !== 0xd8) continue;

    for (let j = i + 2; j + 1 < b.length; j++) {
      if (b[j] === 0xff && b[j + 1] === 0xd9) {
        const end = j + 2;
        const len = end - i;
        if (len >= minBytes) return b.subarray(i, end);
        i = end - 1;
        break;
      }
    }
  }
  return null;
};

const parseElements = (b, start, end, onElement) => {
  let p = start;
  while (p < end) {
    const idV = readVint(b, p, false);
    if (!idV) return;
    p += idV.len;

    const sizeV = readVint(b, p, true);
    if (!sizeV) return;
    p += sizeV.len;

    const dataStart = p;
    let dataEnd = sizeV.unknown ? end : (p + sizeV.val);
    if (dataEnd > end) dataEnd = end;

    onElement(idV.val, dataStart, dataEnd);
    p = dataEnd;
  }
};

const looksLikeCoverName = (name) => {
  const n = (name || '').toLowerCase();
  return n.includes('cover') || n.includes('front') || n.includes('folder') || n.includes('art');
};

const extractEmbeddedArtworkMKV = async (url, opts) => {
  const { fetch, timeoutMs, maxBytes, preferPicture, signal } = opts || {};

  const b = await fetchBytes(url, { fetch, timeoutMs, maxBytes, signal });
  if (b.length < 32) throw new Error('MKV too small');

  const out = [];

  const parseAttachedFile = (start, end) => {
    let fileName = '';
    let mime = '';
    let fileData = null;

    parseElements(b, start, end, (id, ds, de) => {
      if (id === ID_FILE_NAME) fileName = bytesToString(b.subarray(ds, de));
      else if (id === ID_FILE_MIME) mime = bytesToString(b.subarray(ds, de));
      else if (id === ID_FILE_DATA) fileData = b.subarray(ds, de);
    });

    if (!fileData || fileData.length === 0) return;
    if (!mime) {
      if (fileData[0] === 0xff && fileData[1] === 0xd8) mime = 'image/jpeg';
      else if (fileData[0] === 0x89 && fileData[1] === 0x50 && fileData[2] === 0x4e && fileData[3] === 0x47) mime = 'image/png';
      else if (fileData[0] === 0x52 && fileData[1] === 0x49 && fileData[2] === 0x46 && fileData[3] === 0x46) mime = 'image/webp';
      else mime = 'application/octet-stream';
    }
    if (!mime.startsWith('image/')) return;

    const kind = looksLikeCoverName(fileName) ? 'front' : 'other';
    out.push({ bytes: fileData, mime, kind, container: 'mka', fileName });
  };

  const parseAttachments = (start, end) => {
    parseElements(b, start, end, (id, ds, de) => {
      if (id === ID_ATTACHED_FILE) parseAttachedFile(ds, de);
    });
  };

  const parseSegment = (start, end) => {
    parseElements(b, start, end, (id, ds, de) => {
      if (id === ID_ATTACHMENTS) parseAttachments(ds, de);
    });
  };

  parseElements(b, 0, b.length, (id, ds, de) => {
    if (id === ID_SEGMENT) parseSegment(ds, de);
    if (id === ID_ATTACHMENTS) parseAttachments(ds, de);
  });

  if (out.length === 0) {
    if (hasAscii(b, 'V_MJPEG')) {
      const jpg = extractFirstJPEGStream(b, 4096);
      if (jpg) out.push({ bytes: jpg, mime: 'image/jpeg', kind: 'front', container: 'mka' });
    }
  }

  if (out.length === 0) throw new Error('No MKV artwork found (no attachments, no detectable cover stream)');

  if (preferPicture === 'front') {
    const front = out.filter((x) => x.kind === 'front');
    return (front.length ? front : out);
  }
  return out;
};

const extractEmbeddedArtworkMKA = async (url, opts) => {
  const out = await extractEmbeddedArtworkMKV(url, opts);
  return out.map((x) => ({ ...x, container: 'mka' }));
};

const u64be = (b, o) => {
  const hi = u32be(b, o);
  const lo = u32be(b, o + 4);
  return hi * 2 ** 32 + lo;
};

function *iterBoxes(b, start, end) {
  let p = start;
  while (p + 8 <= end) {
    let size = u32be(b, p);
    const type = bytesToAscii(b, p + 4, 4);
    let header = 8;
    if (size === 1) {
      if (p + 16 > end) break;
      size = u64be(b, p + 8);
      header = 16;
    } else if (size === 0) {
      size = end - p;
    }
    if (!size || size < header) break;
    const boxStart = p;
    const boxEnd = Math.min(end, p + size);
    const dataStart = p + header;
    yield { type, start: boxStart, end: boxEnd, header, dataStart };
    p = boxEnd;
  }
}

const findChildBox = (b, parent, type) => {
  for (const box of iterBoxes(b, parent.dataStart, parent.end)) {
    if (box.type === type) return box;
  }
  return null;
};

const extractCovrFromIlst = (b, ilstBox) => {
  for (const item of iterBoxes(b, ilstBox.dataStart, ilstBox.end)) {
    if (item.type !== 'covr') continue;

    for (const child of iterBoxes(b, item.dataStart, item.end)) {
      if (child.type !== 'data') continue;

      const p = child.dataStart;
      if (p + 8 > child.end) continue;

      const sniffMimeAt = (off) => {
        if (off + 12 > child.end) return null;
        const x = b.subarray(off, off + 12);
        if (x[0] === 0xff && x[1] === 0xd8) return 'image/jpeg';
        if (x[0] === 0x89 && x[1] === 0x50 && x[2] === 0x4e && x[3] === 0x47) return 'image/png';
        if (x[0] === 0x52 && x[1] === 0x49 && x[2] === 0x46 && x[3] === 0x46 && x[8] === 0x57 && x[9] === 0x45 && x[10] === 0x42 && x[11] === 0x50) return 'image/webp';
        return null;
      };

      const starts = [p + 8, p + 12, p + 16].filter((s) => s < child.end);
      let payloadStart = starts[0];
      let mime = null;
      for (const s of starts) {
        const m = sniffMimeAt(s);
        if (m) {
          payloadStart = s;
          mime = m;
          break;
        }
      }
      const payload = b.subarray(payloadStart, child.end);
      if (!mime) mime = sniffMimeAt(payloadStart) || 'application/octet-stream';

      return { bytes: payload, mime, kind: 'front', container: 'm4a' };
    }
  }
  return null;
};

const extractEmbeddedArtworkM4A = async (url, opts) => {
  const { fetch, timeoutMs, maxBytes, signal } = opts || {};

  const b = await fetchBytes(url, { fetch, timeoutMs, maxBytes, signal });
  if (b.length < 16) throw new Error('M4A too small');

  const root = { type: 'root', dataStart: 0, end: b.length };

  const moov = findChildBox(b, root, 'moov');
  if (!moov) throw new Error('No moov box found');

  const udta = findChildBox(b, moov, 'udta');
  if (!udta) throw new Error('No udta box found');
  const meta = findChildBox(b, udta, 'meta');
  if (!meta) throw new Error('No meta box found');

  const metaAsContainer = { ...meta, dataStart: meta.dataStart + 4 };
  const ilst = findChildBox(b, metaAsContainer, 'ilst');
  if (!ilst) throw new Error('No ilst box found');

  const covr = extractCovrFromIlst(b, ilst);
  if (!covr) throw new Error('No covr artwork found');

  return [covr];
};

const canvasPool = new Map();

const getCanvas = (width, height) => {
  const key = `${width}x${height}`;
  if (canvasPool.has(key)) {
    const canvas = canvasPool.get(key);
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, width, height);
    return { canvas, ctx };
  }
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  canvasPool.set(key, canvas);
  const ctx = canvas.getContext('2d');
  return { canvas, ctx };
};

const clearCanvasPool = () => {
  const n = canvasPool.size;
  canvasPool.clear();
  return n > 0;
};

const getCanvasPoolEntries = () => canvasPool.size;

const decodeToBitmap = async (bytes, mime) => {
  const blob = new Blob([bytes], { type: mime || 'application/octet-stream' });
  if (typeof createImageBitmap === 'function') {
    return await createImageBitmap(blob);
  }
  const uri = URL.createObjectURL(blob);
  try {
    const img = new Image();
    img.decoding = 'async';
    await new Promise((resolve, reject) => {
      img.onload = resolve;
      img.onerror = reject;
      img.src = uri;
    });
    return img;
  } finally {
    try { URL.revokeObjectURL(uri); } catch { /* ignore */ }
  }
};

const canvasToBlob = (canvas, mime, quality) => {
  if (canvas && typeof canvas.convertToBlob === 'function') {
    return canvas.convertToBlob({ type: mime, quality });
  }
  return new Promise((resolve, reject) => {
    canvas.toBlob((blob) => {
      if (!blob) reject(new Error('toBlob returned null'));
      else resolve(blob);
    }, mime, quality);
  });
};

const transcodeImageBytesToOutput = async (bytes, inputMime, output) => {
  const outMime = output?.mime?.type || inputMime || 'image/jpeg';
  const quality = output?.mime?.quality;
  const size = output?.size;
  const type = output?.type || 'objectURL';

  const bitmap = await decodeToBitmap(bytes, inputMime);
  const srcW = bitmap.width || bitmap.naturalWidth;
  const srcH = bitmap.height || bitmap.naturalHeight;
  if (!srcW || !srcH) throw new Error('Unable to determine image dimensions');

  const dstW = size ? Math.max(1, Math.round(size)) : srcW;
  const dstH = size ? Math.max(1, Math.round((srcH * dstW) / srcW)) : srcH;

  const { canvas, ctx } = getCanvas(dstW, dstH);
  ctx.drawImage(bitmap, 0, 0, dstW, dstH);

  try { bitmap.close?.(); } catch { /* ignore */ }

  if (type === 'dataURI') {
    const uri = canvas.toDataURL(outMime, quality);
    return { URI: uri, type: 'dataURI', mime: { type: outMime, quality }, width: dstW, height: dstH };
  }

  const blob = await canvasToBlob(canvas, outMime, quality);
  const uri = URL.createObjectURL(blob);
  return { URI: uri, type: 'objectURL', mime: { type: outMime, quality }, width: dstW, height: dstH };
};

const u32be = (b, o) => ((b[o] << 24) | (b[o + 1] << 16) | (b[o + 2] << 8) | b[o + 3]) >>> 0;
const synchsafe32 = (b, o) => ((b[o] & 0x7f) << 21) | ((b[o + 1] & 0x7f) << 14) | ((b[o + 2] & 0x7f) << 7) | (b[o + 3] & 0x7f);
const bytesToAscii = (b, o, n) => String.fromCharCode.apply(null, b.subarray(o, o + n));

const findTerminator = (b, start, encoding) => {
  if (encoding === 0 || encoding === 3) {
    for (let i = start; i < b.length; i++) if (b[i] === 0x00) return i;
    return -1;
  }
  for (let i = start; i + 1 < b.length; i++) if (b[i] === 0x00 && b[i + 1] === 0x00) return i;
  return -1;
};

const mimeFromPICFormat = (fmt3) => {
  const f = (fmt3 || '').toUpperCase();
  if (f === 'JPG' || f === 'JPEG') return 'image/jpeg';
  if (f === 'PNG') return 'image/png';
  if (f === 'WEB') return 'image/webp';
  return 'application/octet-stream';
};

const kindFromPictureType = (pt) => (pt === 3 ? 'front' : 'other');

const parseAPIC = (frameBytes) => {
  if (frameBytes.length < 4) return null;
  const enc = frameBytes[0];
  let p = 1;
  const mimeEnd = frameBytes.indexOf(0x00, p);
  if (mimeEnd < 0) return null;
  const mime = bytesToAscii(frameBytes, p, mimeEnd - p);
  p = mimeEnd + 1;
  if (p >= frameBytes.length) return null;
  const picType = frameBytes[p++];

  const descEnd = findTerminator(frameBytes, p, enc);
  if (descEnd < 0) return null;
  p = (enc === 0 || enc === 3) ? (descEnd + 1) : (descEnd + 2);
  if (p >= frameBytes.length) return null;

  if (mime === '-->') return null;
  const bytes = frameBytes.subarray(p);
  return { bytes, mime, kind: kindFromPictureType(picType) };
};

const parsePIC = (frameBytes) => {
  if (frameBytes.length < 6) return null;
  const enc = frameBytes[0];
  const fmt3 = bytesToAscii(frameBytes, 1, 3);
  let p = 4;
  const picType = frameBytes[p++];
  const descEnd = findTerminator(frameBytes, p, enc);
  if (descEnd < 0) return null;
  p = (enc === 0 || enc === 3) ? (descEnd + 1) : (descEnd + 2);
  if (p >= frameBytes.length) return null;
  const mime = mimeFromPICFormat(fmt3);
  const bytes = frameBytes.subarray(p);
  return { bytes, mime, kind: kindFromPictureType(picType) };
};

const extractEmbeddedArtworkMP3 = async (url, opts) => {
  const { fetch, timeoutMs, maxBytes, preferPicture, signal } = opts || {};

  const head = await fetchBytes(url, { fetch, timeoutMs, maxBytes: 64, allowTruncate: true, signal, range: { start: 0, end: 9 } });
  if (head.length < 10) throw new Error('MP3 too small');
  if (bytesToAscii(head, 0, 3) !== 'ID3') throw new Error('No ID3v2 tag found');

  const verMajor = head[3];
  const flags = head[5];
  const tagSize = synchsafe32(head, 6);
  const total = 10 + tagSize;
  if (total > maxBytes) throw new Error(`ID3 tag size (${total}) exceeds maxBytes (${maxBytes})`);

  const tag = await fetchBytes(url, { fetch, timeoutMs, maxBytes: total, allowTruncate: true, signal, range: { start: 0, end: total - 1 } });
  if (tag.length < total) throw new Error(`Unable to fetch full ID3 tag (${tag.length}/${total} bytes)`);
  let p = 10;

  if (flags & 0x40) {
    if (verMajor === 3) {
      const extSize = u32be(tag, p);
      p += 4 + extSize;
    } else if (verMajor === 4) {
      const extSize = synchsafe32(tag, p);
      p += extSize;
    } else {
      throw new Error(`Unsupported ID3 version: 2.${verMajor}`);
    }
  }

  const out = [];
  while (p + 6 < tag.length) {
    if (tag[p] === 0x00) break;

    if (verMajor === 2) {
      const id = bytesToAscii(tag, p, 3);
      const size = ((tag[p + 3] << 16) | (tag[p + 4] << 8) | tag[p + 5]) >>> 0;
      p += 6;
      if (!id.trim() || size === 0 || p + size > tag.length) break;
      const frame = tag.subarray(p, p + size);
      p += size;
      if (id === 'PIC') {
        const pic = parsePIC(frame);
        if (pic) out.push({ ...pic, container: 'mp3' });
      }
      continue;
    }

    if (p + 10 > tag.length) break;
    const id = bytesToAscii(tag, p, 4);
    const size = (verMajor === 4) ? synchsafe32(tag, p + 4) : u32be(tag, p + 4);
    p += 10;
    if (!id.trim() || size === 0 || p + size > tag.length) break;
    const frame = tag.subarray(p, p + size);
    p += size;

    if (id === 'APIC') {
      const pic = parseAPIC(frame);
      if (pic) out.push({ ...pic, container: 'mp3' });
    }
  }

  if (out.length === 0) throw new Error('No embedded pictures found in ID3 tag');

  if (preferPicture === 'front') {
    const front = out.filter((x) => x.kind === 'front');
    return (front.length ? front : out);
  }
  return out;
};

const stripExtension = (filename) => {
  const i = filename.lastIndexOf('.');
  if (i <= 0) return filename;
  return filename.slice(0, i);
};

const makeSidecarCandidates = (audioURL, opts) => {
  const candidates = [];

  const add = (filename) => {
    const resolved = opts.resolveSidecarURL
      ? opts.resolveSidecarURL(audioURL, filename)
      : new URL(filename, audioURL);
    const u = (resolved instanceof URL) ? resolved : new URL(String(resolved), audioURL);
    candidates.push(u.toString());
  };

  for (const name of opts.sidecarNames || []) {
    for (const ext of opts.sidecarExts || []) add(`${name}.${ext}`);
  }

  if (opts.sidecarIncludeBasename) {
    const leaf = audioURL.pathname.split('/').pop() || '';
    const base = stripExtension(leaf);
    if (base) {
      for (const ext of opts.sidecarExts || []) add(`${base}.${ext}`);
    }
  }

  return [...new Set(candidates)];
};

const makeSidecarCandidateGroups = (audioURL, opts) => {
  const groups = [];

  const resolve = (filename) => {
    const resolved = opts.resolveSidecarURL
      ? opts.resolveSidecarURL(audioURL, filename)
      : new URL(filename, audioURL);
    const u = (resolved instanceof URL) ? resolved : new URL(String(resolved), audioURL);
    return u.toString();
  };

  const stems = [];
  for (const name of opts.sidecarNames || []) stems.push(String(name));

  if (opts.sidecarIncludeBasename) {
    const leaf = audioURL.pathname.split('/').pop() || '';
    const base = stripExtension(leaf);
    if (base) stems.push(base);
  }

  const seenStem = new Set();
  for (const stem of stems) {
    if (!stem) continue;
    if (seenStem.has(stem)) continue;
    seenStem.add(stem);

    const urls = [];
    const seenURL = new Set();
    for (const ext of opts.sidecarExts || []) {
      const u = resolve(`${stem}.${ext}`);
      if (seenURL.has(u)) continue;
      seenURL.add(u);
      urls.push(u);
    }
    if (urls.length) groups.push(urls);
  }

  return groups;
};

const getSessionStorage = () => {
  try {
    if (typeof sessionStorage === 'undefined') return null;
    sessionStorage.length;
    return sessionStorage;
  } catch {
    return null;
  }
};

const cacheKey = (opts, method, url) => {
  const prefix = opts.sidecarCacheKeyPrefix || 'audio-thumbnail.js';
  return `${prefix}:sidecar:${method}:${url}`;
};

const cacheGet = (opts, method, url) => {
  if (!opts.sidecarCache) return { hit: false };
  const ss = getSessionStorage();
  if (!ss) return { hit: false };
  const v = ss.getItem(cacheKey(opts, method, url));
  if (v === null) return { hit: false };
  if (v === '1') return { hit: true, val: true };
  if (v === '0') return { hit: true, val: false };
  if (v === '-1') return { hit: true, val: null };
  return { hit: false };
};

const cacheSet = (opts, method, url, val) => {
  if (!opts.sidecarCache) return;
  const ss = getSessionStorage();
  if (!ss) return;
  const v = (val === true) ? '1' : (val === false) ? '0' : '-1';
  try { ss.setItem(cacheKey(opts, method, url), v); } catch { /* ignore */ }
};

const getCachedSidecarVerdict = (url, opts, mode = null) => {
  const m = mode || opts?.sidecarValidate || 'auto';
  const cached = cacheGet(opts || {}, `any:${m}`, url);
  if (!cached.hit) return undefined;
  return cached.val;
};

const withTimeoutSignal = (parentSignal, timeoutMs) => {
  const controller = new AbortController();
  const onAbort = () => {
    try { controller.abort(parentSignal?.reason || new Error('aborted')); } catch { /* ignore */ }
  };
  if (parentSignal) {
    if (parentSignal.aborted) onAbort();
    else parentSignal.addEventListener('abort', onAbort, { once: true });
  }
  const timeoutId = setTimeout(() => controller.abort(new Error('timeout')), timeoutMs);
  const cleanup = () => {
    clearTimeout(timeoutId);
    if (parentSignal) {
      try { parentSignal.removeEventListener('abort', onAbort); } catch { /* ignore */ }
    }
  };
  return { controller, signal: controller.signal, cleanup };
};

const validateHead = async (url, opts, parentSignal) => {
  const cached = cacheGet(opts, 'head', url);
  if (cached.hit) return cached.val;

  const { signal, cleanup } = withTimeoutSignal(parentSignal, opts.timeoutMs);
  try {
    const res = await opts.fetch(url, { method: 'HEAD', signal });
    if (res.ok) {
      const ct = res.headers?.get?.('content-type') || '';
      if (ct && !ct.toLowerCase().startsWith('image/')) return false;
      return true;
    }

    if (res.status === 404 || res.status === 410) return false;
    return null;
  } catch (e) {
    if (isAbortError(e) || parentSignal?.aborted) throw e;
    return null;
  } finally {
    cleanup();
  }
};

const validateGetRange = async (url, opts, parentSignal) => {
  const cached = cacheGet(opts, 'get-range', url);
  if (cached.hit) return cached.val;

  const { controller, signal, cleanup } = withTimeoutSignal(parentSignal, opts.timeoutMs);
  try {
    const headers = new Headers();
    headers.set('Range', 'bytes=0-0');
    const res = await opts.fetch(url, { method: 'GET', headers, signal });

    try { res.body?.cancel?.(); } catch { /* ignore */ }
    try { controller.abort(); } catch { /* ignore */ }

    if (res.status === 206 || res.status === 200) {
      const ct = res.headers?.get?.('content-type') || '';
      if (ct && !ct.toLowerCase().startsWith('image/')) return false;
      return true;
    }

    if (res.status === 404 || res.status === 410) return false;
    return null;
  } catch (e) {
    if (isAbortError(e) || parentSignal?.aborted) throw e;
    return null;
  } finally {
    cleanup();
  }
};

const validateImg = (url, opts, parentSignal) => {
  const cached = cacheGet(opts, 'img', url);
  if (cached.hit) return Promise.resolve(cached.val === true);

  return new Promise((resolve, reject) => {
    const img = new Image();
    let done = false;

    const timeoutId = setTimeout(() => finish(false), opts.timeoutMs);

    const finish = (ok) => {
      if (done) return;
      done = true;
      clearTimeout(timeoutId);
      img.onload = null;
      img.onerror = null;
      if (parentSignal) {
        try { parentSignal.removeEventListener('abort', onAbort); } catch { /* ignore */ }
      }
      cacheSet(opts, 'img', url, ok);
      resolve(ok);
    };

    const onAbort = () => {
      if (done) return;
      try { img.src = ''; } catch { /* ignore */ }
      clearTimeout(timeoutId);
      img.onload = null;
      img.onerror = null;
      try { parentSignal.removeEventListener('abort', onAbort); } catch { /* ignore */ }
      done = true;
      reject(parentSignal?.reason || new DOMException('Aborted', 'AbortError'));
    };

    if (parentSignal) {
      if (parentSignal.aborted) return onAbort();
      parentSignal.addEventListener('abort', onAbort, { once: true });
    }

    img.decoding = 'async';
    img.onload = () => finish(true);
    img.onerror = () => finish(false);
    img.src = url;
  });
};

const validateSidecarURL = async (url, opts, onTiming, signal = null) => {
  if (signal?.aborted) throw (signal.reason || new DOMException('Aborted', 'AbortError'));

  const mode = opts.sidecarValidate || 'auto';
  const cachedAny = cacheGet(opts, `any:${mode}`, url);
  if (cachedAny.hit && cachedAny.val !== null) return cachedAny.val === true;

  const t0 = nowMs();

  const emit = (when, extra) => {
    if (typeof onTiming === 'function') onTiming({ phase: 'sidecar-validate', when, ts: nowMs(), url, mode, ...extra });
  };

  const cacheMaybeSet = (method, val) => {
    if (signal?.aborted) return;
    cacheSet(opts, method, url, val);
  };

  emit('start');
  try {
    let result = false;

    if (mode === 'head') {
      const v = await validateHead(url, opts, signal);
      cacheMaybeSet('head', v);
      result = (v === true);
      cacheMaybeSet(`any:${mode}`, result);
      return result;
    }

    if (mode === 'get-range') {
      const v = await validateGetRange(url, opts, signal);
      cacheMaybeSet('get-range', v);
      result = (v === true);
      cacheMaybeSet(`any:${mode}`, result);
      return result;
    }

    if (mode === 'img') {
      result = await validateImg(url, opts, signal);
      cacheMaybeSet(`any:${mode}`, result);
      return result;
    }

    if (mode === 'none') {
      cacheMaybeSet(`any:${mode}`, true);
      return true;
    }

    try {
      const head = await validateHead(url, opts, signal);
      cacheMaybeSet('head', head);
      if (head === true) {
        cacheMaybeSet(`any:${mode}`, true);
        return true;
      }
      if (head === false) {
        cacheMaybeSet(`any:${mode}`, false);
        return false;
      }
    } catch {
      if (signal?.aborted) throw (signal.reason || new DOMException('Aborted', 'AbortError'));
    }
    try {
      const get = await validateGetRange(url, opts, signal);
      cacheMaybeSet('get-range', get);
      if (get === true) {
        cacheMaybeSet(`any:${mode}`, true);
        return true;
      }
      if (get === false) {
        cacheMaybeSet(`any:${mode}`, false);
        return false;
      }
    } catch {
      if (signal?.aborted) throw (signal.reason || new DOMException('Aborted', 'AbortError'));
    }
    result = await validateImg(url, opts, signal);
    cacheMaybeSet(`any:${mode}`, result);
    return result;
  } finally {
    emit('end', { ms: nowMs() - t0 });
  }
};

const defineHidden = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    value,
    enumerable: false,
    configurable: true,
    writable: true
  });
};

const pickBestArtwork = (results) => {
  if (!results || results.length === 0) return null;
  const front = results.find((r) => r && r.kind === 'front');
  return front || results[0];
};

const summarizeAttempts = (attempts) => {
  if (!attempts || attempts.length === 0) return '';
  const max = 8;
  const head = attempts.slice(0, max).join(' | ');
  const more = attempts.length > max ? ` | (+${attempts.length - max} more)` : '';
  return `Attempts: ${head}${more}`;
};

const bytesToObjectURL = (bytes, mime) => {
  const blob = new Blob([bytes], { type: mime || 'application/octet-stream' });
  return URL.createObjectURL(blob);
};

const bytesToDataURI = (bytes, mime) => {
  const bin = [];
  const chunk = 0x8000;
  for (let i = 0; i < bytes.length; i += chunk) {
    bin.push(String.fromCharCode.apply(null, bytes.subarray(i, i + chunk)));
  }
  const b64 = btoa(bin.join(''));
  return `data:${mime || 'application/octet-stream'};base64,${b64}`;
};

const trackObjectURL = (uri) => {
  if (typeof uri === 'string' && uri.startsWith('blob:')) _audioThumbnailActiveObjectURLs.add(uri);
};

const cleanupObjectURLs = () => {
  let n = 0;
  for (const uri of _audioThumbnailActiveObjectURLs) {
    try {
      URL.revokeObjectURL(uri);
      n++;
    } catch {
      // ignore
    }
  }
  _audioThumbnailActiveObjectURLs.clear();
  return n;
};

const getActiveObjectURLCount = () => _audioThumbnailActiveObjectURLs.size;

const fetchBytes = async (url, opts) => {
  const {
    fetch,
    timeoutMs = 15000,
    maxBytes = 8000000,
    allowTruncate = false,
    signal = null,
    range = null
  } = opts || {};

  if (typeof fetch !== 'function') throw new Error('fetchBytes: fetch is required');

  const controller = new AbortController();
  const onAbort = () => {
    try { controller.abort(signal?.reason || new Error('aborted')); } catch { /* ignore */ }
  };
  if (signal) {
    if (signal.aborted) onAbort();
    else signal.addEventListener('abort', onAbort, { once: true });
  }
  const timeoutId = setTimeout(() => controller.abort(new Error('timeout')), timeoutMs);

  try {
    const headers = new Headers();
    if (range && Number.isFinite(range.start) && Number.isFinite(range.end) && range.start >= 0 && range.end >= range.start) {
      headers.set('Range', `bytes=${range.start}-${range.end}`);
    }

    const res = await fetch(url, { method: 'GET', headers, signal: controller.signal });
    if (!res.ok && res.status !== 206) {
      throw new Error(`HTTP ${res.status} ${res.statusText || ''}`.trim());
    }

    if (res.body && typeof res.body.getReader === 'function') {
      const reader = res.body.getReader();
      const chunks = [];
      let total = 0;
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        if (value) {
          total += value.byteLength;
          if (total > maxBytes) {
            if (!allowTruncate) {
              try { controller.abort(new Error('maxBytes')); } catch { /* ignore */ }
              try { reader.cancel(); } catch { /* ignore */ }
              throw new Error(`Response exceeded maxBytes (${maxBytes})`);
            }

            const over = total - maxBytes;
            const keepLen = value.byteLength - over;
            if (keepLen > 0) chunks.push(value.subarray(0, keepLen));
            total = maxBytes;
            try { reader.cancel(); } catch { /* ignore */ }
            break;
          }
          chunks.push(value);
        }
      }
      const out = new Uint8Array(total);
      let off = 0;
      for (const c of chunks) {
        out.set(c, off);
        off += c.byteLength;
      }
      return out;
    }

    const ab = await res.arrayBuffer();
    if (ab.byteLength > maxBytes) throw new Error(`Response exceeded maxBytes (${maxBytes})`);
    return new Uint8Array(ab);
  } finally {
    clearTimeout(timeoutId);
    if (signal) {
      try { signal.removeEventListener('abort', onAbort); } catch { /* ignore */ }
    }
  }
};
</script>

  <!-- File Pickers -->
  <script type="module">
    const global = window;
    const isDebug = () => !!(global.app && global.app.options && global.app.options.debug);
    const logInfo = (...args) => { if (isDebug()) console.info(...args); }
    /*
      You must supply the appropriate keys in the `app.options.cloud` at the top of this <script> block AND register your app with
      Google and/or Microsoft.

      player.html also *must be served over HTTPS* for the Google and MS auth flows to work
    */
    function filePickerMain() {
      // Show the cloud buttons if OneDrive and/or Gdrive are configured
      if (isHTTPS()) {
        if (onedriveCheck()) $('.btn-onedrive').show();
        if (gdriveCheck())   $('.btn-gdrive').show();
      }
    }

    function isHTTPS() {
      return location.protocol === 'https:';
    }

    function onedriveCheck() {
      return isSet(app.options.cloud.onedrive.clientId);
    }

    function gdriveCheck() {
      const opts = app.options.cloud;
      return isSet(opts.gdrive.developerKey) && isSet(opts.gdrive.clientId) && isSet(opts.gdrive.appId);
    }

    function isSet(v) {
      return (typeof v !== 'undefined' && v.length > 0);
    }

    function onedrive() {
      const p = new Promise((resolve, reject) => {
        function complete(res) {
          if (!res || !res.value || !res.value[0]) {
            // Common case: user closes the picker without choosing a file.
            logInfo('OneDrive picker closed without a file');
            resolve();
            return;
          }

          const file = res.value[0];
          const metadata = {
            source: 'OneDrive',
            id: file.id,
            name: file.name,
            url: file['@microsoft.graph.downloadUrl'],
            size: file.size,
            mimeType: file.file.mimeType,
            duration:
              file.video && file.video.duration ? file.video.duration : undefined,
            media: file.video || {}
          };
          resolve(metadata);
        }

        var opts = {
          clientId: app.options.cloud.onedrive.clientId,
          action: 'download',
          multiSelect: false,
          advanced: {
            queryParameters:
              'select=id,name,size,file,audio,video,@microsoft.graph.downloadUrl',
            filter: 'mp4,webm,mkv,wav,mp3,aac,m4a,ogg',
            navigation: {
              sourceTypes: ['OneDrive', 'Sites', 'Recent']
            },
            viewType: 'files'
          },
          success: complete,
          cancel: complete,
          error: reject
        };

        global.OneDrive.open(opts);
      });

      return p;
    }
    global.onedrive = onedrive;
    function gdrive() {
      const p = new Promise((resolve, reject) => {
        const opts = app.options.cloud.gdrive;
        const developerKey = opts.developerKey; // The Browser API key obtained from the Google API Console.
        const clientId = opts.clientId; // The Client ID obtained from the Google API Console. Replace with your own Client ID.
        const appId = opts.appId; //  console.developers.google.com - 'Project number' under 'IAM & Admin' > 'Settings'

        const scope = ['https://www.googleapis.com/auth/drive.file'];

        var gdrivePickerAPILoaded = false;
        var oauthToken;

        // Use the Google API Loader script to load the google.picker script.
        function gdrivePickerLoad() {
          global.gapi.load('auth', {
            callback: function () {
              global.gapi.auth.authorize(
                {
                  client_id: clientId,
                  scope: scope,
                  immediate: false
                },
                function (authResult) {
                  if (authResult && !authResult.error) {
                    oauthToken = authResult.access_token;
                    gdrivePickerCreate();
                  }
                }
              );
            }
          });
          global.gapi.load('picker', {
            callback: function () {
              gdrivePickerAPILoaded = true;
              gdrivePickerCreate();
            }
          });
        }

        function gdrivePickerCreate() {
          if (gdrivePickerAPILoaded && oauthToken) {
            const view = new global.google.picker.View(
              global.google.picker.ViewId.DOCS_VIDEOS
            );
            const gdrivePicker = new global.google.picker.PickerBuilder()
              .setAppId(appId)
              .setOAuthToken(oauthToken)
              .setDeveloperKey(developerKey)
              .addView(view)
              .setCallback(gdriveCallback)
              .build();
            gdrivePicker.setVisible(true);

            global.gdrivePicker = gdrivePicker;
          }
        }

        function gdriveCallback(response) {
          if (
            response.action === global.google.picker.Action.PICKED &&
            response.docs &&
            response.docs[0]
          ) {
            const file = response.docs[0];

            const metadata = {
              source: 'Google Drive',
              url: `https://drive.google.com/u/0/uc?id=${file.id}&export=download`,
              id: file.id,
              name: file.name,
              size: file.sizeBytes,
              duration: file.duration,
              mimeType: file.mimeType
            };

            resolve(metadata);
          } else if (response.action === global.google.picker.Action.CANCEL) {
            resolve();
          }
        }

        gdrivePickerLoad();
      });

      return p;
    }
    global.gdrive = gdrive;

    filePickerMain();
</script>

  <!-- folder.api v2 -->
  <script type="module">
/*! folder-api browser bundle (single-file, no dependencies)
 *  Features: fetch/iframe/auto, recursion, size/date parsing, MIME (HEAD), hidden detection.
 *  Exposes global folderApiRequest and ESM export.
 *  License: MIT
 */
 'use strict';

  // -------- Utilities --------
  const ensureHttp = (url)=>{ const u=new URL(url); if(!/^https?:$/.test(u.protocol)) throw new Error('unsupported scheme'); u.pathname=u.pathname.replace(/\/+/g,'/'); if(!u.pathname.endsWith('/')) u.pathname+='/'; return u; };
  const keyForVisited = (u)=> `${u.protocol}//${u.host.toLowerCase()}${u.pathname}`;
  const parentDirectory = (u)=>{ const parts=u.pathname.split('/').filter(Boolean); if(!parts.length) return null; parts.pop(); return `${u.protocol}//${u.host}/${parts.join('/')}${parts.length?'/':''}`; };
  const rootDirectory = (u)=> `${u.protocol}//${u.host}/`;
  const hidden = (name)=> name.startsWith('.') && name!=='.' && name!=='..';
  const safeDecode = (seg, errors)=>{ try{return decodeURIComponent(seg);}catch{ errors.push(`decode: failed to decode segment '${seg}'`); return seg; } };
  const classify = (href, meta)=>{ if(href.endsWith('/')) return 'folder'; const last=href.split('/').filter(Boolean).pop()||''; if(/^[^.].*\.[^.]+$/.test(last)) return 'file'; if(/\b(dir|folder|directory)\b/i.test(meta)) return 'folder'; return 'file'; };
  const monthIdx = m=>['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'].indexOf(m.toLowerCase());
  function parseDate(text, errors){ let m=/^(\d{4})-(\d{2})-(\d{2})[ T](\d{2}):(\d{2})(?::(\d{2}))?/.exec(text); if(m){return new Date(Date.UTC(+m[1],+m[2]-1,+m[3],+m[4],+m[5],+(m[6]||0))).toISOString();} m=/(\d{2})-(\w{3})-(\d{4})\s(\d{2}):(\d{2})/.exec(text); if(m){ const mi=monthIdx(m[2]); if(mi>-1) return new Date(Date.UTC(+m[3],mi,+m[1],+m[4],+m[5],0)).toISOString(); } m=/(\d{1,2})\/(\d{1,2})\/(\d{4})\s(\d{1,2}):(\d{2})(?:\s?(AM|PM))/i.exec(text); if(m){ let H=+m[4]; const ap=m[6]; if(ap){ if(/am/i.test(ap)){ if(H===12)H=0;} else if(/pm/i.test(ap)){ if(H!==12)H+=12; }} return new Date(Date.UTC(+m[3],+m[1]-1,+m[2],H,+m[5],0)).toISOString(); } if(/\b\d{1,2}[-/]\d{1,2}[-/]\d{2,4}\b/.test(text)) errors.push('date: ambiguous numeric date pattern'); return null; }
  function parseSize(text){ const re=/(\d+(?:\.\d+)?)([KMGTP]?B?)/gi; const pow={ '':0,'B':0,'K':1,'KB':1,'M':2,'MB':2,'G':3,'GB':3,'T':4,'TB':4,'P':5,'PB':5 }; const tokens=[]; let m; while((m=re.exec(text))){ const raw=m[0]; const val=+m[1]; const unit=(m[2]||'').toUpperCase(); if(isNaN(val)||pow[unit]==null) continue; if(/^\d{4}$/.test(raw)){ const idx=m.index; const around=text.slice(Math.max(0,idx-5),Math.min(text.length,idx+6)); if(/[\d]{4}[-/]/.test(around)) continue; } const bytes = Math.floor(val*Math.pow(1024,pow[unit])); tokens.push({bytes,unit,raw,index:m.index}); } if(!tokens.length) return null; let withUnit=tokens.filter(t=>/[KMGTP]/.test(t.unit)); let cand=withUnit.length?withUnit:tokens.filter(t=>{ const before=text[t.index-1]||''; const after=text[t.index+t.raw.length]||''; if(': -'.includes(before)||': -'.includes(after)) return false; if(t.bytes<=60){ const slice=text.slice(Math.max(0,t.index-5),Math.min(text.length,t.index+8)); if(/\d{1,2}:\d{2}/.test(slice)) return false; } return true; }); if(!cand.length) cand=tokens; return cand.sort((a,b)=>b.bytes-a.bytes)[0].bytes; }
  const pushError=(errs,prefix,msg)=>errs.push(`${prefix}: ${msg}`);

  // -------- Fetch / Iframe loaders --------
  async function fetchHtml(url, opts, stats){ const controller=new AbortController(); const t=setTimeout(()=>controller.abort(),opts.timeoutMs); if(opts.signal){ if(opts.signal.aborted) controller.abort(); const on=()=>controller.abort(); opts.signal.addEventListener('abort',on,{once:true}); }
    try{ const res=await fetch(url,{redirect:'follow',signal:controller.signal}); stats.fetches++; if(res.status!==200) throw new Error('http '+res.status); const ct=res.headers.get('content-type')||''; if(!/text\/html/i.test(ct)) throw new Error('not html'); return await res.text(); } finally { clearTimeout(t);} }
  async function iframeHtml(url, opts, stats){ if(typeof document==='undefined') throw new Error('no DOM'); const iframe=document.createElement('iframe'); iframe.setAttribute('sandbox','allow-same-origin'); Object.assign(iframe.style,{position:'absolute',width:'0',height:'0',border:'0',visibility:'hidden'}); document.body.appendChild(iframe); stats.iframes++; return await new Promise((resolve,reject)=>{ const to=setTimeout(()=>{ cleanup(); reject(new Error('timeout')); },opts.timeoutMs); function cleanup(){ clearTimeout(to); iframe.remove(); } iframe.onload=()=>{ try{ const html=iframe.contentDocument?.documentElement?.outerHTML||''; cleanup(); resolve(html);}catch(e){ cleanup(); reject(e);} }; iframe.onerror=()=>{ cleanup(); reject(new Error('iframe error')); }; iframe.src=url; }); }

  // -------- Parsing directory listing --------
  function parseDirectory(baseUrl, html, opts){ const errors=[]; const doc=new DOMParser().parseFromString(html,'text/html'); const anchors=[]; for(const sel of ['pre a[href]','table a[href]','ul a[href]','ol a[href]']) anchors.push(...doc.querySelectorAll(sel)); if(!anchors.length) anchors.push(...doc.querySelectorAll('a[href]'));
    const seen=new Set(); const folders=[]; const files=[]; for(const a of anchors){ const hrefRaw=a.getAttribute('href'); if(!hrefRaw) continue; if(seen.has(hrefRaw)) continue; seen.add(hrefRaw); if(/^javascript:/i.test(hrefRaw)||/^mailto:/i.test(hrefRaw)||/#/.test(hrefRaw)) continue; const abs=new URL(hrefRaw,baseUrl); if(opts.sameOriginOnly && abs.origin!==new URL(baseUrl).origin) continue; const meta=deriveLineText(a); const kind=classify(abs.toString(),meta); const parts=abs.pathname.split('/').filter(Boolean); const segRaw=parts[parts.length-(abs.toString().endsWith('/')?1:1)]||''; const decoded=safeDecode(segRaw,errors); const isHidden=hidden(decoded); const date=parseDate(meta,errors); const size=parseSize(meta); if(kind==='folder'){ folders.push({ kind:'folder', url:abs.toString().endsWith('/')?abs.toString():abs.toString()+'/', rawName:segRaw, name:decoded, hidden:isHidden, size:null, date }); } else { files.push({ kind:'file', url:abs.toString(), rawName:segRaw, name:decoded, hidden:isHidden, size:size??null, date }); }
    }
    return { folders, files, errors }; }
  function deriveLineText(a){ const tr=a.closest('tr'); if(tr) return tr.textContent||''; const li=a.closest('li'); if(li) return li.textContent||''; const pre=a.closest('pre'); if(pre){ const lines=pre.textContent.split(/\n/); const t=a.textContent?.trim(); const line=lines.find(l=>t&&l.includes(t)); return line||a.textContent||''; } return a.parentElement?.textContent||a.textContent||''; }

  // -------- MIME enrichment --------
  async function enrichMime(files, opts, stats, errors){ if(!opts.includeMime||!files.length) return; const limit=Math.max(1,opts.headConcurrency); let active=0; const queue=[]; const run=async(fn)=>{ if(active>=limit) return await new Promise(r=>queue.push(()=>r(run(fn)))); active++; try{ await fn(); } finally { active--; const n=queue.shift(); if(n) n(); } };
    await Promise.all(files.map(f=>run(async()=>{ try{ const c=new AbortController(); const to=setTimeout(()=>c.abort(),opts.timeoutMs); const res=await fetch(f.url,{method:'HEAD',signal:c.signal}); stats.heads++; clearTimeout(to); if(res.ok){ if(!f.mime) f.mime=res.headers.get('content-type'); const len=res.headers.get('content-length'); if(len&&!f.size){ const n=+len; if(!isNaN(n)) f.size=n; } } else if(res.status===405||res.status===501){ pushError(errors,'mime','HEAD not supported'); } } catch{ pushError(errors,'mime',`failed HEAD for ${f.url}`); } })) ); }

  // -------- Traversal --------
  async function traverse(startUrl, opts, state){ const normalized=ensureHttp(startUrl).toString(); const u=new URL(normalized); const key=keyForVisited(u); if(state.visited.has(key)){ pushError(state.errors,'loop',`already visited ${normalized}`); return makeNode(normalized,u,0,'self'); } state.visited.add(key); const node=makeNode(normalized,u,0,'self'); state.allFolders.push(node); await loadDir(node,0); async function loadDir(cur,depth){ if(state.safety>50000){ pushError(state.errors,'limit','entry limit exceeded'); return; } let html=null; try{ if(opts.mode==='fetch'||opts.mode==='auto') html=await fetchHtml(cur.url,opts,state.stats); } catch(e){ if(opts.mode==='auto'){ html=await iframeHtml(cur.url,opts,state.stats); } else if(opts.mode==='iframe'){ html=await iframeHtml(cur.url,opts,state.stats); } else { throw e; } }
      if(html==null) throw new Error('failed to load directory'); const parsed=parseDirectory(cur.url,html,opts); parsed.errors.forEach(e=>state.errors.push(e)); const curUrl=new URL(cur.url); const root=rootDirectory(curUrl); const parent=parentDirectory(curUrl);
  for(const f of parsed.folders){ const fu=new URL(f.url); const depthFolder=folderDepth(curUrl,fu); const role= roleFor(f.url, normalized, root, parent); const fe={ kind:'folder', url:f.url, rawName:f.rawName, name:f.name, hidden:f.hidden, size:null, date:f.date, role, depth:depthFolder, children:[], files:[] }; if(role==='child') cur.children.push(fe); if(!state.allFolders.find(x=>x.url===fe.url && x.role===fe.role)) state.allFolders.push(fe); state.safety++; }
      for(const fi of parsed.files){ const file={ kind:'file', url:fi.url, rawName:fi.rawName, name:fi.name, hidden:fi.hidden, size:fi.size, date:fi.date }; cur.files.push(file); state.allFiles.push(file); state.safety++; }
      if(depth<opts.maxDepth){ for(const ch of cur.children){ const k=keyForVisited(new URL(ch.url)); if(state.visited.has(k)) continue; state.visited.add(k); await loadDir(ch,depth+1); } }
      state.maxDepth=Math.max(state.maxDepth,depth); }
    return node; }
  function makeNode(url,u,depth,role){ const seg=u.pathname.split('/').filter(Boolean).pop()||''; return { kind:'folder', url, rawName:seg, name:seg, hidden:hidden(seg), size:null, date:null, role, depth, children:[], files:[] }; }
  const folderDepth=(base,cand)=>{ const b=base.pathname.split('/').filter(Boolean); const c=cand.pathname.split('/').filter(Boolean); if(c.length<b.length) return 0; return c.length - b.length; };
  const roleFor=(url,start,root,parent)=>{ if(url===start) return 'self'; if(url===root) return 'root'; if(parent && url===parent) return 'parent'; return 'child'; };

  // -------- Option normalization --------
  const norm=(o={})=>({ maxDepth: Math.max(0,o.maxDepth||0), mode: o.mode||'auto', includeMime: !!o.includeMime, headConcurrency: Math.max(1,o.headConcurrency||6), timeoutMs: Math.max(100,o.timeoutMs||15000), sameOriginOnly: o.sameOriginOnly!==false, signal: o.signal });

  // -------- Public API --------
  export async function folderApiRequest(url, options){ const opts=norm(options||{}); const start= (typeof performance!=='undefined'&&performance.now)? performance.now(): Date.now(); const state={ visited:new Set(), allFolders:[], allFiles:[], errors:[], stats:{fetches:0,iframes:0,heads:0}, safety:0, maxDepth:0 }; const root=await traverse(url, opts, state); if(opts.includeMime) await enrichMime(state.allFiles, opts, state.stats, state.errors); const duration=((typeof performance!=='undefined'&&performance.now)? performance.now(): Date.now())-start; const entries=[...state.allFolders, ...state.allFiles]; return { url: root.url, root, folders: state.allFolders, files: state.allFiles, entries, generatedAt: new Date().toISOString(), errors: state.errors, stats:{ fetches: state.stats.fetches, iframes: state.stats.iframes, heads: state.stats.heads, durationMs: duration, maxDepth: state.maxDepth } }; }

  // Attach global for convenience in browsers when loaded via <script type="module">
  if (typeof globalThis !== 'undefined' && !globalThis.folderApiRequest) {
    globalThis.folderApiRequest = folderApiRequest;
  }
</script>

  <!-- App code -->
  <script type="module">
    const global = window;
    const $html = $('html');
    const $body = $('body');
    const $playerContainer = $('.player-container');
    const $progressBar = $('.progress-bar');
    const $player = $('.player');
    const $trick = $('.trick');
    const $fileinfo = $('.fileinfo');
    const $help = $('.help');
    const $settings = $('.settings');
    const $subtitles = $('.subtitle-selection');
    const $playlist = $('.playlist');
    const $currentTimestamp = $('.current-timestamp');

    const isDebug = () => !!(app && app.options && app.options.debug);
    const logInfo = (...args) => { if (isDebug()) console.info(...args); }

    const escapeHtml = (value) => {
      if (value === null || typeof value === 'undefined') return '';
      const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      };
      return String(value).replace(/[&<>"']/g, (c) => map[c]);
    }

    const escapeAttr = (value) => escapeHtml(value);

    const escapeCssUrl = (value) => {
      if (value === null || typeof value === 'undefined') return '';
      return String(value).replace(/\\/g, '\\\\').replace(/'/g, "\\'");
    }

    const setAriaPressed = (selector, pressed) => {
      const $el = $(selector);
      if ($el) $el.attr('aria-pressed', pressed ? 'true' : 'false');
    }

    const getSupportedTypes = () => {
      const supported = {
        extensions: [],
        mime: []
      };

      const types = [
        { mime: 'video/mp4',        extensions: ['mp4', 'm4v', 'mov', '3gp'] },
        { mime: 'video/webm',       extensions: ['webm'] },
        { mime: 'video/x-matroska', extensions: ['mkv'] },
        { mime: 'video/matroska',   extensions: ['mkv'] },
        { mime: 'video/mp2t',       extensions: ['ts', 'mp2'] },
        { mime: 'video/x-msvideo',  extensions: ['avi'] },
        { mime: 'video/msvideo',    extensions: ['avi'] },
        { mime: 'video/avi',        extensions: ['avi'] },
        { mime: 'video/vnd.avi',    extensions: ['avi'] },
        { mime: 'video/x-ms-wmv',   extensions: ['wmv'] },
        { mime: 'video/x-ms-asf',   extensions: ['wmv'] },
        { mime: 'video/x-flv',      extensions: ['flv'] },
        { mime: 'audio/wav',        extensions: ['wav'] },
        { mime: 'audio/mpeg',       extensions: ['mp3'] },
        { mime: 'audio/aac',        extensions: ['aac'] },
        { mime: 'audio/m4a',        extensions: ['m4a'] },
        { mime: 'audio/mp4',        extensions: ['m4a'] },
        { mime: 'audio/ogg',        extensions: ['ogg'] },
        { mime: 'audio/x-matroska', extensions: ['mka'] },
        { mime: 'audio/matroska',   extensions: ['mka'] }
      ];

      const v = document.createElement('video');
      types.forEach(type => {
        if (v.canPlayType(type.mime) !== '') {
          supported.extensions.push(...type.extensions);
          supported.mime.push(type.mime);
        }
      });

      return supported;
    }

    const isSupportedMimeType = (mime) => app.options.supportedTypes.mime.includes(mime);
    app.options.supportedTypes = getSupportedTypes();
    logInfo(`Supported mime-types: ${app.options.supportedTypes.mime.join(', ')}`);

    const hashState = { location: '', media: '' };
    app.playlist = [];
    app.playlistIndex = -1;
    app.playlistLoop = true;
    const playlistStorageKey = 'playlist-saved';
    const playlistSessionKey = 'playlist-session';

    const urlToFolder = (url) => {
      if (isFolder(url)) return url;

      var pieces = url.split('/'); // Break the URL into pieces
      pieces.pop(); // Remove the last piece (the filename)
      return pieces.join('/') + '/'; // Put it back together with a trailing /
    }

    const getParentFolder = (url) => {
      try {
        const base = urlToFolder(url);
        const parentUrl = new URL('../', base).toString();
        return (parentUrl === base ? undefined : parentUrl);
      } catch (e) {
        return undefined;
      }
    }

    const isFile = (url) => {
      const parsed = new URL(url);
      const finalPosition = parsed.pathname.lastIndexOf('/') + 1;
      const finalPart = parsed.pathname.substring(finalPosition);
      const isFile = hasPeriod(finalPart) || isUppercase(finalPart)
      return isFile;
    }
    const isUppercase = (s) => !!s.match(/^[A-Z]+$/);
    const hasPeriod = (s) => s.indexOf('.') >= 0;
    const isFolder = (url) => !isFile(url);

    const urlToFilename = (url) => {
      const re = /\/{1}([^\/]+\.[\w\d]{2,4})$/;
      const parts = re.exec(url);
      return (parts && parts.length > 1 ? parts[1] : url);
    }

    const urlToLabel = (url) => {
      if (!isString(url)) return;

      const fragments = url.split('/');

      const label = removeFileExtension(
        decodeURIComponent(
          fragments[fragments.length - 1]
        )
      );

      const prefixRe = /^(the|a)(\s|%20)/i;
      const hasPrefix = prefixRe.test(label);

      if (hasPrefix) {
        const prefix = prefixRe.exec(label);
        const length = prefix[1].length + prefix[2].length;
        return `${label.substring(length)}, ${prefix[1]}`;
      } else {
        return label;
      }
    }

    const urlType = (url) => {
      if (isHiddenFileOrFolder(url)) {
        return 'hidden';
      } else if (url[url.length - 1] === '/') {
        return 'folder';
      } else if (isMedia(url) || isSubtitle(url)) {
        return 'file';
      } else {
        return 'unknown';
      }
    }

    const removeFileExtension = (s) => {
      const supportedMediaExtensions = app.options.supportedTypes.extensions.join('|');
      const re = new RegExp(`\\.+(${supportedMediaExtensions})+$`, 'i');
      return s.replace(re, '');
    }

    const stripUrlExtension = (url) => {
      if (!isString(url)) return '';
      const clean = url.split('#')[0].split('?')[0];
      const match = /^(.*)(?:\.[^./]+)$/.exec(clean);
      return match ? match[1] : clean;
    }

    const sortFiles = (a, b) => {
      const labelA = urlToLabel(a.url);
      const labelB = urlToLabel(b.url);

      return labelA < labelB ? -1 : 1;
    }

    const isMedia = (haystack, fileExtensions) => {
      const supportedMediaExtensions = app.options.supportedTypes.extensions.join('|');
      const re = new RegExp(`\\.+(${supportedMediaExtensions})+$`, 'i');
      return re.test(haystack);
    };

    const isAudio = (url) => {
      const re = /(?:\/)((?:[^/])+\.(?:wav|mp3|aac|m4a|mka|ogg))/gi
      return re.test(url);
    }

    const isImage = (url) => {
      const re = /(?:\/)((?:[^/])+\.(?:png|jpeg|jpg|gif|webp))/gi
      return re.test(url);
    }

    const isHiddenFileOrFolder = (url) => {
      const reHidden = /\/\..+$/i;
      return url.toString().match(reHidden);
    }

    const linksHash = (links) => {
      var output = '';
      if (links.files && links.files.length > 0) {
        output += links.files.reduce((acc, link) => acc + link.url, '')
      }

      if (links.folders && links.folders.length > 0) {
        output += links.folders.reduce((acc, link) => acc + link.url, '')
      }

      return output;
    }

    const createLinks = async (url) => {
      const targetUrl = url || window.location.href;
      const folder = urlToFolder(targetUrl);
      const links = await folderApiRequest(folder);

      if (Array.isArray(links.folders)) {
        links.folders = links.folders.filter((item) => !(item && item.role === 'self'));
      }

      const parentUrl = getParentFolder(folder);
      if (parentUrl && Array.isArray(links.folders)) {
        const hasParent = links.folders.some((item) => (
          item &&
          (item.role === 'parent' || item.type === 'parent' || item.url === parentUrl || item.url === '../')
        ));
        if (!hasParent) {
          links.folders.unshift({ url: parentUrl, role: 'parent', name: 'Parent' });
        }
      }

      const oldLinksHash = linksHash(app.links);
      const newLinksHash = linksHash(links);

      app.links = links;

      // Only show the links if they have changed
      if (oldLinksHash !== newLinksHash) showLinks(links);
    }

    const showLinks = async (links) => {
      var html = '';
      const folders = links.folders;
      const files = links.files;
      const base = getBaseLocation(window.location);

      folders.forEach((folder) => {
        const rawUrl = folder.url;
        const url = decodeURI(rawUrl).replace(base, '');
        const label = url;
        const optClasses = ((folder.role || folder.type) === 'parent' ? 'parent' : '');

        html += createFolderTemplate(rawUrl, label, optClasses);
      });

      const removeUrlExtension = (url) => {
        const re = /^(.*)(?:\.\w+)$/i;
        const results = re.exec(url);

        if (!results || results.length === 0) return undefined;

        return results[1];
      }

      const findThumbnail = (mediaUrl, files) => {
        if (!Array.isArray(files)) return undefined;

        const mediaPrefix = removeUrlExtension(mediaUrl);

        const thumbnails = files.filter((file) => isImage(file.url));
        const thumb = thumbnails.find((file) => {
          const filePrefix = removeUrlExtension(file.url);
          return mediaPrefix === filePrefix;
        });
        return thumb;
      }

      const subtitles = files.filter((file) => isSubtitle(file.url));
      populateSubtitles(subtitles);

      const medias = files.filter((file) => isMedia(file.url));
      medias.sort(sortFiles);

      medias.forEach((file) => {
        const rawUrl = file.url;
        const url = decodeURI(rawUrl).replace(base, '');
        const label = urlToLabel(url);
        const cssClasses = [];

        const preRenderedThumbnail = findThumbnail(file.url, links.files);
        const preRenderedThumbnailAvailable = preRenderedThumbnail && preRenderedThumbnail.url;
        const thumbnailUrl = (preRenderedThumbnailAvailable ? preRenderedThumbnail.url : '');

        if (preRenderedThumbnailAvailable) cssClasses.push('prerendered');
        if (rawUrl === $player.src) cssClasses.push('current');

        html += createFileTemplate(rawUrl, label, cssClasses.join(' '), thumbnailUrl);
      });

      $('.links').innerHTML = html;

      const $links = [...document.querySelectorAll('.file, .folder')];
      $links.forEach((link) => $(link).on('click', clickLink));

      populateThumbnails();
    }

    const clickLink = (e) => {
      e.preventDefault();

      // Find `a.file` or `a.folder` element. `e.target` can be children too instead.
      const getTargetEl = (e) => {
        const anchors = [...e.composedPath()].filter((el) => el.nodeName === 'A');
        const $anchors = anchors.map((el) => $(el));
        const $fileOrFolder = $anchors.filter(($el) => ($el.hasClass('file') || $el.hasClass('folder')));

        return $fileOrFolder[0];
      }

      const $el = getTargetEl(e);
      if (!$el) return;

      const eventPath = (e.composedPath ? e.composedPath() : [e.target]);
      const addButtonClicked = eventPath.some((el) => el.classList && el.classList.contains('btn-add-to-playlist'));
      if (addButtonClicked && $el) {
        e.stopImmediatePropagation();
        if ($el.hasClass('file')) {
          addToPlaylist($el.href, isPlaybackStopped());
        } else if ($el.hasClass('folder')) {
          addFolderToPlaylist($el.href, { shouldPlay: isPlaybackStopped() });
        }
        return;
      }

      if ($el.hasClass('file')) setPlaylistFromUrl($el.href, true);
      if ($el.hasClass('folder')) {
        hashState.location = $el.href;
        clearThumbnailQueue();
        createLinks($el.href);
        updateHash({ push: true });
        return;
      }

      updateHash();
    }

    const createFileTemplate = (url, label, optionalClasses = '', preRenderedThumbnailUrl = '' ) => {
      const escapedUrl = escapeAttr(url);
      const safeLabel = escapeHtml(label);
      const safeTitle = escapeAttr(`Play ${url}`);
      const styleValue = preRenderedThumbnailUrl
        ? `--image-url-0: url('${escapeCssUrl(preRenderedThumbnailUrl)}')`
        : '';
      const safeStyle = escapeAttr(styleValue);
      const isAudioClass = (isAudio(url) ? 'audio-file' : '');

      return `<a href='${escapedUrl}' class='file ${isAudioClass} ${optionalClasses}' title='${safeTitle}' style='${safeStyle}' draggable='false'>
                <div class='title' draggable='false'>
                  <span class='label'>${safeLabel}</span>
                  <button class='btn-add-to-playlist' type='button' title='Add to playlist' aria-label='Add to playlist'>
                    <svg><use xlink:href='#svg-playlist-add'/></svg>
                  </button>
                </div>
                <div class='arrow' draggable='false'>
                  <svg><use xlink:href='#svg-play'/></svg>
                </div>
              </a>`;
    }

    const createFolderTemplate = (url, label, optionalClasses = '') => {
      const escapedUrl = escapeAttr(url);
      const safeLabel = escapeHtml(label);
      const safeTitle = escapeAttr(`Navigate to ${url}`);
      const isParent = optionalClasses.split(' ').includes('parent');
      const addButton = (isParent ? '' : `
                  <button class='btn-add-to-playlist' type='button' title='Add folder to playlist' aria-label='Add folder to playlist'>
                    <svg><use xlink:href='#svg-playlist-add'/></svg>
                  </button>`);

      return `<a href='${escapedUrl}' class='folder ${optionalClasses}' draggable='false' title='${safeTitle}'>
                <div class='title' draggable='false'>
                  <span class='folder-label'>
                    <svg class='icon'><use xlink:href='#svg-folder-arrow'/></svg>
                    <span class="label">${safeLabel}</span>
                  </span>
                  ${addButton}
                </div>
                <div class='arrow' draggable='false'>
                  <svg class='open'><use xlink:href='#svg-folder-open'/></svg>
                  <svg class='closed'><use xlink:href='#svg-folder-closed'/></svg>
                </div>
              </a>`;
    }

    const playlistItemFromUrl = (url) => {
      const label = urlToLabel(url);
      return { url, label: (label ? label : urlToFilename(url)) };
    }

    const updatePlaylistLoop = () => {
      if (app.playlistLoop) {
        $body.removeClass('playlist-loop-off');
      } else {
        $body.addClass('playlist-loop-off');
      }
      setAriaPressed('.btn-loop', app.playlistLoop);
    }

    const togglePlaylistLoop = () => {
      app.playlistLoop = !app.playlistLoop;
      updatePlaylistLoop();
    }

    const getPlaylistCurrentIndex = () => {
      if (!Array.isArray(app.playlist) || app.playlist.length === 0) return -1;
      if (
        app.playlistIndex >= 0 &&
        app.playlistIndex < app.playlist.length &&
        (!$player.src || app.playlist[app.playlistIndex].url === $player.src)
      ) {
        return app.playlistIndex;
      }
      if (!$player.src) return -1;
      return app.playlist.findIndex((item) => item.url === $player.src);
    }

    const syncPlaylistCurrent = () => {
      const index = getPlaylistCurrentIndex();
      app.playlistIndex = index;
      renderPlaylist();
    }

    const setPlaylistFromItem = (item, shouldPlay = true) => {
      if (!item || !item.url) return;
      app.playlist = [item];
      app.playlistIndex = 0;
      renderPlaylist();
      if (shouldPlay) actionPlay(item.url);
    }

    const setPlaylistFromUrl = (url, shouldPlay = true) => {
      if (!url) return;
      setPlaylistFromItem(playlistItemFromUrl(url), shouldPlay);
    }

    const setPlaylistFromUrls = (urls) => {
      app.playlist = (Array.isArray(urls) ? urls.map(playlistItemFromUrl) : []);
      app.playlistIndex = app.playlist.findIndex((item) => item.url === $player.src);
      renderPlaylist();
    }

    const getMediaUrlsFromLinks = (links) => {
      if (!links || !Array.isArray(links.files)) return [];
      const medias = links.files.filter((file) => isMedia(file.url));
      medias.sort(sortFiles);
      return medias.map((file) => file.url);
    }

    const isAbortError = (e) => {
      if (!e) return false;
      if (e.name === 'AbortError' || e.code === 20) return true;
      if (isString(e) && e.includes('BodyStreamBuffer was aborted')) return true;
      if (isString(e?.message) && e.message.includes('BodyStreamBuffer was aborted')) return true;
      return false;
    }

    const playlistFolderDepthDefault = 2;
    const normalizePlaylistFolderDepth = (value) => {
      const parsed = parseInt(value, 10);
      if (!Number.isFinite(parsed)) return playlistFolderDepthDefault;
      return Math.min(3, Math.max(1, Math.floor(parsed)));
    }
    const getPlaylistFolderDepth = () => normalizePlaylistFolderDepth(retrieveSetting('playlist-depth'));

    const subtitleOptionsConfig = ((app && app.options && app.options.subtitles) ? app.options.subtitles : {});

    const subtitleFontOptions = [
      { value: 'sans', label: 'Sans' },
      { value: 'serif', label: 'Serif' },
      { value: 'mono', label: 'Monospace' },
      { value: 'casual', label: 'Casual' }
    ];
    const subtitleSizeOptions = [
      { value: '90%', label: 'Small' },
      { value: '100%', label: 'Medium' },
      { value: '120%', label: 'Large' },
      { value: '140%', label: 'X-Large' }
    ];
    const subtitlePositionOptions = [
      { value: 'author', label: 'Author default' },
      { value: 90, label: 'Bottom' },
      { value: 75, label: 'Lower-middle' },
      { value: 60, label: 'Middle' },
      { value: 35, label: 'Upper-middle' },
      { value: 20, label: 'Top' }
    ];

    const subtitleFontValues = subtitleFontOptions.map((opt) => opt.value);
    const subtitleSizeValues = subtitleSizeOptions.map((opt) => opt.value);
    const subtitlePositionValues = subtitlePositionOptions
      .map((opt) => opt.value)
      .filter((value) => value !== 'author');

    const subtitleFontDefault = (() => {
      const normalized = String(subtitleOptionsConfig.font || '').toLowerCase();
      return (subtitleFontValues.includes(normalized) ? normalized : 'sans');
    })();
    const subtitleSizeDefault = (() => {
      const normalized = String(subtitleOptionsConfig.size || '').trim();
      return (subtitleSizeValues.includes(normalized) ? normalized : '100%');
    })();
    const subtitlePositionDefault = (() => {
      const normalized = String(subtitleOptionsConfig.position || '').toLowerCase();
      if (normalized === 'author') return 'author';
      const parsed = parseFloat(subtitleOptionsConfig.position);
      return (Number.isFinite(parsed) && subtitlePositionValues.includes(parsed) ? parsed : 'author');
    })();
    const subtitleColorDefault = (() => {
      const color = String(subtitleOptionsConfig.color || '').trim();
      if (/^#[0-9a-f]{6}$/i.test(color) || /^#[0-9a-f]{3}$/i.test(color)) return color;
      return '#ffffff';
    })();
    const subtitleBackgroundDefault = (() => {
      const color = String(subtitleOptionsConfig.background || '').trim();
      if (/^#[0-9a-f]{6}$/i.test(color) || /^#[0-9a-f]{3}$/i.test(color)) return color;
      return '#000000';
    })();

    const normalizeSubtitleFont = (value) => {
      const normalized = String(value || '').toLowerCase();
      return (subtitleFontValues.includes(normalized) ? normalized : subtitleFontDefault);
    }
    const normalizeSubtitleSize = (value) => {
      const normalized = String(value || '').trim();
      return (subtitleSizeValues.includes(normalized) ? normalized : subtitleSizeDefault);
    }
    const normalizeSubtitlePosition = (value) => {
      const normalized = String(value || '').toLowerCase();
      if (normalized === 'author') return 'author';
      const parsed = parseFloat(value);
      if (!Number.isFinite(parsed)) return subtitlePositionDefault;
      return (subtitlePositionValues.includes(parsed) ? parsed : subtitlePositionDefault);
    }
    const normalizeSubtitleColor = (value, fallback) => {
      const str = String(value || '').trim();
      if (/^#[0-9a-f]{6}$/i.test(str) || /^#[0-9a-f]{3}$/i.test(str)) return str;
      return fallback;
    }
    const subtitleFontToFamily = (value) => {
      switch (normalizeSubtitleFont(value)) {
        case 'serif':
          return "Georgia, 'Times New Roman', serif";
        case 'mono':
          return "'Courier New', Consolas, monospace";
        case 'casual':
          return "'Trebuchet MS', 'Segoe UI', Arial, sans-serif";
        default:
          return "system-ui, 'Segoe UI', Calibri, Arial, Helvetica, sans-serif";
      }
    }

    const addPlaylistItems = (urls, shouldPlay = false) => {
      if (!Array.isArray(urls)) return;
      const items = urls
        .filter((url) => isString(url) && url.length > 0)
        .map(playlistItemFromUrl)
        .filter((item) => item && item.url);
      if (items.length === 0) return;
      app.playlist.push(...items);
      if (shouldPlay) {
        actionPlay(items[0].url);
      } else {
        renderPlaylist();
      }
    }

    const isPlaybackStopped = () => (!$player.src || $player.src.length === 0 || $body.hasClass('is-stopped'));

    const addToPlaylist = (url, shouldPlay = false) => {
      if (!url) return;
      addPlaylistItems([url], shouldPlay);
    }

    const addFolderToPlaylist = async (url, opts = {}) => {
      if (!url) return;
      const shouldPlay = !!opts.shouldPlay;
      const depth = (Number.isFinite(opts.depth) ? opts.depth : getPlaylistFolderDepth());
      const maxDepth = Math.max(0, normalizePlaylistFolderDepth(depth) - 1);

      try {
        const links = await folderApiRequest(urlToFolder(url), { maxDepth });
        const urls = getMediaUrlsFromLinks(links);
        addPlaylistItems(urls, shouldPlay);
      } catch (e) {
        console.warn('Unable to add folder to playlist', e);
      }
    }

    const addCurrentFolderToPlaylist = () => {
      const depth = getPlaylistFolderDepth();
      if (depth <= 1) {
        const urls = getMediaUrlsFromLinks(app.links);
        addPlaylistItems(urls, isPlaybackStopped());
        return;
      }
      const baseUrl = (hashState.location && hashState.location.length > 0)
        ? hashState.location
        : window.location.href;
      addFolderToPlaylist(baseUrl, { shouldPlay: isPlaybackStopped(), depth });
    }

    const hasMultiPlaylist = () => Array.isArray(app.playlist) && app.playlist.length > 1;

    const updatePlaylistMultiState = () => {
      if (hasMultiPlaylist()) {
        $body.addClass('playlist-multiple');
      } else {
        $body.removeClass('playlist-multiple');
      }
    }

    const clearPlaylist = () => {
      app.playlist = [];
      app.playlistIndex = -1;
      renderPlaylist();
    }

    const playPlaylistIndex = (index) => {
      if (!Array.isArray(app.playlist) || app.playlist.length === 0) return;
      if (index < 0 || index >= app.playlist.length) return;
      app.playlistIndex = index;
      actionPlay(app.playlist[index].url);
      renderPlaylist();
    }

    const advancePlaylist = (reason) => {
      if (!Array.isArray(app.playlist) || app.playlist.length === 0) return;

      const currentIndex = getPlaylistCurrentIndex();
      if (currentIndex < 0) return;

      var nextIndex = currentIndex + 1;

      if (nextIndex >= app.playlist.length) {
        if (!app.playlistLoop) {
          if (reason === 'error') actionStop();
          return;
        }
        nextIndex = 0;
      }

      if (nextIndex === currentIndex) {
        if (reason === 'ended' && app.playlistLoop) {
          playPlaylistIndex(nextIndex);
        } else if (reason === 'error') {
          actionStop();
        }
        return;
      }

      playPlaylistIndex(nextIndex);
    }

    const playNextTrack = () => {
      if (!hasMultiPlaylist()) return;
      const currentIndex = getPlaylistCurrentIndex();
      if (currentIndex < 0) return;
      var nextIndex = currentIndex + 1;
      if (nextIndex >= app.playlist.length) {
        if (!app.playlistLoop) return;
        nextIndex = 0;
      }
      playPlaylistIndex(nextIndex);
    }

    const playPreviousTrack = () => {
      if (!hasMultiPlaylist()) return;
      const currentIndex = getPlaylistCurrentIndex();
      if (currentIndex < 0) return;
      var prevIndex = currentIndex - 1;
      if (prevIndex < 0) {
        if (!app.playlistLoop) return;
        prevIndex = app.playlist.length - 1;
      }
      playPlaylistIndex(prevIndex);
    }

    const removePlaylistItem = (index) => {
      if (!Array.isArray(app.playlist) || app.playlist.length === 0) return;
      if (index < 0 || index >= app.playlist.length) return;

      const wasCurrent = index === app.playlistIndex;
      app.playlist.splice(index, 1);

      if (app.playlist.length === 0) {
        app.playlistIndex = -1;
        actionStop();
        renderPlaylist();
        return;
      }

      if (wasCurrent) {
        const nextIndex = (index >= app.playlist.length ? 0 : index);
        app.playlistIndex = nextIndex;
        if (!app.playlistLoop && index >= app.playlist.length) {
          actionStop();
        } else {
          actionPlay(app.playlist[nextIndex].url);
        }
      } else if (index < app.playlistIndex) {
        app.playlistIndex -= 1;
      }

      renderPlaylist();
    }

    const swapPlaylistItems = (from, to) => {
      if (!Array.isArray(app.playlist) || app.playlist.length === 0) return;
      if (to < 0 || to >= app.playlist.length) return;

      const items = app.playlist;
      const swap = items[from];
      items[from] = items[to];
      items[to] = swap;

      if (app.playlistIndex === from) {
        app.playlistIndex = to;
      } else if (app.playlistIndex === to) {
        app.playlistIndex = from;
      }

      renderPlaylist();
    }

    const parseM3U = (text, baseUrl) => {
      if (!text) return [];
      const lines = text.split(/\r?\n/);
      const urls = [];

      lines.forEach((line) => {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith('#')) return;
        try {
          const resolved = new URL(trimmed, baseUrl).toString();
          urls.push(resolved);
        } catch (e) { }
      });

      return urls;
    }

    const importPlaylistFromUrl = async () => {
      const input = prompt('Enter an M3U URL');
      if (!input) return;

      var url;
      try {
        url = new URL(input, window.location.href).toString();
      } catch (e) {
        console.warn('Invalid playlist URL');
        return;
      }

      try {
        const res = await fetch(url);
        const text = await res.text();
        const urls = parseM3U(text, url);
        setPlaylistFromUrls(urls);
      } catch (e) {
        console.warn('Unable to import playlist', e);
      }
    }

    const importPlaylistFromFile = () => {
      const $input = $(`<input type="file" accept=".m3u,.m3u8,text/plain"/>`);
      $input.on('change', async () => {
        const file = $input.files[0];
        if (!file) return;
        const text = await file.text();
        const base = urlToFolder(window.location.href);
        const urls = parseM3U(text, base);
        setPlaylistFromUrls(urls);
      });
      $input.click();
    }

    const exportPlaylist = () => {
      if (!Array.isArray(app.playlist) || app.playlist.length === 0) return;
      const lines = ['#EXTM3U', ...app.playlist.map((item) => item.url)];
      const blob = new Blob([lines.join('\n')], { type: 'audio/x-mpegurl' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'playlist.m3u';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      setTimeout(() => URL.revokeObjectURL(url), 0);
    }

    const savePlaylistToStorage = () => {
      if (!Array.isArray(app.playlist) || app.playlist.length === 0) {
        storageRemove(playlistStorageKey);
        return;
      }
      const urls = app.playlist.map((item) => item.url);
      storageStore(playlistStorageKey, JSON.stringify(urls));
    }

    const savePlaylistToSession = () => {
      if (!Array.isArray(app.playlist) || app.playlist.length === 0) {
        sessionRemove(playlistSessionKey);
        return;
      }
      const urls = app.playlist.map((item) => item.url);
      const index = getPlaylistCurrentIndex();
      sessionStore(playlistSessionKey, JSON.stringify({ urls, index }));
    }

    const restorePlaylistFromSession = () => {
      const saved = sessionRetrieve(playlistSessionKey);
      if (!saved) return false;
      try {
        const payload = JSON.parse(saved);
        const urls = (payload && Array.isArray(payload.urls) ? payload.urls : []);
        const filtered = urls.filter((url) => isString(url));
        if (filtered.length === 0) return false;
        app.playlist = filtered.map(playlistItemFromUrl);
        const index = (Number.isFinite(payload.index) ? payload.index : -1);
        app.playlistIndex = (index >= 0 && index < app.playlist.length ? index : -1);
        renderPlaylist();
        return true;
      } catch (e) {
        console.warn('Unable to restore playlist from session', e);
        return false;
      }
    }

    const restorePlaylistFromStorage = () => {
      const saved = storageRetrieve(playlistStorageKey);
      if (!saved) return;
      try {
        const urls = JSON.parse(saved);
        if (!Array.isArray(urls)) return;
        const filtered = urls.filter((url) => isString(url));
        if (filtered.length === 0) return;
        setPlaylistFromUrls(filtered);
      } catch (e) {
        console.warn('Unable to restore playlist', e);
      }
    }

    const renderPlaylist = () => {
      if (!$playlist) return;
      const currentIndex = getPlaylistCurrentIndex();
      app.playlistIndex = currentIndex;
      updatePlaylistMultiState();
      savePlaylistToSession();

      var html = `
        <li class='modal-item playlist-controls'>
          <button class='btn-playlist-import-url' type='button' title='Import playlist from URL (requires CORS support)'>
            <svg><use xlink:href='#svg-import'/></svg>
            <span>Import URL</span>
          </button>
          <button class='btn-playlist-import-file' type='button' title='Import playlist file'>
            <svg><use xlink:href='#svg-import'/></svg>
            <span>Import File</span>
          </button>
          <button class='btn-playlist-restore' type='button' title='Restore playlist from localStorage'>
            <svg><use xlink:href='#svg-import'/></svg>
            <span>Restore</span>
          </button>
          <button class='btn-playlist-save' type='button' title='Save playlist to localStorage'>
            <svg><use xlink:href='#svg-save'/></svg>
            <span>Save</span>
          </button>
          <button class='btn-playlist-export' type='button' title='Export playlist'>
            <svg><use xlink:href='#svg-download'/></svg>
            <span>Export</span>
          </button>
          <button class='btn-playlist-add-folder' type='button' title='Add all files from current folder view'>
            <svg><use xlink:href='#svg-playlist-add'/></svg>
            <span>Add All</span>
          </button>
          <button class='btn-playlist-clear' type='button' title='Clear playlist'>Clear</button>
        </li>
      `;

      if (!Array.isArray(app.playlist) || app.playlist.length === 0) {
        html += `<li class='modal-item playlist-empty'>Playlist is empty</li>`;
      } else {
        app.playlist.forEach((item, index) => {
          const isCurrent = (index === currentIndex ? 'current' : '');
          const safeTitle = escapeAttr(item.url);
          const safeLabel = escapeHtml(item.label);
          html += `
            <li class='modal-item playlist-item ${isCurrent}' data-index='${index}' title='${safeTitle}'>
              <span class='playlist-label'>${safeLabel}</span>
              <span class='playlist-actions'>
                <button class='btn-playlist-up' type='button' title='Move up' aria-label='Move up'><svg><use xlink:href='#svg-caret-up'/></svg></button>
                <button class='btn-playlist-down' type='button' title='Move down' aria-label='Move down'><svg><use xlink:href='#svg-caret-down'/></svg></button>
                <button class='btn-playlist-remove' type='button' title='Remove from playlist' aria-label='Remove from playlist'><svg><use xlink:href='#svg-playlist-remove'/></svg></button>
              </span>
            </li>
          `;
        });
      }

      $playlist.html(html);

      const stopClose = (e) => e.stopImmediatePropagation();

      const importUrlButton = $playlist.querySelector('.btn-playlist-import-url');
      if (importUrlButton) {
        importUrlButton.addEventListener('click', (e) => {
          stopClose(e);
          importPlaylistFromUrl();
        });
      }

      const importFileButton = $playlist.querySelector('.btn-playlist-import-file');
      if (importFileButton) {
        importFileButton.addEventListener('click', (e) => {
          stopClose(e);
          importPlaylistFromFile();
        });
      }

      const exportButton = $playlist.querySelector('.btn-playlist-export');
      if (exportButton) {
        exportButton.addEventListener('click', (e) => {
          stopClose(e);
          exportPlaylist();
        });
      }

      const addFolderButton = $playlist.querySelector('.btn-playlist-add-folder');
      if (addFolderButton) {
        addFolderButton.addEventListener('click', (e) => {
          stopClose(e);
          addCurrentFolderToPlaylist();
        });
      }

      const restoreButton = $playlist.querySelector('.btn-playlist-restore');
      if (restoreButton) {
        restoreButton.addEventListener('click', (e) => {
          stopClose(e);
          restorePlaylistFromStorage();
        });
      }

      const saveButton = $playlist.querySelector('.btn-playlist-save');
      if (saveButton) {
        saveButton.addEventListener('click', (e) => {
          stopClose(e);
          savePlaylistToStorage();
        });
      }

      const clearButton = $playlist.querySelector('.btn-playlist-clear');
      if (clearButton) {
        clearButton.addEventListener('click', (e) => {
          stopClose(e);
          clearPlaylist();
        });
      }

      const items = [...$playlist.querySelectorAll('.playlist-item')];
      items.forEach((item) => {
        item.addEventListener('click', (e) => {
          stopClose(e);
          const index = parseInt(item.dataset.index, 10);
          playPlaylistIndex(index);
        });

        const up = item.querySelector('.btn-playlist-up');
        if (up) up.addEventListener('click', (e) => {
          stopClose(e);
          const index = parseInt(item.dataset.index, 10);
          swapPlaylistItems(index, index - 1);
        });

        const down = item.querySelector('.btn-playlist-down');
        if (down) down.addEventListener('click', (e) => {
          stopClose(e);
          const index = parseInt(item.dataset.index, 10);
          swapPlaylistItems(index, index + 1);
        });

        const remove = item.querySelector('.btn-playlist-remove');
        if (remove) remove.addEventListener('click', (e) => {
          stopClose(e);
          const index = parseInt(item.dataset.index, 10);
          removePlaylistItem(index);
        });
      });
    }

    var audioThumbnailQueue = [];
    var videoThumbnailQueue = [];
    var audioThumbnailProcessing = false;
    var videoThumbnailProcessing = false;
    var thumbnailObserver;
    const populateThumbnails = async () => {
      if (retrieveSetting('thumbnailing') === false) return;
      const $files = [...document.querySelectorAll('.file')];
      setupThumbnailObserver($files);
    }

    const enqueueThumbnail = ($file) => {
      if (!$file) return;
      if ($file.dataset.thumbnailQueued === 'true' || $file.dataset.thumbnailDone === 'true') return;
      if (hasPreRenderedThumbnail($file)) {
        $file.dataset.thumbnailDone = 'true';
        return;
      }

      $file.dataset.thumbnailQueued = 'true';
      if (isAudio($file.href)) {
        audioThumbnailQueue.push({$file, url: $file.href});
      } else {
        videoThumbnailQueue.push({$file, url: $file.href});
      }
      processThumbnailQueue();
    }

    const processThumbnailQueue = () => {
      processVideoThumbnailQueue();
      processAudioThumbnailQueue();
    }

    const processVideoThumbnailQueue = async () => {
      if (videoThumbnailProcessing) return;
      videoThumbnailProcessing = true;
      const concurrency = Math.max(1, app.options.thumbnails.concurrency || 1);

      while (videoThumbnailQueue.length > 0) {
        const batch = videoThumbnailQueue.splice(0, concurrency);
        await Promise.all(batch.map(async (work) => {
          await setThumbnail(work.$file, work.url);
          work.$file.dataset.thumbnailDone = 'true';
        }));
      }

      videoThumbnailProcessing = false;
    }

    const processAudioThumbnailQueue = async () => {
      if (audioThumbnailProcessing) return;
      audioThumbnailProcessing = true;
      const audioOpts = app.options.audioThumbnails || {};
      const concurrency = Math.max(1, audioOpts.concurrency || 1);

      while (audioThumbnailQueue.length > 0) {
        const batch = audioThumbnailQueue.splice(0, concurrency);
        await Promise.all(batch.map(async (work) => {
          await setThumbnail(work.$file, work.url);
          work.$file.dataset.thumbnailDone = 'true';
        }));
      }

      audioThumbnailProcessing = false;
    }

    const setupThumbnailObserver = ($files) => {
      if (thumbnailObserver) thumbnailObserver.disconnect();

      if (!('IntersectionObserver' in window)) {
        $files.forEach(enqueueThumbnail);
        return;
      }

      thumbnailObserver = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (!entry.isIntersecting && entry.intersectionRatio === 0) return;
          const $file = entry.target;
          if (thumbnailObserver) thumbnailObserver.unobserve($file);
          enqueueThumbnail($file);
        });
      }, { root: null, rootMargin: '200px 0px', threshold: 0.1 });

      $files.forEach(($file) => {
        if ($file.dataset.thumbnailQueued === 'true' || $file.dataset.thumbnailDone === 'true') return;
        if (hasPreRenderedThumbnail($file)) {
          $file.dataset.thumbnailDone = 'true';
          return;
        }
        thumbnailObserver.observe($file);
      });
    }

    const clearThumbnailQueue = () => {
      audioThumbnailQueue = [];
      videoThumbnailQueue = [];
      if (thumbnailObserver) thumbnailObserver.disconnect();
    }

    const getMediaDuration = () => {
      const duration = $player.duration;
      if (Number.isFinite(duration)) return duration;
      if ($player.seekable && $player.seekable.length > 0) {
        return $player.seekable.end($player.seekable.length - 1);
      }
      return 0;
    }

    const getRelativePosition = () => $player.currentTime / getMediaDuration() || 0;
    const getProgressBarWidth = () => $progressBar.offsetWidth;
    const updateProgressBarAria = () => {
      const duration = getMediaDuration();
      const current = (Number.isFinite($player.currentTime) ? $player.currentTime : 0);
      const max = (duration && Number.isFinite(duration) ? duration : 0);
      $progressBar.attr('aria-valuemin', '0');
      $progressBar.attr('aria-valuemax', `${Math.floor(max)}`);
      $progressBar.attr('aria-valuenow', `${Math.floor(current)}`);
      $progressBar.attr('aria-valuetext', `${secondsToString(current)} of ${secondsToString(max)}`);
      $progressBar.attr('aria-disabled', max > 0 ? 'false' : 'true');
    }

    const getState = () => {
      const location = hashState.location;
      const media = getMediaUrl();
      const time = $player.currentTime;
      const state = { location, media, time }

      return state;
    }

    const getBaseLocation = (l) => l.protocol + '//' + l.host;
    const getMediaUrl = () => $player.src;

    const encodeHash = (hash) => encodeURIComponent(base64EncodeUTF(JSON.stringify(hash)));
    const decodeHash = (hash) => JSON.parse(base64DecodeUTF(decodeURIComponent(hash)));
    const getHash = () => {
      const urlHash = window.location.hash.substr(1);

      var hash = {};
      try {
        hash = decodeHash(urlHash);
      } catch (e) { }

      return hash;
    }

    const updateHash = (opts = {}) => {
      var url = new URL(location);
      url.hash = encodeHash(getState());
      if (opts.push) {
        history.pushState(null, document.title, url);
      } else {
        history.replaceState(null, document.title, url);
      }
    }

    const updateTitle = () => {
      const prefix = `player.html`
      const url = $player.src;

      if (!url) return document.title = prefix;

      const name = urlToLabel(url);
      const time = secondsToString($player.currentTime);
      const title = `${prefix} - ${name} (${time})`;

      return document.title = title;
    }

    const updateVersionNumber = () => {
      const version = document.querySelector('meta[name="version"]').getAttribute('content');
      const els = [...document.querySelectorAll('.version')];
      els.forEach((el) => el.innerText = `v${version}`);
    }

    const openFromCloud = (cloud) => {
      return async () => {
        var metadata;

        switch (cloud) {
          case 'onedrive':
            metadata = await onedrive();
            break;
          case 'gdrive':
            metadata = await gdrive();
            break;
        }

        if (!metadata || !metadata.url) return;
        const label = (metadata.name ? removeFileExtension(metadata.name) : urlToLabel(metadata.url));
        const item = { url: metadata.url, label: (label ? label : urlToFilename(metadata.url)) };
        return setPlaylistFromItem(item, true);
      }
    }

    const actionPasteAndPlay = (e) => {
      e.preventDefault();

      const re = /^https?:\/\//i;
      const clipboard = e.clipboardData.getData('text');

      if (clipboard && re.test(clipboard)) {
        const url = clipboard;
        logInfo(`Playing media from clipboard: ${clipboard}`);
        setPlaylistFromUrl(url, true);
      }
    }

    const resetPlayer = () => {
      resetFileinfo();
      clearSubtitles();
      resetAutoSubtitleState();
      updatePlaybackState('stop');
      $player.playbackRate = 1;
      $player.onerror = undefined;
      updatePlaybackRate();
      updateProgress();
    }

    const updatePlaybackState = (state) => {
      const states = {
        play: 'is-playing',
        pause: 'is-paused',
        stop: 'is-stopped'
      }

      const $el = $('body');

      Object.keys(states).forEach((key) => {
        if (state === key) {
          if (!$el.hasClass(states[key])) {
            $el.addClass(states[key]);
          }
        } else {
          $el.removeClass(states[key]);
        }
      });

      setAriaPressed('.btn-play-pause', state === 'play');
      if (state === 'stop') resetPlayerBackground();
    }

    const getRanges = () => {
      if ($player.buffered.length === 0) return [];

      var ranges = [];
        for (let i = 0; i < $player.buffered.length; i++) {
          const start = $player.buffered.start(i);
          const end   = $player.buffered.end(i);
          ranges.push({start, end})
        }
        return ranges;
    }

    const updateRanges = () => {
      const ranges = getRanges();
      const transparentGradient = 'linear-gradient(to right, transparent, transparent)';
      const gradient = (ranges.length > 0 ? rangesToGradient(ranges, $player.duration) : transparentGradient);

      // Only set if the gradient is different
      if ($progressBar.dataset.gradient !== gradient){
        $progressBar.dataset.gradient = gradient;
        $progressBar.style.backgroundImage = gradient;
      }
    }

    const rangesToGradient = (ranges, duration) => {
      const color = 'var(--progress-bar-buffer-color)';

      const gradient = ranges.reduce((acc, range) => {
        const relativeStart = `${(range.start / duration) * 100}%`;
        const relativeEnd   = `${(range.end   / duration) * 100}%`;

        return acc + `, transparent ${relativeStart}, ${color} ${relativeStart}, ${color} ${relativeEnd}, transparent ${relativeEnd}`;
      }, 'linear-gradient(to right') + ')';

      return gradient;
    }

    const actionPlay = (url) => {
      // Don't restart playback if it is the currently playing media
      if (url === $player.currentSrc && $player.src.length > 0) return;

      resetPlayer();

      // Being playback if there is a URL
      if (!!url) {
        logInfo(`Loading media: ${url}`);
        $player.autoplay = true;

        $player.once('error', () => {
          console.warn(`Unable to begin playback: ${url}`);
          advancePlaylist('error');
        });
        $player.once('play', () => logInfo(`Playback started: ${url}`));
        $player.once('loadedmetadata', () => updateDuration($player.duration));
        $player.src = $trick.src = hashState.media = url;
        $player.load();
        $body.addClass('is-loaded');

        $player.once('loadedmetadata', () => {
          if ($player.videoWidth === 0 && $player.videoHeight === 0) {
            $body.addClass('is-audio');
            if (!$player.paused) schedulePlayerArtworkBackground(url);
          } else {
            $body.removeClass('is-audio');
            resetPlayerBackground();
          }
        });

        document.querySelector('.media-title').innerText = urlToLabel(url);

        const scrollOpts = {
          behavior: 'smooth',
          block: 'center'
        }
        setTimeout(() => $player.scrollIntoView(scrollOpts), 16);

      } else { // Reset the player if no URL supplied
        updateDuration(0);

        unloadMediaSrc($player);
        unloadMediaSrc($trick);

        hashState.media = undefined;
        $body.removeClass('is-loaded');

        resetPlayerBackground();
        logInfo(`Playback stopped`);
      }

      syncPlaylistCurrent();
      setCurrentMediaTile();
    }

    const checkFileHandlerOpen = () => {
      if ('launchQueue' in window) {
        window.launchQueue.setConsumer(async (launchParams) => {
          if (launchParams.files.length > 0) {
            const fileHandle = launchParams.files[0];
            const file = await fileHandle.getFile();
            const url = URL.createObjectURL(file);

            const label = (file.name ? removeFileExtension(file.name) : urlToLabel(url));
            setPlaylistFromItem({ url, label: (label ? label : urlToFilename(url)) }, true);
          }
        });
      }
    };

    const unloadMediaSrc = (el) => {
      el.removeAttribute('src'); // Unset video, use `removeAttribute` instead of `src = undefined` to prevent 404s for `/video-thumbnail.js/src/undefined`
      el.load(); // Must invoke `load` to complete the `src` change
    }

    const subtitleDurationCache = new Map();
    const autoPositionedSubtitleCues = new WeakSet();
    let autoSubtitleAttemptedFor = '';
    let autoSubtitlePlaybackStartedFor = '';

    const getAutoSubtitleDefault = () => {
      if (app && app.options && app.options.subtitles && typeof app.options.subtitles.autoMatch !== 'undefined') {
        return app.options.subtitles.autoMatch;
      }
      return false;
    }

    const shouldAutoLoadMatchingSubtitles = () => {
      const stored = retrieveSetting('auto-subtitles');
      if (typeof stored !== 'undefined') return stored;
      return getAutoSubtitleDefault();
    }

    const isSubtitleTrackKind = (kind) => kind === 'subtitles' || kind === 'captions';

    const getSubtitlePositionPreference = () => {
      return normalizeSubtitlePosition(retrieveSetting('subtitle-position'));
    }

    const applySubtitleStyleSettings = () => {
      const font = normalizeSubtitleFont(retrieveSetting('subtitle-font'));
      const size = normalizeSubtitleSize(retrieveSetting('subtitle-size'));
      const color = normalizeSubtitleColor(retrieveSetting('subtitle-color'), subtitleColorDefault);
      const background = normalizeSubtitleColor(retrieveSetting('subtitle-background'), subtitleBackgroundDefault);

      setCSSVariableNumber('--subtitle-font-family', subtitleFontToFamily(font), $html);
      setCSSVariableNumber('--subtitle-font-size', size, $html);
      setCSSVariableNumber('--subtitle-color', color, $html);
      setCSSVariableNumber('--subtitle-background-color', background, $html);
    }

    const applySubtitlePositionToCue = (cue, preferredLine) => {
      if (!cue || typeof cue.line === 'undefined') return;

      if (preferredLine === 'author') {
        if (autoPositionedSubtitleCues.has(cue)) {
          try {
            cue.line = 'auto';
            cue.snapToLines = true;
          } catch (e) {}
          autoPositionedSubtitleCues.delete(cue);
        }
        return;
      }

      const hasAuthorPosition = (cue.line !== 'auto' && !autoPositionedSubtitleCues.has(cue));
      if (hasAuthorPosition) return;

      try {
        cue.snapToLines = false;
        cue.line = preferredLine;
        autoPositionedSubtitleCues.add(cue);
      } catch (e) {}
    }

    const applySubtitlePositionToTrack = (textTrack, preferredLine) => {
      if (!textTrack || !isSubtitleTrackKind(textTrack.kind)) return;
      const cues = textTrack.cues;
      if (!cues || !cues.length) return;
      for (let i = 0; i < cues.length; i++) {
        applySubtitlePositionToCue(cues[i], preferredLine);
      }
    }

    const applySubtitlePositionPreference = () => {
      const textTracks = $player ? $player.textTracks : null;
      if (!textTracks || !textTracks.length) return;
      const preferredLine = getSubtitlePositionPreference();
      for (let i = 0; i < textTracks.length; i++) {
        applySubtitlePositionToTrack(textTracks[i], preferredLine);
      }
    }

    const resetAutoSubtitleState = () => {
      autoSubtitleAttemptedFor = '';
      autoSubtitlePlaybackStartedFor = '';
    }

    const markAutoSubtitlePlaybackStarted = () => {
      const mediaUrl = $player.currentSrc || $player.src;
      if (mediaUrl) autoSubtitlePlaybackStartedFor = mediaUrl;
    }

    const getMatchingSubtitleUrl = (mediaUrl) => {
      if (!mediaUrl || !Array.isArray(app.links.files)) return null;
      if (isAudio(mediaUrl)) return null;
      const mediaBase = stripUrlExtension(mediaUrl);
      if (!mediaBase) return null;

      const candidates = app.links.files.filter((file) => file && file.url && isSubtitle(file.url));
      const matches = candidates.filter((file) => stripUrlExtension(file.url) === mediaBase);
      if (!matches.length) return null;

      const vtt = matches.find((file) => file.url && file.url.toLowerCase().endsWith('.vtt'));
      return (vtt || matches[0]).url;
    }

    const maybeAutoLoadSubtitles = () => {
      if (!shouldAutoLoadMatchingSubtitles()) return;

      const mediaUrl = $player.currentSrc || $player.src;
      if (!mediaUrl) return;
      if (autoSubtitlePlaybackStartedFor !== mediaUrl) return;
      if (!Array.isArray(app.links.files)) return;
      if (autoSubtitleAttemptedFor === mediaUrl) return;

      autoSubtitleAttemptedFor = mediaUrl;

      if (hasSubtitleTracks()) return;

      const subtitleUrl = getMatchingSubtitleUrl(mediaUrl);
      if (!subtitleUrl) return;

      loadSubtitle(subtitleUrl);
    }

    const hasSubtitleTracks = () => {
      const trackElements = $player ? $player.querySelectorAll('track') : null;
      if (trackElements && trackElements.length > 0) return true;

      const textTracks = $player ? $player.textTracks : null;
      if (!textTracks || !textTracks.length) return false;
      for (let i = 0; i < textTracks.length; i++) {
        const kind = textTracks[i].kind;
        if (isSubtitleTrackKind(kind)) return true;
      }
      return false;
    }

    const createDisableSubtitlesItem = () => {
      const $toggle = $(`<li class='subtitle-item modal-item disable-subtitles'>Turn off subtitles</li>`);
      $toggle.on('click', (e) => {
        e.preventDefault();
        clearSubtitles();
      });
      return $toggle;
    }

    const updateSubtitleToggleVisibility = () => {
      if (!$subtitles) return;
      const hasTracks = hasSubtitleTracks();
      const existing = $subtitles.querySelector('.disable-subtitles');
      const settingsStart = $subtitles.querySelector('.subtitle-settings-heading, .subtitle-setting-item');
      if (hasTracks) {
        if (!existing) {
          const $toggle = createDisableSubtitlesItem();
          if (settingsStart) {
            $subtitles.insertBefore($toggle, settingsStart);
          } else {
            $subtitles.append($toggle);
          }
        } else if (settingsStart) {
          $subtitles.insertBefore(existing, settingsStart);
        }
      } else if (existing) {
        $(existing).remove();
      }
    }

    const disableAllTextTracks = () => {
      const textTracks = $player ? $player.textTracks : null;
      if (!textTracks || !textTracks.length) return;
      for (let i = 0; i < textTracks.length; i++) {
        const kind = textTracks[i].kind;
        if (isSubtitleTrackKind(kind)) {
          textTracks[i].mode = 'disabled';
        }
      }
    }

    const enableLatestSubtitleTrack = () => {
      const textTracks = $player ? $player.textTracks : null;
      if (!textTracks || !textTracks.length) return false;
      let lastIndex = -1;
      for (let i = 0; i < textTracks.length; i++) {
        const kind = textTracks[i].kind;
        if (isSubtitleTrackKind(kind)) lastIndex = i;
      }
      if (lastIndex < 0) return false;
      for (let i = 0; i < textTracks.length; i++) {
        const kind = textTracks[i].kind;
        if (isSubtitleTrackKind(kind)) {
          textTracks[i].mode = (i === lastIndex ? 'showing' : 'disabled');
        }
      }
      return true;
    }

    const ensureSubtitleTrackEnabled = () => {
      if (enableLatestSubtitleTrack()) return;
      setTimeout(() => enableLatestSubtitleTrack(), 0);
    }

    const getSubtitleDurationCached = async (url) => {
      const cached = subtitleDurationCache.get(url);
      if (typeof cached === 'number') return cached;
      if (cached && typeof cached.then === 'function') return cached;

      const promise = getSubtitleDuration(url)
        .then((duration) => {
          subtitleDurationCache.set(url, duration);
          return duration;
        })
        .catch((e) => {
          console.warn('Unable to read subtitle duration', e);
          subtitleDurationCache.delete(url);
          return 0;
        });

      subtitleDurationCache.set(url, promise);
      return promise;
    }

    const updateSubtitleDurations = () => {
      const items = [...$subtitles.querySelectorAll('li[data-subtitle-url]')];
      items.forEach(async (li) => {
        const $li = $(li);
        if ($li.hasClass('disable-subtitles')) return;
        if (li.dataset.subtitleDurationReady === 'true') return;
        const url = li.dataset.subtitleUrl;
        if (!url) return;
        const duration = await getSubtitleDurationCached(url);
        const name = li.dataset.subtitleName ? decodeURIComponent(li.dataset.subtitleName) : li.textContent;
        li.textContent = `${name} (${secondsToString(duration)})`;
        li.dataset.subtitleDurationReady = 'true';
      });
    }

    const populateSubtitles = async (subtitles) => {
      var html = '';

      if (subtitles.length === 0) {
        $body.addClass('no-subtitles');
        html = `<li class='subtitle-item modal-item'>No subtitles found in current folder</li>`;
      } else {
        $body.removeClass('no-subtitles');

        for (let i = 0; i < subtitles.length; i++) {
          const url = subtitles[i].url;
          const name = decodeURIComponent(urlToFilename(url));
          const safeUrl = escapeAttr(url);
          const safeName = escapeHtml(name);
          const encodedName = encodeURIComponent(name);
          html += `<li class='subtitle-item modal-item' data-subtitle-url='${safeUrl}' data-subtitle-name='${encodedName}' title='${safeUrl}'>${safeName}</li>`
        }
      }

      $subtitles.html(html);

      const list = [...$subtitles.querySelectorAll('li[data-subtitle-url]')];
      list.forEach((li) => {
        const $li = $(li);
        $li.on('click', (e) => {
          e.preventDefault();

          loadSubtitle(li.dataset.subtitleUrl);
        });
      })

      renderSubtitleSettingsControls();
      updateSubtitleToggleVisibility();
      maybeAutoLoadSubtitles();
    }

    const loadSubtitle = async (url) => {
      clearSubtitles();

      if (isSRT(url)) {
        url = await srtToVtt(url);
      } else {
        url = await urlToObjectUrl(url, 'text/vtt');
      }

      getSubtitleDurationCached(url);

      const $track = $(`<track src='${url}' label='${url}' default>`);
      $track.on('load', applySubtitlePositionPreference);
      $player.append($track);
      ensureSubtitleTrackEnabled();
      applySubtitlePositionPreference();
      setTimeout(applySubtitlePositionPreference, 0);
      updateSubtitleToggleVisibility();
      setAriaPressed('.btn-subtitles', true);
    }

    const clearSubtitles = () => {
      disableAllTextTracks();
      const tracks = [...document.querySelectorAll('track')];

      if (tracks) {
        tracks.forEach((track) => {
          if (track.track && isSubtitleTrackKind(track.track.kind)) {
            track.track.mode = 'disabled';
          }
          $(track).remove();
        });
      }
      updateSubtitleToggleVisibility();
      setAriaPressed('.btn-subtitles', false);
    }

    const isSubtitle = (url) => url.toString().endsWith('.vtt') || url.toString().endsWith('.srt');

    const isSRT = (url) => {
      try {
        return url.endsWith('.srt');
      } catch (e) {
        return false;
      }
    }

    const srtToVtt = async (url) => {
      const re = /(\d{2}:\d{2}:\d{2}),(\d{3})/g;

      const srt = await fetch(url);
      const text = await srt.text();
      const converted = `WEBVTT\r\n\r\n${text.replace(re, "$1.$2")}`;

      const blob = new Blob([converted], {type: 'text/vtt'})
      return URL.createObjectURL(blob);
    }

    const getSubtitleDuration = async (url) => {
      const f = await fetch(url);
      const text = await f.text();

      const re = /(\d{2}):(\d{2}):(\d{2})[.,](\d{3})/g;
      let lastMatch;
      let match;

      while ((match = re.exec(text)) !== null) {
        lastMatch = match;
      }

      if (lastMatch) {
        const h = parseInt(lastMatch[1], 10);
        const m = parseInt(lastMatch[2], 10);
        const s = parseInt(lastMatch[3], 10);
        const ms = parseInt(lastMatch[4], 10);

        const seconds = h * 3600 + m * 60 + s + ms / 1000;
        return seconds;
      }

      return 0;
    }

    const urlToObjectUrl = async (url, type) => {
      const srt = await fetch(url);
      const blob = await srt.blob();

      if (type) {
        return URL.createObjectURL(blob.slice(0, blob.size, type));
      } else {
        return URL.createObjectURL(blob);
      }

    }

    const setCurrentMediaTile = () => {
      const $former = $('.links .current')
      if ($former && $former.classList) $former.classList.remove('current');

      const $current = $(`.file[href='${$player.src}']`);
      if ($current && $current.classList) $current.classList.add('current');
    }

    const actionPlayPause = () => {
      if ($player.src && $player.paused) {
        $player.play();
        updatePlaybackState('play');
      } else if (!$player.src) {
        updatePlaybackState('stop');
      } else {
        $player.pause();
        updatePlaybackState('pause');
      }
    }

    const actionVolume = () => {
      let volume = +$player.dataset.volume;
      if (volume === 3) {
        volume = 0;
      } else {
        volume += 1;
      }
      $player.dataset.volume = volume;

      const maxVolumeStep = 3;
      const uiValue = (volume === 0 ? 0 : (volume / maxVolumeStep)); // 0..1
      const exponent = (typeof app.options.volumeExponent === 'number' ? app.options.volumeExponent : 1.8);
      $player.volume = (uiValue === 0 ? 0 : Math.pow(uiValue, exponent));
    }

    const updateVolume = () => {
      const $el = $('.primary-buttons');
      const levelPrefix = 'volume-';
      const levels = [0, 1, 2, 3];
      const currentLevel = +$player.dataset.volume;

      $player.muted = (currentLevel === 0);

      // Clear the existing level setting
      levels.forEach((level) => $el.removeClass(`${levelPrefix}${level}`));

      // Apply the new level setting
      $el.addClass(`${levelPrefix}${currentLevel}`);
    }

    const actionPlaybackRate = () => {
      const playbackRate = +$player.playbackRate;
      $player.playbackRate = (playbackRate >= 2 ? 0 : playbackRate + 0.25);
    }

    const updatePlaybackRate = () => {
      setCSSVariableString('--playback-rate', $player.playbackRate.toFixed(2), $('.btn-playback-rate'));

      const skipDuration = Math.abs(getSkipDuration());
      const replayDuration = Math.abs(getReplayDuration());
      const forwardTitle = (skipDuration > 1 ? `${skipDuration} seconds` : `1 frame`);
      const rewindTitle = (replayDuration > 1 ? `${replayDuration} seconds` : `1 frame`);
      $('.btn-fast-forward').title = `Go forward ${forwardTitle} [Right Arrow]`;
      $('.btn-rewind').title       = `Go back ${rewindTitle} [Left Arrow]`;
    }

    const actionStop = () => {
      actionPlay(); // Calling `actionPlay` with no source unsets the video
      updatePlaybackState('stop');
    }

    const getReplayDuration = () => {
      const framerate = (app.metadata.framerate ? app.metadata.framerate : 30);
      const frameDuration = 1 / framerate;
      const playbackRate = $player.playbackRate;
      const delta = 15;

      const val = -1 * (playbackRate === 0 ? frameDuration : delta * playbackRate);

      return val;
    }

    const getSkipDuration = () => {
      const framerate = (app.metadata.framerate ? app.metadata.framerate : 30);
      const frameDuration = 1 / framerate;
      const playbackRate = $player.playbackRate;
      const delta = 30;

      const val = (playbackRate === 0 ? frameDuration : delta * playbackRate);

      return val;
    }

    const actionReplay = () => seek(getReplayDuration());
    const actionSkip = () => seek(getSkipDuration());

    const seek = (delta) => {
      const duration = getMediaDuration();
      const newTime = $player.currentTime + delta;
      if (!duration) return $player.currentTime = Math.max(0, newTime);
      return $player.currentTime = minmax(0, newTime, duration);
    }

    const updateVolumeSupport = () => {
      const volumeValueKey = 0.97846; // Just a random number
      $player.volume = volumeValueKey;

      // `video.volume` is read-only on iOS. It falsely returns the value you set it
      // to if you check it within the same loop cycle. setTimeout must be used to
      // delay the check until the next event loop cycle.
      setTimeout(() => {
        if ($player.volume !== volumeValueKey) {
          $body.addClass('no-volume');
        } else {
          $body.removeClass('no-volume');
        }
      }, 1);
    }

    /* Fullscreen */
    const actionFullscreenToggle = () => (isFullscreen() ? exitFullscreen() : requestFullscreen());
    const isFullscreen = () => !!document.fullscreenElement || !!document.webkitFullscreenElement;
    const updateFullscreenAria = () => setAriaPressed('.btn-fullscreen', isFullscreen());
    const updateFullscreenSupport = () => {
      const $el = $playerContainer;

      if (
        (document.fullscreenEnabled       && $el.requestFullscreen) ||
        (document.webkitSupportsFullscreen && $el.webkitRequestFullscreen) ||
        $player.webkitEnterFullscreen
      ) {
        $('.btn-fullscreen').addClass('enabled');
      }
    }

    const requestFullscreen = () => {
      const $el = $playerContainer;
      const requests = ['requestFullscreen', 'webkitRequestFullscreen', 'msRequestFullscreen'];
      if (prefixRun($el, requests)) return true;

      if ($player.webkitEnterFullscreen) return $player.webkitEnterFullscreen();
    }

    const exitFullscreen = () => {
      const $el = document;
      const exits = ['exitFullscreen', 'webkitExitFullscreen', 'msExitFullscreen'];
      if (prefixRun($el, exits)) return true;

      if ($player.webkitExitFullScreen) return $player.webkitExitFullScreen();
    }

    /* Picture-in-picture */
    const actionPIPToggle = () => (isPIP() ? exitPIP() : requestPIP());
    const isPIP = () => !!document.pictureInPictureElement;
    const isPIPSupported = () => !!document.pictureInPictureEnabled;
    const updatePIPSupport = () => { if (isPIPSupported()) $('.btn-pip').addClass('enabled'); };
    const requestPIP = async () => {
      if (isPIPSupported()) {
        await $player.requestPictureInPicture();
        $html.addClass('is-pip')
        setAriaPressed('.btn-pip', true);
      } else {
        $html.removeClass('is-pip');
        setAriaPressed('.btn-pip', false);
      }
    };
    const exitPIP = () => {
      if (isPIPSupported()) document.exitPictureInPicture();
      $html.removeClass('is-pip');
      setAriaPressed('.btn-pip', false);
    };

    const prefixRun = ($el, methods) => {
      const supportedMethod = methods.find(method => $el[method]);
      if (typeof $el[supportedMethod] === 'function') return $el[supportedMethod]();

      return false;
    };


    var timeoutFadeout;
    $playerContainer.on('mousemove', async () => {
      const c = 'fadeout';
      $playerContainer.removeClass(c);

      clearTimeout(timeoutFadeout);
      timeoutFadeout = setTimeout(() => {
        $playerContainer.addClass(c);
      }, 3000);
    });

    /* Progress bar */
    const getProgressBarRelative = (e) => {
      const rect = $progressBar.getBoundingClientRect();
      if (!rect.width) return 0;
      const point = (e.touches && e.touches.length ? e.touches[0].clientX : e.clientX);
      if (isUndefined(point)) return 0;
      const raw = (point - rect.left) / rect.width;
      return minmax(0, raw, 1);
    }

    const actionProgressBarSeek = (e) => {
      const relative = getProgressBarRelative(e);
      $player.currentTime = getMediaDuration() * relative;
    }

    let isProgressDragging = false;
    const progressDragStart = (e) => {
      isProgressDragging = true;
      if (e.pointerId && $progressBar.setPointerCapture) {
        $progressBar.setPointerCapture(e.pointerId);
      }
      actionProgressBarSeek(e);
      e.preventDefault();
    }

    const progressDragMove = (e) => {
      if (!isProgressDragging) return;
      actionProgressBarSeek(e);
      e.preventDefault();
    }

    const progressDragEnd = (e) => {
      if (!isProgressDragging) return;
      isProgressDragging = false;
      actionProgressBarSeek(e);
      if (e.pointerId && $progressBar.releasePointerCapture) {
        try { $progressBar.releasePointerCapture(e.pointerId); } catch (err) {}
      }
      e.preventDefault();
    }

    const progressKeyStep = (delta) => {
      if (!getMediaDuration()) return;
      $player.currentTime = minmax(0, $player.currentTime + delta, getMediaDuration());
      updateProgress();
    }

    const progressKeyHandler = (e) => {
      if (getMediaDuration() <= 0) return;
      switch (e.key) {
        case 'ArrowLeft':
        case 'ArrowDown':
          e.preventDefault();
          progressKeyStep(-5);
          break;
        case 'ArrowRight':
        case 'ArrowUp':
          e.preventDefault();
          progressKeyStep(5);
          break;
        case 'PageUp':
          e.preventDefault();
          progressKeyStep(-30);
          break;
        case 'PageDown':
          e.preventDefault();
          progressKeyStep(30);
          break;
        case 'Home':
          e.preventDefault();
          $player.currentTime = 0;
          updateProgress();
          break;
        case 'End':
          e.preventDefault();
          $player.currentTime = getMediaDuration();
          updateProgress();
          break;
      }
    }

    const throttledUpdateHashAndTitle = throttle(() => {
      updateHash();
      updateTitle();
    }, app.options.updateRate.timeupdate * 25);

    const updateProgress = () => {
      const update = () => {
        updateRelativePosition(getRelativePosition());
        updateAbsolutePosition($player.currentTime);
        updateRanges();
        updateProgressBarAria();

        throttledUpdateHashAndTitle();
      }

      requestAnimationFrame(update);
    }

    const durationEl = $('.current-timestamp');
    const absolutePositionEl = durationEl;
    const relativePositionEl = $('.progress-bar');
    const trickPositionEl = $('.trick-container');

    const updateDuration              = (d) => setCSSVariableString('--duration',          secondsToString(d), durationEl);
    const updateAbsolutePosition      = (p) => setCSSVariableString('--absolute-position', secondsToString(p), absolutePositionEl);
    const updateRelativePosition      = (p) => setCSSVariableNumber('--relative-position', `${p * 100}%`, relativePositionEl);
    const updateTrickRelativePosition = (p) => setCSSVariableNumber('--trick-position'   , `${p * 100}%`, trickPositionEl);

    const progressBarTrickHover = (e) => {
      const relative = getProgressBarRelative(e);
      const absolute = relative * getMediaDuration();

      updateTrickRelativePosition(relative);

      if (absolute >= 0) trickSeek(absolute);
    }

    const trickSeek = (time) => {
      // Seek to whole seconds if the progress bar width in pixels is less
      // than the media duration. Improves trick seek performance.
      const width = getProgressBarWidth();
      const seekTime = ($trick.duration > width ? Math.floor(time) : time);

      if ($trick.readyState === 0) return;
      if (typeof $trick.fastSeek === 'function') return $trick.fastSeek(seekTime);

      return ($trick.currentTime = seekTime);
    }

    const syncTrickSrc = () => $trick.src = $player.src;

    const playFile = (file) => {
      if (!file) return;
      const url = URL.createObjectURL(file);
      const label = (file.name ? removeFileExtension(file.name) : urlToLabel(url));
      return setPlaylistFromItem({ url, label: (label ? label : urlToFilename(url)) }, true);
    };

    const actionOpenLocalFile = () => {
      const reader = new FileReader();
      const supportedTypes = app.options.supportedTypes.mime.join(',');
      const $input = $(`<input type="file" accept="${supportedTypes}"/>`);
      $input.on('change', () => playFile($input.files[0]));
      $input.click();
    }

    const actionDropLocalFile = (e) => {
      $playerContainer.removeClass('drop');
      e.preventDefault();
      const files = e.dataTransfer.files;
      if (files && files.length > 0) playFile(files[0]);
    }

    const setupDragAndDrop = () => {
      $playerContainer.on('dragenter', () => $playerContainer.addClass('drop'));
      $playerContainer.on('dragleave', (e) => {
        // Only remove `drop` class if the target is .player-container
        if (e.target === $playerContainer) $playerContainer.removeClass('drop');
      });
      $playerContainer.on('drop', actionDropLocalFile);
      $playerContainer.on('dragover', (e) => {
        e.dataTransfer.dropEffect = 'link';
        e.preventDefault();
      });
    }

    const setupControls = () => {
      setupPlayerEvents();
      setupPrimaryControls();
      setupModals();
      setupDragAndDrop();
      $body.on('paste', actionPasteAndPlay);
      updatePlaylistLoop();
      renderPlaylist();
    }

    const setupPrimaryControls = () => {
      $('.btn-subtitles').on('click', () => toggleModal($subtitles));
      $('.btn-fileinfo').on('click', () => toggleModal($fileinfo));
      $('.btn-playlist').on('click', () => toggleModal($playlist));
      $('.btn-settings').on('click', () => toggleModal($settings));
      $('.btn-playback-rate').on('click', actionPlaybackRate);
      $('.btn-rewind').on('click', actionReplay);
      $('.btn-fast-forward').on('click', actionSkip);
      $('.btn-stop').on('click', actionStop);
      $('.btn-previous').on('click', playPreviousTrack);
      $('.btn-next').on('click', playNextTrack);
      $('.btn-loop').on('click', togglePlaylistLoop);
      $('.btn-volume').on('click', actionVolume);
      delay(10, updateVolume);

      $('.btn-onedrive').on('click', openFromCloud('onedrive'));
      $('.btn-gdrive').on('click', openFromCloud('gdrive'));
      $('.btn-local-file').on('click', actionOpenLocalFile);

      $('.btn-play-pause').on('click', actionPlayPause);
      $('.btn-fullscreen').on('click', actionFullscreenToggle);
      updateFullscreenSupport();
      updateFullscreenAria();
      document.addEventListener('fullscreenchange', updateFullscreenAria);
      document.addEventListener('webkitfullscreenchange', updateFullscreenAria);
      $('.btn-pip').on('click', actionPIPToggle);
      updatePIPSupport();
      updateVolumeSupport();
      setAriaPressed('.btn-subtitles', false);
    }

    const setupModals = () => {
      $fileinfo.on('click', (e) => {
        // Only hide the fileinfo if the target element isn't `<span class="value"/>` so that you can copy value text
        const isValue = $(e.target).hasClass('value');
        if (!isValue) hideModals();
      });
      $help.on('click', hideModals);
      $playlist.on('click', (e) => e.stopImmediatePropagation());

      setupSettingsControls();
    }

    const setupSettingsControls = () => {
      const checkBoxes = [...document.querySelectorAll('.settings .modal-item')];
      checkBoxes.forEach((checkbox) => {
        $(checkbox).on('click', (e) => e.stopImmediatePropagation());
      });

      $('.modal-background-overlay').on('click', () => hideModals());
    }

    const setupPlayerEvents = () => {
      $player.on('loadedmetadata', () => {
        updateFileinfo();
        updateSubtitleToggleVisibility();
        applySubtitlePositionPreference();
        setTimeout(applySubtitlePositionPreference, 0);
      });
      $player.on('loadeddata', syncTrickSrc);
      $player.on('timeupdate', throttle(updateProgress, app.options.updateRate.timeupdate));
      $player.on('pause', () => updatePlaybackState('pause'));
      $player.on('play',  () => {
        updatePlaybackState('play');
        markAutoSubtitlePlaybackStarted();
        if ($body.hasClass('is-audio')) schedulePlayerArtworkBackground($player.currentSrc);
        maybeAutoLoadSubtitles();
      });
      $player.on('ended', () => {
        updatePlaybackState('stop');
        advancePlaylist('ended');
      });
      $player.on('click', () => { if ($player.src.length > 0) actionPlayPause(); });
      $player.on('dblclick', actionFullscreenToggle);
      $player.on('volumechange', updateVolume);
      $player.on('ratechange', updatePlaybackRate);

      $progressBar.on('mousemove', throttle(progressBarTrickHover, app.options.updateRate.trickHover));
      if (window.PointerEvent) {
        $progressBar.on('pointerdown', progressDragStart);
        $progressBar.on('pointermove', progressDragMove);
        $progressBar.on('pointerup', progressDragEnd);
        $progressBar.on('pointercancel', progressDragEnd);
      } else {
        $progressBar.on('mousedown', (e) => {
          progressDragStart(e);
          const move = (ev) => progressDragMove(ev);
          const end = (ev) => {
            progressDragEnd(ev);
            window.removeEventListener('mousemove', move);
            window.removeEventListener('mouseup', end);
          };
          window.addEventListener('mousemove', move);
          window.addEventListener('mouseup', end);
        });
        $progressBar.on('touchstart', (e) => {
          progressDragStart(e);
          const move = (ev) => progressDragMove(ev);
          const end = (ev) => {
            progressDragEnd(ev);
            window.removeEventListener('touchmove', move);
            window.removeEventListener('touchend', end);
            window.removeEventListener('touchcancel', end);
          };
          window.addEventListener('touchmove', move, { passive: false });
          window.addEventListener('touchend', end);
          window.addEventListener('touchcancel', end);
        });
      }
      $progressBar.on('keydown', progressKeyHandler);

      if ($player.textTracks && $player.textTracks.addEventListener) {
        $player.textTracks.addEventListener('addtrack', () => {
          setTimeout(applySubtitlePositionPreference, 0);
        });
      }
    }

    const keyboardBroker = (e) => {
      // Don't handle keyboard combinations
      if (e.ctrlKey || e.altKey) return;
      const target = e.target;
      if (target && (target.isContentEditable || ['INPUT', 'TEXTAREA', 'SELECT'].includes(target.tagName))) return;
      if (target && target.classList && target.classList.contains('progress-bar')) return;
      if (document.querySelector('.modal.show') && e.key !== 'Escape') return;

      switch (e.key) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          e.preventDefault();
          const position = e.key / 10;
          $player.currentTime = $player.duration * position;
          break;
        case 'Backspace':
          e.preventDefault();
          const $firstLink = $('.links a');
          if ($firstLink) $firstLink.click();
          break;
        case 'PageUp':
          e.preventDefault();
          playPreviousTrack();
          break;
        case 'PageDown':
          e.preventDefault();
          playNextTrack();
          break;
        case 'ArrowLeft':
          e.preventDefault();
          actionReplay();
          break;
        case 'ArrowRight':
          e.preventDefault();
          actionSkip();
          break;
        case ' ':
          e.preventDefault();
          actionPlayPause();
          break;
        case 'i':
          toggleModal($fileinfo);
          break;
        case '?':
        case 'F1':
          e.preventDefault();
          toggleModal($help);
          break;
        case 's':
          toggleModal($subtitles);
          break;
        case 'Escape':
          hideModals();
          break;
        case 'f':
          actionFullscreenToggle();
          break;
        case 'r':
          actionPlaybackRate();
          break;
        case 'ContextMenu':
          // preventDefault must be performed on the `contextmenu` event (below
          // switch statement), not the keydown event
          toggleModal($settings);
          break;
      }
    }
    window.addEventListener('keydown', keyboardBroker);
    $html.on('contextmenu', (e) => e.preventDefault());

    const toggleModal = ($el) => {
      if ($el.hasClass('show')) {
        hideModals();
      } else if ($('.modal.show')) {
        hideModals();
        showModal($el);
      } else {
        showModal($el);
      }
    }

    const showModal = ($el) => {
      $el.addClass('show');
      if ($el === $subtitles) updateSubtitleDurations();
      $el.once('click', hideModals);
    }

    const hideModals = (e) => {
      if (e && $(e.target).hasClass('value')) return;

      const modals = [...document.querySelectorAll('.modal.show')];
      modals.forEach((el) => $(el).removeClass('show'));
    }

    const subtitlePersistedSettingKeys = [
      'auto-subtitles',
      'subtitle-font',
      'subtitle-size',
      'subtitle-position',
      'subtitle-color',
      'subtitle-background'
    ];
    const subtitleSettingKeys = new Set([
      ...subtitlePersistedSettingKeys,
      'subtitle-reset'
    ]);
    const isSubtitleSetting = (key) => subtitleSettingKeys.has(key);

    const renderSettingRows = (keys, useDefaults, itemClass = 'setting-item') => {
      return keys.reduce((acc, key) => {
        const setting = settings[key];
        const type = setting.type || 'checkbox';
        const value = (useDefaults && !isUndefined(setting.default) ? setting.default : setting.get());
        const isCheckbox = (type === 'checkbox');
        const isSelect = (type === 'select');
        const checked = (isCheckbox && value === true ? 'checked' : '');
        const attrs = (setting.attrs ? ` ${setting.attrs}` : '');

        var valueAttribute = '';

        if (typeof value !== 'boolean' && !isSelect) {
          if (setting.type === 'button') {
            valueAttribute = `value="${setting.buttonLabel}"`;
          } else if (setting.type === 'color') {
            if (typeof value === 'number') {
              valueAttribute = `value="${HSLToHex(value, 100, 50)}"`;
            } else {
              const fallback = (isString(setting.default) ? setting.default : '#ffffff');
              valueAttribute = `value="${escapeAttr(normalizeSubtitleColor(value, fallback))}"`;
            }
          } else {
            valueAttribute = `value="${escapeAttr(value)}"`;
          }
        }

        const control = (isSelect
          ? (() => {
              const options = (setting.options || [])
                .map((opt) => {
                  const optValue = (opt && typeof opt === 'object' ? opt.value : opt);
                  const optLabel = (opt && typeof opt === 'object' ? opt.label : opt);
                  const safeValue = escapeAttr(optValue);
                  const safeLabel = escapeHtml(optLabel);
                  const selected = (String(value) === String(optValue) ? ' selected' : '');
                  return `<option value="${safeValue}"${selected}>${safeLabel}</option>`;
                })
                .join('');
              return `<select class='setting-${key}'${attrs}>${options}</select>`;
            })()
          : `<input type="${type}" class='setting-${key}' ${valueAttribute} ${checked}${attrs}>`
        );

        return `${acc}
          <li class='modal-item ${itemClass}' title='${setting.desc}'><span class='key'>${setting.label}</span>
            <span class='desc'>
              <label>${control}<span class="metadata"></span></label>
            </span>
          </li>`;
      }, '');
    }

    const bindSettingControls = (keys) => {
      keys.forEach((key) => {
        const setting = settings[key];
        const $el = $(`.setting-${key}`);
        if (!$el) return;
        const $item = $el.closest('.modal-item');
        if ($item) $($item).on('click', (e) => e.stopImmediatePropagation());

        const changeEvent = setting.event || 'click';

        $el.on(changeEvent, () => {
          if ($el.attr('type') === 'button') {
            setting.set();
          } else {
            setting.update();
          }
        });

        $el.on('click', (e) => e.stopImmediatePropagation()); // Don't close the modal for clicks on a settings control
        setting.update();
      });
    }

    const renderSettingsControls = (useDefaults) => {
      const keys = Object.keys(settings).filter((key) => !isSubtitleSetting(key));
      const html = renderSettingRows(keys, useDefaults, 'setting-item');
      $settings.html(html);
      bindSettingControls(keys);
      return html;
    }

    const renderSubtitleSettingsControls = (useDefaults) => {
      if (!$subtitles) return '';
      const keys = Object.keys(settings).filter((key) => isSubtitleSetting(key));
      const rows = renderSettingRows(keys, useDefaults, 'setting-item subtitle-setting-item');
      const html = `<li class='modal-item subtitle-section-heading subtitle-settings-heading'>Subtitle display settings</li>${rows}`;
      const old = [...$subtitles.querySelectorAll('.subtitle-settings-heading, .subtitle-setting-item')];
      old.forEach((el) => $(el).remove());
      $subtitles.insertAdjacentHTML('beforeend', html);
      bindSettingControls(keys);
      return html;
    }

    const retrieveSetting = (key) => {
      const val = storageRetrieve(`setting-${key}`);

      if (+val == val) { // number
        return +val;
      } else if (val === 'true') { // Boolean true
        return true;
      } else if (val === 'false') { // Boolean false
        return false;
      } else { // Fallback to value if present, undefined otherwise
        return val || undefined;
      }
    };
    const persistSetting = (key, value) => storageStore(`setting-${key}`, value);
    const clearSetting = (key) => storageRemove(`setting-${key}`);
    const enumerateSettings = () => Object.keys(localStorage).filter((key) => key.startsWith('setting-')).map((key) => key.replace('setting-', ''));
    const resetSettings = () => {
      const settings = enumerateSettings();
      settings.forEach((setting) => clearSetting(setting));
    }
    const checkIncorrectDefaultHue = () => {
      const settings = {};
      Object.keys(localStorage)
        .filter((key) => key.startsWith('setting-'))
        .forEach((key) => settings[key] = storageRetrieve(key));

      if (settings['setting-blur'] === 'false' &&
          settings['setting-thumbnailing'] === 'false' &&
          settings['setting-animate'] === 'false' &&
          settings['setting-transitions'] === 'false' &&
          settings['setting-hue'] == '0'
      ) {
        resetSettings();
      }
    };
    checkIncorrectDefaultHue();

    const settings = {
      hue: {
        label: 'Theme color',
        desc: 'Set the theme color for player.html',
        event: 'input',
        type: 'color',
        default: getCSSVariable('--default-hue'),
        get: () => (typeof retrieveSetting('hue') !== 'undefined' ? retrieveSetting('hue') : settings.hue.default),
        set: async (val) => {
          persistSetting('hue', val);
          await updateHue(val);
        },
        update: async () => {
          const $el = $('.setting-hue');
          const hex = $el.value;
          const hsl = hexToHSL(hex);
          await settings.hue.set(hsl.h);
        }
      },
      blur: {
        label: 'UI Blur Effects',
        desc: 'Enable/diable blur effects in the UI',
        event: 'change',
        default: true,
        get: () => typeof retrieveSetting('blur') !== 'undefined' ? retrieveSetting('blur') : settings.blur.default,
        set: (val) => persistSetting('blur', val),
        update: () => {
          const $el = $('.setting-blur');
          const val = $el.checked;
          settings.blur.set(val);

          if (val) {
            try {
              delete $('html').dataset.blur;
            } catch (e) {}
          } else {
            $('html').dataset.blur = 'disabled';
          }
        }
      },
      transitions: {
        label: 'UI Transitions',
        desc: 'Enable/disable animated transitions in the UI',
        event: 'change',
        default: true,
        get: () => typeof retrieveSetting('transitions') !== 'undefined' ? retrieveSetting('transitions') : settings.transitions.default,
        set: (val) => persistSetting('transitions', val),
        update: () => {
          const $el = $('.setting-transitions');
          const val = $el.checked;
          settings.transitions.set(val);

          if (val) {
            try {
              delete $('html').dataset.transitions;
            } catch (e) {}
          } else {
            $('html').dataset['transitions'] = 'disabled';
          }
        }
      },
      'auto-subtitles': {
        label: 'Auto-load matching subtitles',
        desc: 'Automatically load a subtitle file that shares the video filename (e.g. .vtt or .srt).',
        event: 'change',
        default: getAutoSubtitleDefault(),
        get: () => typeof retrieveSetting('auto-subtitles') !== 'undefined' ? retrieveSetting('auto-subtitles') : settings['auto-subtitles'].default,
        set: (val) => persistSetting('auto-subtitles', val),
        update: () => {
          const $el = $('.setting-auto-subtitles');
          const val = $el.checked;
          settings['auto-subtitles'].set(val);
          if (val) {
            autoSubtitleAttemptedFor = '';
            maybeAutoLoadSubtitles();
          }
        }
      },
      'subtitle-font': {
        label: 'Subtitle font',
        desc: 'Set subtitle font family.',
        event: 'change',
        type: 'select',
        options: subtitleFontOptions,
        default: subtitleFontDefault,
        get: () => normalizeSubtitleFont(retrieveSetting('subtitle-font')),
        set: (val) => persistSetting('subtitle-font', normalizeSubtitleFont(val)),
        update: () => {
          const $el = $('.setting-subtitle-font');
          const val = normalizeSubtitleFont($el.value);
          $el.value = val;
          settings['subtitle-font'].set(val);
          applySubtitleStyleSettings();
        }
      },
      'subtitle-size': {
        label: 'Subtitle size',
        desc: 'Set subtitle font size.',
        event: 'change',
        type: 'select',
        options: subtitleSizeOptions,
        default: subtitleSizeDefault,
        get: () => normalizeSubtitleSize(retrieveSetting('subtitle-size')),
        set: (val) => persistSetting('subtitle-size', normalizeSubtitleSize(val)),
        update: () => {
          const $el = $('.setting-subtitle-size');
          const val = normalizeSubtitleSize($el.value);
          $el.value = val;
          settings['subtitle-size'].set(val);
          applySubtitleStyleSettings();
        }
      },
      'subtitle-position': {
        label: 'Subtitle position',
        desc: 'Fallback vertical position used only when cues have no authored line setting.',
        event: 'change',
        type: 'select',
        options: subtitlePositionOptions,
        default: subtitlePositionDefault,
        get: () => normalizeSubtitlePosition(retrieveSetting('subtitle-position')),
        set: (val) => persistSetting('subtitle-position', normalizeSubtitlePosition(val)),
        update: () => {
          const $el = $('.setting-subtitle-position');
          const val = normalizeSubtitlePosition($el.value);
          $el.value = String(val);
          settings['subtitle-position'].set(val);
          applySubtitlePositionPreference();
        }
      },
      'subtitle-color': {
        label: 'Subtitle color',
        desc: 'Set subtitle text color.',
        event: 'input',
        type: 'color',
        default: subtitleColorDefault,
        get: () => normalizeSubtitleColor(retrieveSetting('subtitle-color'), subtitleColorDefault),
        set: (val) => persistSetting('subtitle-color', normalizeSubtitleColor(val, subtitleColorDefault)),
        update: () => {
          const $el = $('.setting-subtitle-color');
          const val = normalizeSubtitleColor($el.value, subtitleColorDefault);
          $el.value = val;
          settings['subtitle-color'].set(val);
          applySubtitleStyleSettings();
        }
      },
      'subtitle-background': {
        label: 'Subtitle background',
        desc: 'Set subtitle background color.',
        event: 'input',
        type: 'color',
        default: subtitleBackgroundDefault,
        get: () => normalizeSubtitleColor(retrieveSetting('subtitle-background'), subtitleBackgroundDefault),
        set: (val) => persistSetting('subtitle-background', normalizeSubtitleColor(val, subtitleBackgroundDefault)),
        update: () => {
          const $el = $('.setting-subtitle-background');
          const val = normalizeSubtitleColor($el.value, subtitleBackgroundDefault);
          $el.value = val;
          settings['subtitle-background'].set(val);
          applySubtitleStyleSettings();
        }
      },
      'subtitle-reset': {
        label: 'Reset subtitle settings',
        buttonLabel: 'Reset',
        desc: 'Reset subtitle-specific settings to their defaults.',
        event: 'click',
        type: 'button',
        get: () => {},
        set: () => {
          subtitlePersistedSettingKeys.forEach((key) => clearSetting(key));
          renderSubtitleSettingsControls(true);
        },
        update: () => {}
      },
      thumbnailing: {
        label: 'Generate Thumbnails',
        desc: 'Generate thumbnails for video listings. It may use a lot of bandwidth, especially in large folders of videos. Turn off if it causes playback problems.',
        event: 'change',
        default: true,
        get: () => typeof retrieveSetting('thumbnailing') !== 'undefined' ? retrieveSetting('thumbnailing') : settings.thumbnailing.default,
        set: (val) => persistSetting('thumbnailing', val),
        update: () => {
          const $el = $('.setting-thumbnailing');
          const val = $el.checked;
          settings.thumbnailing.set(val);
          if (!val) {
            clearThumbnailQueue();
          } else {
            populateThumbnails();
          }
        }
      },
      animate: {
        label: 'Animate Thumbnails',
        desc: 'Generate animated thumbnails. Disable this to save bandwidth and localStorage space.',
        event: 'change',
        default: true,
        get: () => typeof retrieveSetting('animate') !== 'undefined' ? retrieveSetting('animate') : settings.animate.default,
        set: (val) => persistSetting('animate', val),
        update: () => {
          const $el = $('.setting-animate');
          const val = $el.checked;
          settings.animate.set(val);

          if (val) {
            $html.removeClass('no-thumbnail-animation');
          } else {
            $html.addClass('no-thumbnail-animation');
          }
        }
      },
      'playlist-depth': {
        label: 'Playlist folder depth',
        desc: 'How many folder levels to include when adding a folder to the playlist (1 = current folder only).',
        event: 'change',
        type: 'select',
        options: [1, 2, 3],
        default: playlistFolderDepthDefault,
        get: () => normalizePlaylistFolderDepth(retrieveSetting('playlist-depth')),
        set: (val) => persistSetting('playlist-depth', val),
        update: () => {
          const $el = $('.setting-playlist-depth');
          const val = normalizePlaylistFolderDepth($el.value);
          $el.value = val;
          settings['playlist-depth'].set(val);
        }
      },
      cache: {
        label: 'Thumbnail cache',
        buttonLabel: 'Clear',
        desc: 'Amount of localStorage space in your browser that is being used to cache thumbnails',
        event: 'click',
        type: 'button',
        get: () => Math.floor(videoThumbnail.cacheSize() / 1024),
        set: () => {
          videoThumbnail.clearCache();
          settings.cache.update();
        },
        update: () => {
          const size = settings.cache.get();
          const formattedSize = addCommas(size);
          $('.setting-cache + .metadata').html(formattedSize);
        }
      },
      reset: {
        label: 'Reset to defaults',
        buttonLabel: 'Reset',
        desc: 'Reset all settings to their defaults',
        event: 'click',
        type: 'button',
        get: () => {},
        set: () => {
          resetSettings();
          renderSettingsControls(true);
          renderSubtitleSettingsControls(true);
        },
        update: () => {}
      },
    }

    const getHeaderData = async (url) => {
      const opts = {
        method: 'HEAD',
        mode: 'cors',
      }

      const responseHeaders = (h) => {
        const response = {};

        if (h.has('Content-Length')) response.size =     h.get('Content-Length');
        if (h.has('Content-Type'))   response.mimeType = h.get('Content-Type');
        if (h.has('Last-Modified'))  response.date =     h.get('Last-Modified');

        return response;
      }

      // Attempt with method = HEAD first
      try {
        const f = await fetch(url, opts);
        return responseHeaders(f.headers);
      } catch (e) {
        // Fallback on method = GET
        try {
          opts.method = 'GET';
          const f = await fetch(url, opts);
          return responseHeaders(f.headers);
        } catch (e) {
          console.warn(e);
          return {};
        }
      }
    }

    const getFramerate = async () => {
      const frame1 = await requestVideoFrame();

      // Wait a few extra frames to make estimate more accurate
      for (var i = 0; i < 10; i++) {
        const waitFrame = await requestVideoFrame();
      }

      const frame2 = await requestVideoFrame();

      const frames = frame2.metadata.presentedFrames - frame1.metadata.presentedFrames;
      const duration = (frame2.metadata.mediaTime - frame1.metadata.mediaTime);
      const fps = frames / duration;

      return fps;
    }

    const requestVideoFrame = () => {
      if (!supportsVideoFrameCallback()) return;

      const p = new Promise((resolve, reject) => {
        $player.requestVideoFrameCallback((now, metadata) => {
          resolve({now, metadata});
        });
      });

      return p;
    }

    const supportsVideoFrameCallback = () => 'requestVideoFrameCallback' in HTMLVideoElement.prototype;

    const updateFileinfo = async () => {
      const url = $player.currentSrc;
      const subtitles =   ($player.textTracks  && $player.textTracks.length  ? $player.textTracks.length  : 0);
      const audioTracks = ($player.audioTracks && $player.audioTracks.length ? $player.audioTracks.length : 1);

      const metadata = {
        name: urlToFilename(url),
        url: url,
        duration: $player.duration,
        width: $player.videoWidth,
        height: $player.videoHeight,
        subtitles: subtitles,
        audioTracks: audioTracks,
      };

      const headerData = await getHeaderData(url);
      if (headerData.size) metadata.bitrate = headerData.size / $player.duration;

      const headerKeys = Object.keys(headerData);
      headerKeys.forEach((k) => metadata[k] = headerData[k]);

      if (!isAudio(url) && supportsVideoFrameCallback()) metadata.framerate = await getFramerate($player);

      const mapping = {
        name: { name: 'Filename', format: (v) => decodeURIComponent(v)},
        url: 'URL',
        size: {name: 'Size', format: (v) => `${limitPrecision(v / 1024 / 1024, 1)}MB`},
        mimeType: 'Type',
        duration: {name: 'Duration (seconds)', format: (v) => limitPrecision(v, 2)},
        bitrate: {name: 'Bitrate', format: (v) => `${limitPrecision(v * 8 / 1024, 0)}kbps`},
        date: { name: 'Date', format: (d) => dateFormat(new Date(d))},
        framerate: {name: 'Estimated Framerate', format: (v) => `${limitPrecision(v, 3)}fps`},
        width: 'Width',
        height: 'Height',
        subtitles: 'Embedded Subtitles',
        audioTracks: 'Audio Tracks'
      }
      app.metadata = metadata;

      // Generate HTML for each fileinfo metadata item
      var html = '';
      const metadataKeys = Object.keys(metadata);
      metadataKeys.forEach((key) => {
        const map = mapping[key];
        const label = (typeof map === 'object' ? map.name : map);
        const value = (typeof map === 'object' && typeof map.format === 'function' ? map.format(metadata[key]) : metadata[key]);
        html += `<li class='fileinfo-item modal-item ${key}'><span class='key'>${label}</span><span class="value">${value}</span></li>`;
      });

      $fileinfo.html(html);
    }

    const dateFormat = (d) => {
      const formattedDate = Intl.DateTimeFormat(undefined, {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric'
      }).format(d);
      return formattedDate;
    }

    const resetFileinfo = () => {
      $fileinfo.html('<li class="fileinfo-item modal-item">Metadata not yet loaded</li>');
      app.metadata = {};
    }
    $player.on('loadstart', resetFileinfo);

    const getSVGPoster = (hue) => {
      const h = (typeof hue === 'number' ? hue : getCSSVariable('--theme-hue'))
      const color = `hsl(${h}, 100%, 50%)`;

      const svg = `<?xml version='1.0' encoding='UTF-8' standalone='no'?>
        <svg  width='32' height='32' viewBox='9 7 32 33' version='1.1' xmlns='http://www.w3.org/2000/svg'>
          <path style='fill: ${color}' d='M 13.750134,8.4121203 38.167189,21.116929 c 1.592276,0.828502 2.211438,2.790929 1.382936,4.383205 -0.308051,0.592037 -0.790899,1.074885 -1.382936,1.382937 L 13.750134,39.58788 C 12.157858,40.416381 10.195431,39.797219 9.3669293,38.204943 9.125863,37.741644 9,37.227072 9,36.704809 V 11.295191 c 0,-1.7949254 1.455075,-3.25 3.25,-3.25 0.447654,0 0.889658,0.092471 1.298566,0.2706995 z m -1.153949,2.2177467 -0.110487,-0.04668 c -0.07579,-0.02509 -0.15535,-0.038 -0.235698,-0.038 -0.414214,0 -0.75,0.335786 -0.75,0.75 v 25.409618 c 0,0.120522 0.02904,0.23927 0.08468,0.346185 0.191193,0.367448 0.644061,0.510332 1.011509,0.319139 L 37.01324,24.665324 c 0.136624,-0.07109 0.24805,-0.182515 0.319139,-0.319139 0.191192,-0.367449 0.04831,-0.820316 -0.319139,-1.011509 z'/>
        </svg>`;

      const base64 = btoa(svg);
      return `data:image/svg+xml;base64,${base64}`;
    }

    const updatePlayerBackground = (hue) => {
      hue = (typeof hue === 'number' ? hue : retrieveSetting('hue'));
      const dataUri = getSVGPoster(hue);
      $player.style.backgroundImage = `url('${dataUri}')`;
    }

    let audioArtworkRequestId = 0;
    let audioArtworkActive = false;
    let audioArtworkForUrl = '';
    let audioArtworkTimeoutId = null;

    const getAudioThumbnailOptions = () => {
      const thumbnailOpts = app.options.thumbnails;
      const audioConfig = app.options.audioThumbnails || {};
      const audioConcurrency = Math.max(1, audioConfig.concurrency || 1);
      const sidecarConcurrency = Math.max(1, audioConfig.sidecarConcurrency || audioConcurrency);

      return {
        sourceStrategy: 'race',
        sidecarExts: ['jpg', 'jpeg'],
        sidecarValidate: 'auto',
        sidecarConcurrency: sidecarConcurrency,
        output: {
          type: 'dataURI',
          size: thumbnailOpts.size,
          mime: { ...thumbnailOpts.mime }
        },
        debug: isDebug()
      };
    };

    const getTileArtworkCssUrl = (url) => {
      const $tile = $(`.file[href='${url}']`);
      if (!$tile) return null;
      const value = $tile.style.getPropertyValue('--image-url-0');
      if (!value || value === 'none') return null;
      return { value: value.trim(), $tile };
    };

    const resetPlayerBackground = () => {
      audioArtworkRequestId += 1;
      audioArtworkActive = false;
      audioArtworkForUrl = '';
      if (audioArtworkTimeoutId) {
        clearTimeout(audioArtworkTimeoutId);
        audioArtworkTimeoutId = null;
      }
      updatePlayerBackground();
    };

    const schedulePlayerArtworkBackground = (url) => {
      if (!url) return;
      if (audioArtworkActive && audioArtworkForUrl === url) return;
      if (audioArtworkTimeoutId) clearTimeout(audioArtworkTimeoutId);
      audioArtworkTimeoutId = setTimeout(() => {
        audioArtworkTimeoutId = null;
        setPlayerArtworkBackground(url);
      }, 0);
    };

    const setPlayerArtworkBackground = async (url) => {
      const requestId = ++audioArtworkRequestId;
      audioArtworkActive = false;

      if (!url || (!isAudio(url) && !$body.hasClass('is-audio'))) {
        updatePlayerBackground();
        return;
      }

      const tileArtwork = getTileArtworkCssUrl(url);
      if (tileArtwork && tileArtwork.value) {
        $player.style.backgroundImage = tileArtwork.value;
        audioArtworkActive = true;
        audioArtworkForUrl = url;
        return;
      }

      if (typeof audioThumbnail !== 'function') {
        updatePlayerBackground();
        return;
      }

      try {
        const results = await audioThumbnail(url, getAudioThumbnailOptions());
        if (requestId !== audioArtworkRequestId) return;

        const best = (results && (results.best || results[0])) || null;
        if (best && best.URI) {
          const cssUrl = `url('${escapeCssUrl(best.URI)}')`;
          $player.style.backgroundImage = cssUrl;
          audioArtworkActive = true;
          audioArtworkForUrl = url;
          if (tileArtwork && tileArtwork.$tile && !hasPreRenderedThumbnail(tileArtwork.$tile)) {
            tileArtwork.$tile.style.setProperty('--image-url-0', cssUrl);
          }
          return;
        }
      } catch (e) {
        if (isDebug()) console.warn('Audio artwork generation failed', url, e);
      }

      if (requestId !== audioArtworkRequestId) return;
      updatePlayerBackground();
    };

    const getThemeColorBaseHSL = () => {
      const themeColorBase = getCSSVariable('--theme-color-base')
        .split(',')
        .map((s) => s.replace('%', '').trim());
      const h = +themeColorBase[0];
      const s = +themeColorBase[1];
      const l = +themeColorBase[2];

      return {h,s,l};
    }

    const updateHue = async (val) => {
      const hue = (isUndefined(val) ? retrieveSetting('hue') : val);
      setCSSVariableNumber('--theme-hue', hue, $html);

      const baseColor = getThemeColorBaseHSL();
      const hex = HSLToHex(hue, baseColor.s, baseColor.l);

      const meta = $('meta[name="theme-color"]');

      if (meta) {
        meta.attr('content', hex);
      } else {
        $('head').append(`<meta name="theme-color" content="${hex}">`);
      }

      if (!audioArtworkActive) updatePlayerBackground();
    }

    const isPlaying = () => (
      $player.currentTime > 0 &&
      !$player.paused &&
      !$player.ended
    );

    const hasPreRenderedThumbnail = (node) => node.style.getPropertyValue('--image-url-0').length > ('url(http://)').length;

    const setThumbnail = async (node, url) => {
      if (hasPreRenderedThumbnail(node)) return;
      const thumbnailOpts = app.options.thumbnails;

      const timestampList = (
        Array.isArray(thumbnailOpts.timestamps) && thumbnailOpts.timestamps.length > 0
          ? [...thumbnailOpts.timestamps]
          : [0]
      );
      const shouldAnimate = retrieveSetting('animate');
      const timestamps = (shouldAnimate ? timestampList : [timestampList[0]]);
      const frameCount = (shouldAnimate ? timestamps.length : 1);

      if (isAudio(url) && typeof audioThumbnail === 'function') {
        const audioOpts = getAudioThumbnailOptions();
        try {
          const results = await audioThumbnail(url, audioOpts);
          const best = (results && (results.best || results[0])) || null;
          if (best && best.URI) {
            const safeURI = escapeCssUrl(best.URI);
            for (let i = 0; i < frameCount; i++) {
              node.style.setProperty(`--image-url-${i}`, `url('${safeURI}')`);
            }
            return best;
          }
        } catch (e) {
          if (isDebug()) console.warn('Audio thumbnail generation failed', url, e);
        }
        return null;
      }

      const opts = {
        size: thumbnailOpts.size,
        mime: {...thumbnailOpts.mime},
        cache: thumbnailOpts.cache,
        timestamps: timestamps,
        cacheReadOnly: !thumbnailOpts.cache || isPlaying()
      }
      try {
        const thumbnails = await videoThumbnail(url, opts);
        settings.cache.update();

        if (thumbnails && thumbnails.length > 0) {
          thumbnails.forEach((thumbnail, i) => {
            if (thumbnail && thumbnail.URI && thumbnail.URI.length > 30) {
              node.style.setProperty(`--image-url-${i}`,`url('${thumbnail.URI}')`);
            }
          });

          return thumbnails[0];
        }
      } catch (e) {
        if (isDebug()) console.warn('Thumbnail generation failed', url, e);
        return null;
      }
    }

    const createAnimationCSS = () => {
      const timestamps = (
        Array.isArray(app.options.thumbnails.timestamps) && app.options.thumbnails.timestamps.length > 0
          ? [...app.options.thumbnails.timestamps]
          : [0]
      );
      const n = timestamps.length;
      const style = $('style[primary]');
      if (!style || !style.sheet) return;

      var animationRule = '@keyframes animateThumbnail {\r\n';
      if (n <= 1) {
        animationRule += `0% { background-image: var(--image-url-0); }\r\n`;
        animationRule += `100% { background-image: var(--image-url-0); }\r\n`;
      } else {
        const unit = (1 / (n - 1)) * 100;
        for (let i = 0; i < n; i++) {
          const percent = `${unit * i}%`;
          animationRule += `${percent} { background-image: var(--image-url-${i}); }\r\n`;
        }
      }
      animationRule += '}';

      style.sheet.insertRule(animationRule);

      setCSSVariableNumber('--thumbnail-timestamps', timestamps.length, $('html'));
    }

    const getTransitionDuration = () => {
      const styles = getComputedStyle($html);
      const rawDuration = styles.transitionDuration.toLowerCase();
      const reDuration = /([\d\.]+)(s|ms)+/;
      const parsed = reDuration.exec(rawDuration);

      const durationValue = parsed[1];
      const durationUnit = parsed[2];

      return (durationUnit === 's' ? durationValue * 1000 : durationValue);
    }

    // Third-party scripts
    // From: https://css-tricks.com/converting-color-spaces-in-javascript/
    const hexToHSL = (H) => {
        // Convert hex to RGB first
        let r = 0, g = 0, b = 0;
        if (H.length == 4) {
          r = "0x" + H[1] + H[1];
          g = "0x" + H[2] + H[2];
          b = "0x" + H[3] + H[3];
        } else if (H.length == 7) {
          r = "0x" + H[1] + H[2];
          g = "0x" + H[3] + H[4];
          b = "0x" + H[5] + H[6];
        }
        // Then to HSL
        r /= 255;
        g /= 255;
        b /= 255;
        let cmin = Math.min(r,g,b),
            cmax = Math.max(r,g,b),
            delta = cmax - cmin,
            h = 0,
            s = 0,
            l = 0;

        if (delta == 0)
          h = 0;
        else if (cmax == r)
          h = ((g - b) / delta) % 6;
        else if (cmax == g)
          h = (b - r) / delta + 2;
        else
          h = (r - g) / delta + 4;

        h = Math.round(h * 60);

        if (h < 0)
          h += 360;

        l = (cmax + cmin) / 2;
        s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
        s = +(s * 100).toFixed(1);
        l = +(l * 100).toFixed(1);

        return { h, s, l};
      }

      // From: https://css-tricks.com/converting-color-spaces-in-javascript/
      const HSLToHex = (h, s, l) => {
        s /= 100;
        l /= 100;

        let c = (1 - Math.abs(2 * l - 1)) * s,
            x = c * (1 - Math.abs((h / 60) % 2 - 1)),
            m = l - c/2,
            r = 0,
            g = 0,
            b = 0;

        if (0 <= h && h < 60) {
          r = c; g = x; b = 0;
        } else if (60 <= h && h < 120) {
          r = x; g = c; b = 0;
        } else if (120 <= h && h < 180) {
          r = 0; g = c; b = x;
        } else if (180 <= h && h < 240) {
          r = 0; g = x; b = c;
        } else if (240 <= h && h < 300) {
          r = x; g = 0; b = c;
        } else if (300 <= h && h < 360) {
          r = c; g = 0; b = x;
        }
        // Having obtained RGB, convert channels to hex
        r = Math.round((r + m) * 255).toString(16);
        g = Math.round((g + m) * 255).toString(16);
        b = Math.round((b + m) * 255).toString(16);

        // Prepend 0s, if necessary
        if (r.length == 1)
          r = "0" + r;
        if (g.length == 1)
          g = "0" + g;
        if (b.length == 1)
          b = "0" + b;

        return "#" + r + g + b;
      }

    // main()
    const main = async () => {
      window.addEventListener('unhandledrejection', (event) => {
        if (isAbortError(event.reason)) event.preventDefault();
      });

      const restoredPlaylist = restorePlaylistFromSession();

      setupControls();
      renderSettingsControls();
      renderSubtitleSettingsControls();
      applySubtitleStyleSettings();
      createAnimationCSS();
      updateVersionNumber();
      checkFileHandlerOpen();

      const hash = getHash();

      if (hash) {
        if (hash.media && hash.media.length > 1 && !hash.media.startsWith('blob:')) {
          $player.muted = true; /* Autoplay on load only works if it is muted */
          if (restoredPlaylist) {
            actionPlay(hash.media);
          } else {
            setPlaylistFromUrl(hash.media, true);
          }
        }

        if (hash.time && hash.time > 0) $player.currentTime = hash.time;

        if (hash.location && hash.location.length > 1) {
          hashState.location = hash.location;
          createLinks(hash.location);
        } else {
          createLinks();
        }
      }

      $(window).on('popstate', (e) => {
        const hash = getHash();
        if (hash && hash.location && hash.location.length > 1) createLinks(hash.location)
      });
    }

    main();
</script>
</body>
</html>
